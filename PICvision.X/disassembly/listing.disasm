Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-02-27 15:43:20

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout.c  ----------------------------------------
1:                 /* 
2:                  * File:   TVout.c
3:                  * Author: jacques Deschênes
4:                  * Description:  NTSC/PAL signal generator
5:                  * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
6:                  * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
7:                  * Created on 25 février 2014, 16:28
8:                  */
9:                 
10:                #include <stdio.h>
11:                #include <stdlib.h>
12:                #include <string.h>
13:                #include "TVout.h"
14:                
15:                
16:                #define HPERIOD 1016  // timer count for 15748Hz horizontal frequency ( no prescale)
17:                #define HPULSE 75 // 4,7µsec horizontal pulse width
18:                #define FIRST_VISIBLE 30 // première ligne visible
19:                #define LAST_VISIBLE (FIRST_VISIBLE+VPIXELS) // dernière ligne visible
20:                #define FRONT_PORCH  (1.5*FCY/1000000UL)
21:                #define F_PCHAR 1    // flag put_char() pending
22:                #define F_CLEAR 2    // flag clear_screen() pending
23:                #define F_CLREOL 4   // flag clear to end of line
24:                #define F_RETRACE 8 // flag screen in retrace phase
25:                
26:                #define QUEUE_SIZE 32  // put_char queue
27:                
28:                static unsigned int frame_line_cntr=0; // count line in video frame
29:                volatile static unsigned long frame_cntr=0; // number of frame since reset
30:                volatile static unsigned int flags;
31:                
32:                typedef union coord_type{
33:                    unsigned int yx;
34:                    struct{
35:                        unsigned char y;
36:                        unsigned char x;
37:                    };
38:                }coord_t;
39:                
40:                volatile static coord_t cursor_pos;
41:                
42:                volatile static char pchar_queue[QUEUE_SIZE];
43:                
44:                char video_buffer[LINES][COLUMNS];
45:                volatile static unsigned  head=0, tail=0;
46:                
47:                
48:                void  video_init(){ // initialisation sorties NTSC
49:                    T2CON=0; // désactivation TIMER2
0005FE  EB0280     CLR W5
000600  880885     MOV W5, T2CON
50:                    PR2 = HPERIOD;
000602  203F84     MOV #0x3F8, W4
000604  880864     MOV W4, PR2
51:                    // OC1 video sync
52:                    OC1R=HPULSE;
000606  2004B6     MOV #0x4B, W6
000608  880C16     MOV W6, OC1R
53:                    OC1RS=HPERIOD;
00060A  880C04     MOV W4, OC1RS
54:                    OC1CON=5; // mode 5, timer 2
00060C  200054     MOV #0x5, W4
00060E  880C24     MOV W4, OC1CON
55:                    //OC3 video delay timer black level fixer.
56:                    OC3R=2*HPULSE;
000610  200964     MOV #0x96, W4
000612  880C74     MOV W4, OC3R
57:                    OC3RS=HPERIOD-FRONT_PORCH;
000614  203E04     MOV #0x3E0, W4
000616  880C64     MOV W4, OC3RS
58:                    IFS0bits.OC1IF=0;
000618  A94084     BCLR IFS0, #2
59:                    IPC0bits.OC1IP=7;
00061A  207000     MOV #0x700, W0
00061C  B720A4     IOR IPC0
60:                    IPC4bits.CNIP=7;
00061E  270000     MOV #0x7000, W0
000620  B720AC     IOR IPC4
61:                    CNEN1bits.CN15IE=1;
000622  A8E061     BSET 0x61, #7
62:                    // timer 2 interrupt enabling
63:                    IFS0bits.T2IF=0;
000624  A9E084     BCLR IFS0, #7
64:                    IPC1bits.T2IP=7; // plus haute priorité
000626  B720A6     IOR IPC1
65:                    IEC0bits.T2IE=1;
000628  A8E094     BSET IEC0, #7
66:                    // SPI1 configuration (pixel output)
67:                    SPI1CON1=0;
00062A  881215     MOV W5, SPI1CON1
68:                    SPI1CON1bits.DISSCK=1;
00062C  A88243     BSET 0x243, #4
69:                    SPI1CON1bits.MSTEN=1;
00062E  A8A242     BSET SPI1CON1, #5
70:                    SPI1CON1bits.SPRE=7;
000630  2001C0     MOV #0x1C, W0
000632  B72242     IOR SPI1CON1
71:                    SPI1CON1bits.PPRE=2;
000634  801214     MOV SPI1CON1, W4
000636  A10004     BCLR W4, #0
000638  A01004     BSET W4, #1
00063A  881214     MOV W4, SPI1CON1
72:                    SPI1CON2=1;
00063C  200014     MOV #0x1, W4
00063E  881224     MOV W4, SPI1CON2
73:                    SPI1STATbits.SPIEN=1;
000640  A8E241     BSET 0x241, #7
74:                    T2CONbits.TON=1;
000642  A8E111     BSET 0x111, #7
75:                    cursor_pos.y=0;
000644  FD0280     EXCH W0, W5
000646  B7EAAC     MOV.B WREG, cursor_pos
000648  B7EAAD     MOV.B WREG, 0xAAD
00064A  FD0280     EXCH W0, W5
76:                    cursor_pos.x=0;
77:                }//horz_sync_init()
00064C  060000     RETURN
78:                
79:                void  wait_n_frame(unsigned n){
80:                unsigned long f0;
81:                    f0=frame_cntr+n;
00064E  805544     MOV frame_cntr, W4
000650  805555     MOV 0xAAA, W5
000652  420000     ADD W4, W0, W0
000654  4A80E0     ADDC W5, #0x0, W1
82:                    while (frame_cntr<f0);
000656  805544     MOV frame_cntr, W4
000658  805555     MOV 0xAAA, W5
00065A  500F84     SUB W0, W4, [W15]
00065C  588F85     SUBB W1, W5, [W15]
00065E  3EFFFB     BRA GTU, 0x656
83:                }//f()
000660  060000     RETURN
84:                
85:                void clear_screen(){ // clear screen
86:                    flags |= F_CLEAR;
000662  A82AA6     BSET flags, #1
87:                    while (flags & F_CLEAR);
000664  AB2AA6     BTST flags, #1
000666  3AFFFE     BRA NZ, 0x664
88:                }//f()
000668  060000     RETURN
89:                
90:                void clear_eol(){// clear line from cursor to end of line
91:                    flags |= F_CLREOL;
00066A  A84AA6     BSET flags, #2
92:                }//f()
00066C  060000     RETURN
93:                
94:                void move_cursor(unsigned line, unsigned column){
95:                    cursor_pos.y=line;
00066E  B7EAAC     MOV.B WREG, cursor_pos
96:                    cursor_pos.x=column;
000670  780001     MOV W1, W0
000672  B7EAAD     MOV.B WREG, 0xAAD
97:                }//f()
000674  060000     RETURN
98:                
99:                unsigned get_cursor(){
100:                   return cursor_pos.yx;
000676  805560     MOV cursor_pos, W0
101:               }//f()
000678  060000     RETURN
102:               
103:               void put_char(char c){// put character at current cursor position & move cursor forward
104:                   pchar_queue[tail++]=c;
00067A  805684     MOV tail, W4
00067C  20AB05     MOV #0xAB0, W5
00067E  7A7280     MOV.B W0, [W5+W4]
000680  E80204     INC W4, W4
000682  885684     MOV W4, tail
105:                   tail %= QUEUE_SIZE;
000684  2001F0     MOV #0x1F, W0
000686  B62AD0     AND tail
106:                   flags |= F_PCHAR;
000688  A80AA6     BSET flags, #0
107:               }//f()
00068A  060000     RETURN
108:               
109:               void print(const char *str){
00068C  781F88     MOV W8, [W15++]
00068E  780400     MOV W0, W8
110:                   while (*str){
000690  784018     MOV.B [W8], W0
000692  504FE0     SUB.B W0, #0x0, [W15]
000694  320004     BRA Z, 0x69E
000698  784058     MOV.B [++W8], W0
00069A  504FE0     SUB.B W0, #0x0, [W15]
00069C  3AFFFC     BRA NZ, 0x696
111:                       put_char(*str++);
000696  07FFF1     RCALL put_char
112:                   }
113:               }//f()
00069E  78044F     MOV [--W15], W8
0006A0  060000     RETURN
114:               
115:               void wait_while_printing(){
116:                   while (flags & F_PCHAR);
0006A2  AB0AA6     BTST flags, #0
0006A4  3AFFFE     BRA NZ, wait_while_printing
117:               }//f()
0006A6  060000     RETURN
118:               
119:               void scroll_up(){ //scroll screen 1 line up
120:                   memmove((char*)video_buffer,(char*)video_buffer[1],sizeof(char)*COLUMNS*(LINES-1));
0006A8  2028A2     MOV #0x28A, W2
0006AA  208191     MOV #0x819, W1
0006AC  208000     MOV #0x800, W0
0006AE  07FDF4     RCALL 0x298
121:                   memset((char*)video_buffer[LINES-1],0,sizeof(char)*COLUMNS);
0006B0  20A8A4     MOV #0xA8A, W4
0006B2  090018     REPEAT #0x18
0006B4  EB5A00     CLR.B [W4++]
122:               }//f()
0006B6  060000     RETURN
123:               
124:               void cursor_forward(){
125:                   cursor_pos.x++;
0006B8  EC6AAD     INC.B 0xAAD
126:                   if (cursor_pos.x>=COLUMNS){
0006BA  20AAD4     MOV #0xAAD, W4
0006BC  784214     MOV.B [W4], W4
0006BE  524FF8     SUB.B W4, #0x18, [W15]
0006C0  360008     BRA LEU, 0x6D2
127:                       cursor_pos.x=0;
0006C2  EF6AAD     CLR.B 0xAAD
128:                       cursor_pos.y++;
0006C4  EC6AAC     INC.B cursor_pos
129:                       if (cursor_pos.y>=LINES){
0006C6  20AAC4     MOV #0xAAC, W4
0006C8  784214     MOV.B [W4], W4
0006CA  524FFA     SUB.B W4, #0x1A, [W15]
0006CC  360002     BRA LEU, 0x6D2
130:                           cursor_pos.y--;
0006CE  ED6AAC     DEC.B cursor_pos
131:                           scroll_up();
0006D0  07FFEB     RCALL scroll_up
132:                       }//if
133:                   }//if
134:               }//f()
0006D2  060000     RETURN
135:               
136:               // video sync signal generation
137:               void __attribute__((interrupt,no_auto_psv,shadow)) _T2Interrupt(void){
0006D4  FEA000     PUSH.S
0006D6  F80036     PUSH RCOUNT
0006D8  BE9F84     MOV.D W4, [W15++]
0006DA  BE9F86     MOV.D W6, [W15++]
138:                   frame_line_cntr++;
0006DC  805524     MOV frame_line_cntr, W4
0006DE  E80204     INC W4, W4
0006E0  885524     MOV W4, frame_line_cntr
139:                   switch (frame_line_cntr){
0006E2  520FFE     SUB W4, #0x1E, [W15]
0006E4  320016     BRA Z, 0x712
0006E6  3E0005     BRA GTU, 0x6F2
0006E8  520FE1     SUB W4, #0x1, [W15]
0006EA  32000A     BRA Z, 0x700
0006EC  520FE4     SUB W4, #0x4, [W15]
0006EE  3A0020     BRA NZ, 0x730
0006F0  37000B     BRA 0x708
0006F2  200F65     MOV #0xF6, W5
0006F4  520F85     SUB W4, W5, [W15]
0006F6  320011     BRA Z, 0x71A
0006F8  4282F1     ADD W5, #0x11, W5
0006FA  520F85     SUB W4, W5, [W15]
0006FC  3A0019     BRA NZ, 0x730
0006FE  370010     BRA 0x720
140:                       case 1:
141:                           OC1R=HPERIOD-HPULSE;
000700  203AD4     MOV #0x3AD, W4
000702  880C14     MOV W4, OC1R
142:                           OC3CON=0;
000704  EF2190     CLR OC3CON
143:                           break;
000706  37004F     BRA 0x7A6
144:                       case 4:
145:                           OC3CON=5;
000708  200054     MOV #0x5, W4
00070A  880C84     MOV W4, OC3CON
146:                           OC1R=HPULSE;
00070C  2004B4     MOV #0x4B, W4
00070E  880C14     MOV W4, OC1R
147:                           break;
000710  37004A     BRA 0x7A6
148:                       case FIRST_VISIBLE:
149:                           IFS1bits.CNIF=0;
000712  A96086     BCLR IFS1, #3
150:                           IEC1bits.CNIE=1;
000714  A86096     BSET IEC1, #3
151:               
152:                           flags &= ~F_RETRACE;
000716  A96AA6     BCLR flags, #3
153:                           break;
000718  370046     BRA 0x7A6
154:                       case LAST_VISIBLE:
155:                           IEC1bits.CNIE=0;
00071A  A96096     BCLR IEC1, #3
156:                           flags |= F_RETRACE;
00071C  A86AA6     BSET flags, #3
157:                           break;
00071E  370043     BRA 0x7A6
158:                       case 263:
159:                           frame_line_cntr=0;
000720  EF2AA4     CLR frame_line_cntr
160:                           frame_cntr++;
000722  805544     MOV frame_cntr, W4
000724  805555     MOV 0xAAA, W5
000726  420261     ADD W4, #0x1, W4
000728  4A82E0     ADDC W5, #0x0, W5
00072A  885544     MOV W4, frame_cntr
00072C  885555     MOV W5, 0xAAA
161:                           break;
00072E  37003B     BRA 0x7A6
162:                       default:
163:                           if (flags & F_RETRACE){
000730  AB6AA6     BTST flags, #3
000732  320039     BRA Z, 0x7A6
164:                               if (flags & F_CLEAR){
000734  AB2AA6     BTST flags, #1
000736  32000A     BRA Z, 0x74C
165:                                   memset((char*)video_buffer,0,sizeof(char)*LINES*COLUMNS);
000738  208005     MOV #0x800, W5
00073A  0902A2     REPEAT #0x2A2
00073C  EB5A80     CLR.B [W5++]
166:                                   flags &= ~F_CLEAR;
00073E  A92AA6     BCLR flags, #1
167:                                   cursor_pos.y=0;
000740  EB4200     CLR.B W4
000742  FD0200     EXCH W0, W4
000744  B7EAAC     MOV.B WREG, cursor_pos
000746  B7EAAD     MOV.B WREG, 0xAAD
000748  FD0200     EXCH W0, W4
00074A  37002D     BRA 0x7A6
168:                                   cursor_pos.x=0;
169:                               } else if (flags & F_CLREOL){
00074C  AB4AA6     BTST flags, #2
00074E  320012     BRA Z, 0x774
170:                                   memset((char*)video_buffer[cursor_pos.y]+cursor_pos.x,
000754  BFCAAC     MOV.B cursor_pos, WREG
000756  20AAD5     MOV #0xAAD, W5
000758  784295     MOV.B [W5], W5
00075E  B3C192     MOV #0x19, W2
000760  BC4004     MUL.B WREG2
000762  FB8285     ZE W5, W5
000764  410005     ADD W2, W5, W0
000766  208006     MOV #0x800, W6
000768  400006     ADD W0, W6, W0
00076A  780104     MOV W4, W2
00076C  EB0080     CLR W1
00076E  07FDA5     RCALL 0x2BA
171:                                           0,sizeof(char)*(COLUMNS-cursor_pos.x));
000750  20AAD4     MOV #0xAAD, W4
000752  784214     MOV.B [W4], W4
00075A  FB8204     ZE W4, W4
00075C  120279     SUBR W4, #0x19, W4
172:                                   flags &= ~F_CLREOL;
000770  A94AA6     BCLR flags, #2
000772  370019     BRA 0x7A6
173:                               }else if (flags & F_PCHAR){
000774  AB0AA6     BTST flags, #0
000776  320017     BRA Z, 0x7A6
174:                                   video_buffer[cursor_pos.y][cursor_pos.x]=pchar_queue[head]-32;
000778  BFCAAC     MOV.B cursor_pos, WREG
00077A  20AAD5     MOV #0xAAD, W5
00077C  784295     MOV.B [W5], W5
00077E  805574     MOV head, W4
000780  20AB06     MOV #0xAB0, W6
000782  7A4266     MOV.B [W6+W4], W4
000784  FB8285     ZE W5, W5
000786  B3C192     MOV #0x19, W2
000788  BC4004     MUL.B WREG2
00078A  410285     ADD W2, W5, W5
00078C  208006     MOV #0x800, W6
00078E  430285     ADD W6, W5, W5
000790  B3CE06     MOV #0xE0, W6
000792  424A86     ADD.B W4, W6, [W5]
175:                                   cursor_forward();
000794  07FF91     RCALL cursor_forward
176:                                   head++;
000796  EC2AAE     INC head
177:                                   head %= QUEUE_SIZE;
000798  2001F0     MOV #0x1F, W0
00079A  B62AAE     AND head
178:                                   if (head==tail){
00079C  805575     MOV head, W5
00079E  805684     MOV tail, W4
0007A0  528F84     SUB W5, W4, [W15]
0007A2  3A0001     BRA NZ, 0x7A6
179:                                       flags &= ~F_PCHAR;
0007A4  A90AA6     BCLR flags, #0
180:                                   }
181:                               }//if
182:                           }//if
183:                           break;
184:                   }//switch
185:                   IFS0bits.T2IF=0;
0007A6  A9E084     BCLR IFS0, #7
186:               }// _T2Interrupt()
0007A8  BE034F     MOV.D [--W15], W6
0007AA  BE024F     MOV.D [--W15], W4
0007AC  F90036     POP RCOUNT
0007AE  FE8000     POP.S
0007B0  064000     RETFIE
187:               
188:               void __attribute__((interrupt,no_auto_psv,shadow)) _CNInterrupt(void){
0007B2  FEA000     PUSH.S
0007B4  BE9F84     MOV.D W4, [W15++]
0007B6  BE9F86     MOV.D W6, [W15++]
0007CE  4283F9     ADD W5, #0x19, W7
189:                   int y,x,l;
190:                   char *b;
191:                   if (PORTBbits.RB11){
0007B8  801655     MOV PORTB, W5
0007BA  208004     MOV #0x800, W4
0007BC  628204     AND W5, W4, W4
0007BE  320016     BRA Z, 0x7EC
192:                       y=(frame_line_cntr-FIRST_VISIBLE)>>3;
0007C0  805524     MOV frame_line_cntr, W4
0007C2  52027E     SUB W4, #0x1E, W4
0007C6  DE2243     LSR W4, #3, W4
193:                       l=(frame_line_cntr-FIRST_VISIBLE)&7;
0007C4  620067     AND W4, #0x7, W0
194:                       b=(char*)&video_buffer[y];
0007C8  B92279     MUL.SU W4, #25, W4
0007CA  208006     MOV #0x800, W6
0007CC  430284     ADD W6, W4, W5
195:                       for (x=0;x<COLUMNS;x++){
0007E2  528F87     SUB W5, W7, [W15]
0007E4  3AFFF6     BRA NZ, 0x7D2
196:                           while (SPI1STATbits.SPITBF);
0007D2  AB2240     BTST SPI1STAT, #1
0007D4  3AFFFE     BRA NZ, 0x7D2
197:                           SPI1BUF=font6x8[(int)*b++][l];
0007D0  282C86     MOV #0x82C8, W6
0007D6  FB0235     SE [W5++], W4
0007D8  DD2243     SL W4, #3, W4
0007DA  420200     ADD W4, W0, W4
0007DC  7A4266     MOV.B [W6+W4], W4
0007DE  FB8204     ZE W4, W4
0007E0  881244     MOV W4, SPI1BUF
198:                       }//for
199:                       while (SPI1STATbits.SPITBF);
0007E6  AB2240     BTST SPI1STAT, #1
0007E8  3AFFFE     BRA NZ, 0x7E6
200:                       SPI1BUF=0;
0007EA  EF2248     CLR SPI1BUF
201:                   }
202:                   IFS1bits.CNIF=0;
0007EC  A96086     BCLR IFS1, #3
203:               }// _CNInterrupt
0007EE  BE034F     MOV.D [--W15], W6
0007F0  BE024F     MOV.D [--W15], W4
0007F2  FE8000     POP.S
0007F4  064000     RETFIE
204:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /* 
2:                  * File:   PICvision.c
3:                  * Author: jacques Deschênes
4:                  * Description:  a simple video game console on PIC24FJ64GA002 MCU
5:                  *               inpiration come from HACKvision console.
6:                  *               REF: https://nootropicdesign.com/hackvision/
7:                  *     - display  NTSC/PAL  monochrome
8:                  *     - resolution  200x216 pixels
9:                  *     - controls: 2 SNES paddle  (cheap and easy to find.)
10:                 *     - audio out:  monophonic  PWM DAC
11:                 *
12:                 * Created on 25 février 2014, 16:22
13:                 */
14:                
15:                #include <stdio.h>
16:                #include <stdlib.h>
17:                #include <PPS.h>
18:                
19:                #include "hardwareProfile.h"
20:                #include "TVout.h"
21:                
22:                // PIC24FJ64GA002 Configuration Bit Settings
23:                // CONFIG2
24:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
25:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
26:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
27:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
28:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
29:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
30:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
31:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
32:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
33:                
34:                // CONFIG1
35:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
36:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
37:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
38:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
39:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
40:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
41:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
42:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
43:                
44:                void HardwareConfig(){
45:                    PPSUnLock;
0007F6  803A16     MOV OSCCON, W6
0007F8  B20BF6     AND #0xBF, W6
0007FA  200464     MOV #0x46, W4
0007FC  200575     MOV #0x57, W5
0007FE  207427     MOV #0x742, W7
000800  784B84     MOV.B W4, [W7]
000802  784B85     MOV.B W5, [W7]
000804  784B86     MOV.B W6, [W7]
46:                    PPSOutput(PPS_RP5,PPS_OC2);   // audio output
000806  803626     MOV RPOR2, W6
000808  2E0FF7     MOV #0xE0FF, W7
00080A  630307     AND W6, W7, W6
00080C  213000     MOV #0x1300, W0
00080E  730300     IOR W6, W0, W6
000810  883626     MOV W6, RPOR2
47:                    PPSOutput(PPS_RP6,PPS_OC1);   // video sync
000812  803630     MOV RPOR3, W0
000814  2FFE06     MOV #0xFFE0, W6
000816  600006     AND W0, W6, W0
000818  B30120     IOR #0x12, W0
00081A  883630     MOV W0, RPOR3
48:                    PPSOutput(PPS_RP7,PPS_SDO1);  // video pixels
00081C  803630     MOV RPOR3, W0
00081E  600387     AND W0, W7, W7
000820  207000     MOV #0x700, W0
000822  738380     IOR W7, W0, W7
000824  883637     MOV W7, RPOR3
49:                    PPSOutput(PPS_RP10,PPS_OC3);  // video pedestal (black level)
000826  803657     MOV RPOR5, W7
000828  638306     AND W7, W6, W6
00082A  B30146     IOR #0x14, W6
00082C  883656     MOV W6, RPOR5
50:                    TRISBbits.TRISB5=0;
00082E  A9A2C8     BCLR TRISB, #5
51:                    TRISBbits.TRISB6=0;
000830  A9C2C8     BCLR TRISB, #6
52:                    TRISBbits.TRISB7=0;
000832  A9E2C8     BCLR TRISB, #7
53:                    TRISBbits.TRISB10=0;
000834  A942C9     BCLR 0x2C9, #2
54:                    TRISBbits.TRISB11=1;
000836  A862C9     BSET 0x2C9, #3
55:                    PPSLock;
000838  803A16     MOV OSCCON, W6
00083A  A06006     BSET W6, #6
00083C  207427     MOV #0x742, W7
00083E  784B84     MOV.B W4, [W7]
000840  784B85     MOV.B W5, [W7]
000842  784B86     MOV.B W6, [W7]
56:                }//f()
000844  060000     RETURN
57:                
58:                const char msg[]="hello world!";
59:                const char numbers[]=" 234567890123456789012|";
60:                
61:                int main(void) {
000846  BE9F88     MOV.D W8, [W15++]
000848  781F8A     MOV W10, [W15++]
62:                    int y;
63:                    HardwareConfig();
00084A  07FFD5     RCALL HardwareConfig
64:                    video_init();
00084C  07FED8     RCALL video_init
65:                    for (y=0;y<LINES;y++){
00084E  EB0400     CLR W8
000870  E80408     INC W8, W8
000872  540FFB     SUB W8, #0x1B, [W15]
000874  3AFFEF     BRA NZ, 0x854
000876  37FFFF     BRA 0x876
66:                        move_cursor(y,0);
000854  EB0080     CLR W1
000856  780008     MOV W8, W0
000858  07FF0A     RCALL move_cursor
67:                        put_char(96+' ');
000850  B3C809     MOV #0x80, W9
00085A  784009     MOV.B W9, W0
00085C  07FF0E     RCALL put_char
68:                        wait_n_frame(1);
00085E  200010     MOV #0x1, W0
000860  07FEF6     RCALL wait_n_frame
69:                        move_cursor(y,COLUMNS-1);
000862  200181     MOV #0x18, W1
000864  780008     MOV W8, W0
000866  07FF03     RCALL move_cursor
70:                        put_char(97+' ');
000852  B3C81A     MOV #0x81, W10
000868  78400A     MOV.B W10, W0
00086A  07FF07     RCALL put_char
71:                        wait_n_frame(1);
00086C  200010     MOV #0x1, W0
00086E  07FEEF     RCALL wait_n_frame
72:                    }
73:                    while (1){
74:                        
75:                    }//while
76:                    return (EXIT_SUCCESS);
77:                }//main()
78:                
79:                
