Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-03-07 22:54:06

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/timers.c  ---------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 *  NAME: timers.c
21:                 *  DATE CREATED: 2014-02-21
22:                 *  AUTHOR: Jacques Deschênes
23:                 *  DESCRIPTION: create timers with callback. TIMER1 is used as a system timer that
24:                 *               ticks at regular interval. The ISR of TIMER1 manage created timers.
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "timers.h"
29:                
30:                #define F_TMR_USED 1
31:                #define F_TMR_HALTED 2
32:                #define F_TMR_REPEAT 4
33:                #define TMR_RUNNING 1
34:                
35:                
36:                typedef struct timer_type{
37:                    unsigned status;    // slot used,  timer halted
38:                    unsigned delay;    // timer interval
39:                    unsigned countdown;
40:                    timer_handler_t *handler; // timer callback handler
41:                }timer_t;
42:                
43:                volatile static timer_t timers[MAX_TIMERS];
44:                volatile static unsigned long ticks;
45:                
46:                void timers_init(unsigned ticks_per_second){
0017CE  BE9F88     MOV.D W8, [W15++]
0017D0  781F8A     MOV W10, [W15++]
0017D2  780500     MOV W0, W10
47:                    unsigned long quotient;
48:                    unsigned prescale;
49:                    int i;
50:                    for (i=0;i<MAX_TIMERS;i++){
0017D4  EB0200     CLR W4
0017E6  E80204     INC W4, W4
0017E8  520FE8     SUB W4, #0x8, [W15]
0017EA  3AFFF8     BRA NZ, 0x17DC
51:                        timers[i].status=0;
0017D6  21FAA1     MOV #0x1FAA, W1
0017D8  EB0300     CLR W6
0017DC  DD22C3     SL W4, #3, W5
0017DE  408385     ADD W1, W5, W7
0017E0  780B86     MOV W6, [W7]
52:                        timers[i].handler=NULL;
0017DA  408066     ADD W1, #0x6, W0
0017E2  400285     ADD W0, W5, W5
0017E4  780A86     MOV W6, [W5]
53:                    }//for
54:                    ticks=0;
0017EC  EF3FA6     CLR ticks
0017EE  EF3FA8     CLR 0x1FA8
55:                
56:                    SYSTICKTMR.TON=0;  // disable systick timer
0017F0  A9E105     BCLR 0x105, #7
57:                    SYSTICKTMR.TCS=0;  // use internal Tcy
0017F2  A92104     BCLR T1CON, #1
58:                    quotient = FCY/ticks_per_second;
0017F4  B85461     MUL.UU W10, #1, W8
0017F6  BE0108     MOV.D W8, W2
0017F8  224000     MOV #0x2400, W0
0017FA  200F41     MOV #0xF4, W1
0017FC  07F665     RCALL 0x4C8
59:                    prescale=1;
001804  200014     MOV #0x1, W4
60:                    while (quotient>65535){
0017FE  400FE1     ADD W0, #0x1, [W15]
001800  588FE0     SUBB W1, #0x0, [W15]
001802  36000B     BRA LEU, 0x181A
001806  2FFFF6     MOV #0xFFFF, W6
001808  200007     MOV #0x0, W7
001810  500F86     SUB W0, W6, [W15]
001812  588F87     SUBB W1, W7, [W15]
001814  3EFFFA     BRA GTU, 0x180A
61:                        quotient >>= 1;
00180A  D10081     LSR W1, W1
00180C  D38000     RRC W0, W0
62:                        prescale <<= 1;
00180E  420204     ADD W4, W4, W4
63:                    }
64:                    if (prescale==1){
001816  520FE1     SUB W4, #0x1, [W15]
001818  3A0006     BRA NZ, 0x1826
65:                        SYSTICKTMR.TCKPS=0;
00181A  800824     MOV T1CON, W4
00181C  A14004     BCLR W4, #4
00181E  A15004     BCLR W4, #5
001820  880824     MOV W4, T1CON
66:                        SYSTICKPR=quotient;
001822  880810     MOV W0, PR1
001824  370020     BRA 0x1866
67:                    }else if (prescale<=8){
001826  520FE8     SUB W4, #0x8, [W15]
001828  3E000A     BRA GTU, 0x183E
68:                        SYSTICKTMR.TCKPS=1;
00182A  800824     MOV T1CON, W4
00182C  A04004     BSET W4, #4
00182E  A15004     BCLR W4, #5
001830  880824     MOV W4, T1CON
69:                        SYSTICKPR= FCY/8/ticks_per_second;
001832  BE0108     MOV.D W8, W2
001834  284800     MOV #0x8480, W0
001836  2001E1     MOV #0x1E, W1
001838  07F647     RCALL 0x4C8
00183A  880810     MOV W0, PR1
00183C  370014     BRA 0x1866
70:                    }else if (prescale<=64){
00183E  200405     MOV #0x40, W5
001840  520F85     SUB W4, W5, [W15]
001842  3E000A     BRA GTU, 0x1858
71:                        SYSTICKTMR.TCKPS=2;
001844  800824     MOV T1CON, W4
001846  A14004     BCLR W4, #4
001848  A05004     BSET W4, #5
00184A  880824     MOV W4, T1CON
72:                        SYSTICKPR= FCY/64/ticks_per_second;
00184C  BE0108     MOV.D W8, W2
00184E  2D0900     MOV #0xD090, W0
001850  200031     MOV #0x3, W1
001852  07F63A     RCALL 0x4C8
001854  880810     MOV W0, PR1
001856  370007     BRA 0x1866
73:                    }else{
74:                        SYSTICKTMR.TCKPS=3;
001858  200300     MOV #0x30, W0
00185A  B72104     IOR T1CON
75:                        SYSTICKPR = FCY/256/ticks_per_second;
00185C  2F4244     MOV #0xF424, W4
00185E  090011     REPEAT #0x11
001860  D8820A     DIV.UW W4, W10
001862  780200     MOV W0, W4
001864  880814     MOV W4, PR1
76:                    }//if
77:                    SYSTICKIF=0; // reset interrupt flag
001866  A96084     BCLR IFS0, #3
78:                    SYSTICKIE=1; // enable interrupt on systick timer
001868  A86094     BSET IEC0, #3
79:                    SYSTICKTMR.TON = 1; // enable systick timer
00186A  A8E105     BSET 0x105, #7
80:                }//f()
00186C  78054F     MOV [--W15], W10
00186E  BE044F     MOV.D [--W15], W8
001870  060000     RETURN
81:                
82:                int create_timer(unsigned delay, unsigned repeat, timer_handler_t *handler){
83:                    int i;
84:                    if (!handler) return -1;
001872  EB8200     SETM W4
001874  510FE0     SUB W2, #0x0, [W15]
001876  320020     BRA Z, 0x18B8
85:                    for (i=0;i<MAX_TIMERS;i++){
00187C  200014     MOV #0x1, W4
0018B0  E80204     INC W4, W4
0018B2  520FE8     SUB W4, #0x8, [W15]
0018B4  3AFFE4     BRA NZ, 0x187E
86:                        if (!(timers[i].status & F_TMR_USED)){
001878  AB1FAA     BTST timers, #0
00187A  320007     BRA Z, 0x188A
00187E  DD22C3     SL W4, #3, W5
001880  21FAA6     MOV #0x1FAA, W6
001882  7A82E6     MOV [W6+W5], W5
001884  6282E1     AND W5, #0x1, W5
001886  3A0014     BRA NZ, 0x18B0
001888  370001     BRA 0x188C
00188A  EB0200     CLR W4
87:                            timers[i].status = F_TMR_USED|F_TMR_HALTED;
00188C  DD22C3     SL W4, #3, W5
00188E  200037     MOV #0x3, W7
001890  21FAA6     MOV #0x1FAA, W6
001892  7AB307     MOV W7, [W6+W5]
88:                            if (repeat==TIMER_REPEAT) {timers[i].status |= F_TMR_REPEAT;}
001894  508FE1     SUB W1, #0x1, [W15]
001896  3A0004     BRA NZ, 0x18A0
001898  7A83E6     MOV [W6+W5], W7
00189A  430285     ADD W6, W5, W5
00189C  A02007     BSET W7, #2
00189E  780A87     MOV W7, [W5]
89:                            timers[i].delay=delay;
0018A0  DD22C3     SL W4, #3, W5
0018A2  21FAC6     MOV #0x1FAC, W6
0018A4  7AB300     MOV W0, [W6+W5]
90:                            timers[i].countdown=delay;
0018A6  E88306     INC2 W6, W6
0018A8  7AB300     MOV W0, [W6+W5]
91:                            timers[i].handler=handler;
0018AA  E88306     INC2 W6, W6
0018AC  7AB302     MOV W2, [W6+W5]
92:                            return i;
0018AE  370004     BRA 0x18B8
93:                        }//if
94:                    }//for
95:                    return -1;
0018B6  EB8200     SETM W4
96:                }//f()
0018B8  780004     MOV W4, W0
0018BA  060000     RETURN
97:                
98:                void stop_timer(int timer_id){
99:                    if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
0018BC  500FE7     SUB W0, #0x7, [W15]
0018BE  3E000B     BRA GTU, 0x18D6
0018C6  620261     AND W4, #0x1, W4
0018C8  320006     BRA Z, 0x18D6
100:                        (timers[timer_id].status & F_TMR_USED)){
0018C0  DD0243     SL W0, #3, W4
0018C2  21FAA5     MOV #0x1FAA, W5
0018C4  7A0265     MOV [W5+W4], W4
101:                       timers[timer_id].status |= F_TMR_HALTED;
0018CA  DD0043     SL W0, #3, W0
0018CC  780205     MOV W5, W4
0018CE  7802E4     MOV [W4+W0], W5
0018D0  420000     ADD W4, W0, W0
0018D2  A01005     BSET W5, #1
0018D4  780805     MOV W5, [W0]
102:                   }//if
103:               }//f()
0018D6  060000     RETURN
104:               
105:               void start_timer(int timer_id){
106:                   if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
0018D8  500FE7     SUB W0, #0x7, [W15]
0018DA  3E000F     BRA GTU, 0x18FA
0018E2  620261     AND W4, #0x1, W4
0018E4  32000A     BRA Z, 0x18FA
107:                       (timers[timer_id].status & F_TMR_USED)){
0018DC  DD0243     SL W0, #3, W4
0018DE  21FAA5     MOV #0x1FAA, W5
0018E0  7A0265     MOV [W5+W4], W4
108:                           timers[timer_id].countdown=timers[timer_id].delay;
0018E6  DD0043     SL W0, #3, W0
0018E8  E88300     INC2 W0, W6
0018EA  780205     MOV W5, W4
0018EC  4282E4     ADD W5, #0x4, W5
0018EE  7B0364     MOV [W4+W6], W6
0018F0  783286     MOV W6, [W5+W0]
109:                           timers[timer_id].status &= ~F_TMR_HALTED;
0018F2  7802E4     MOV [W4+W0], W5
0018F4  420000     ADD W4, W0, W0
0018F6  A11005     BCLR W5, #1
0018F8  780805     MOV W5, [W0]
110:                   }//if
111:               }//f()
0018FA  060000     RETURN
112:               
113:               void update_timer(int timer_id, unsigned new_delay){
114:                   if ((timer_id>=0)&&(timer_id<=MAX_TIMERS)&&timers[timer_id].status){
0018FC  500FE8     SUB W0, #0x8, [W15]
0018FE  3E0008     BRA GTU, 0x1910
001900  DD0243     SL W0, #3, W4
001902  21FAA5     MOV #0x1FAA, W5
001904  7A0265     MOV [W5+W4], W4
001906  520FE0     SUB W4, #0x0, [W15]
001908  320003     BRA Z, 0x1910
115:                       timers[timer_id].delay=new_delay;
00190A  DD0043     SL W0, #3, W0
00190C  E88205     INC2 W5, W4
00190E  783201     MOV W1, [W4+W0]
116:                   }
117:               }//f()
001910  060000     RETURN
118:               
119:               void destroy_timer(int timer_id){
120:                   if ((timer_id<0)||(timer_id>=MAX_TIMERS)) return;
001912  500FE7     SUB W0, #0x7, [W15]
001914  3E0008     BRA GTU, 0x1926
121:                   timers[timer_id].status=0;
001916  DD0043     SL W0, #3, W0
001918  21FAA5     MOV #0x1FAA, W5
00191A  428280     ADD W5, W0, W5
00191C  EB0200     CLR W4
00191E  780A84     MOV W4, [W5]
122:                   timers[timer_id].handler=NULL;
001920  21FB05     MOV #0x1FB0, W5
001922  428000     ADD W5, W0, W0
001924  780804     MOV W4, [W0]
123:               }//f()
001926  060000     RETURN
124:               
125:               unsigned long sys_ticks(){
126:                   return ticks;
001928  80FD30     MOV ticks, W0
00192A  80FD41     MOV 0x1FA8, W1
127:               }//f()
00192C  060000     RETURN
128:               
129:               void __attribute__((interrupt,no_auto_psv)) _SYSTICK_ISR(void){
00192E  F80036     PUSH RCOUNT
001930  BE9F80     MOV.D W0, [W15++]
001932  BE9F82     MOV.D W2, [W15++]
001934  BE9F84     MOV.D W4, [W15++]
001936  BE9F86     MOV.D W6, [W15++]
001938  BE9F88     MOV.D W8, [W15++]
00193A  BE9F8A     MOV.D W10, [W15++]
130:                   int i;
131:                   ticks++;
00193C  80FD34     MOV ticks, W4
00193E  80FD45     MOV 0x1FA8, W5
001940  420261     ADD W4, #0x1, W4
001942  4A82E0     ADDC W5, #0x0, W5
001944  88FD34     MOV W4, ticks
001946  88FD45     MOV W5, 0x1FA8
132:                   for (i=0;i<MAX_TIMERS;i++){
001948  EB0400     CLR W8
001990  E80408     INC W8, W8
001992  540FE8     SUB W8, #0x8, [W15]
001994  3AFFDB     BRA NZ, 0x194C
133:                       if (((timers[i].status&(F_TMR_USED|F_TMR_HALTED))==TMR_RUNNING)){
00194C  DD4243     SL W8, #3, W4
00194E  21FAA5     MOV #0x1FAA, W5
001950  7A0265     MOV [W5+W4], W4
001952  620263     AND W4, #0x3, W4
001954  520FE1     SUB W4, #0x1, [W15]
001956  3A001C     BRA NZ, 0x1990
134:                           if (--timers[i].countdown==0){
00194A  21FAE9     MOV #0x1FAE, W9
001958  DD4343     SL W8, #3, W6
00195A  430264     ADD W6, #0x4, W4
00195C  7A03E5     MOV [W5+W4], W7
00195E  448306     ADD W9, W6, W6
001960  E90B07     DEC W7, [W6]
001962  7A0265     MOV [W5+W4], W4
001964  520FE0     SUB W4, #0x0, [W15]
001966  3A0014     BRA NZ, 0x1990
135:                               timers[i].handler();
001968  DD45C3     SL W8, #3, W11
00196A  458266     ADD W11, #0x6, W4
00196C  780505     MOV W5, W10
00196E  7A026A     MOV [W10+W4], W4
001970  010004     CALL W4
136:                               if (timers[i].status & F_TMR_REPEAT) {
001972  7D826A     MOV [W10+W11], W4
001974  620264     AND W4, #0x4, W4
001976  320006     BRA Z, 0x1984
137:                                   timers[i].countdown=timers[i].delay;
001978  78020B     MOV W11, W4
00197A  E88284     INC2 W4, W5
00197C  78030A     MOV W10, W6
00197E  7A8366     MOV [W6+W5], W6
001980  7A3486     MOV W6, [W9+W4]
001982  370006     BRA 0x1990
138:                               }else{
139:                                   timers[i].status |= F_TMR_HALTED;
001984  DD4243     SL W8, #3, W4
001986  21FAA5     MOV #0x1FAA, W5
001988  7A0365     MOV [W5+W4], W6
00198A  428204     ADD W5, W4, W4
00198C  A01006     BSET W6, #1
00198E  780A06     MOV W6, [W4]
140:                               }
141:                           }//if
142:                       }
143:                   }//for
144:                   SYSTICKIF=0;
001996  A96084     BCLR IFS0, #3
145:               }// _SYSTICK_ISR()
001998  BE054F     MOV.D [--W15], W10
00199A  BE044F     MOV.D [--W15], W8
00199C  BE034F     MOV.D [--W15], W6
00199E  BE024F     MOV.D [--W15], W4
0019A0  BE014F     MOV.D [--W15], W2
0019A2  BE004F     MOV.D [--W15], W0
0019A4  F90036     POP RCOUNT
0019A6  064000     RETFIE
146:               
147:               
148:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/text_console.c  ---------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   text_console.h
21:                 * Author: jacques Deschênes
22:                 * Description: manage text writing in video_buffer
23:                 * Created on 28 février 2014, 10:04
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                #include "text_console.h"
29:                
30:                //static text_coord_t cursor_pos;
31:                
32:                //#define X_OFS  ((HPIXELS-CHAR_PER_LINE*CHAR_WIDTH)/2)  // x offset to cursor from screen edge
33:                //#define Y_OFS  ((VPIXELS-LINE_PER_SCREEN*CHAR_HEIGHT)/2) // y offset to cursor from screen edge
34:                
35:                // boolean flags
36:                #define CUR_SHOW 1  // cursor active
37:                #define CUR_VIS  2  // cursor state visible
38:                #define INV_VID  4  // invert video
39:                
40:                
41:                static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
42:                static unsigned char tab_width=TAB_WIDTH;
43:                static cursor_t cur_shape=CR_UNDER;
44:                static unsigned short flags=0;
45:                
46:                
47:                
48:                void scroll_up(void){
49:                    char *src, *dst;
50:                    dst = (char*)video_buffer;
51:                    src = (char*)video_buffer + CHAR_HEIGHT*BYTES_PER_LINE;
52:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001472  215F02     MOV #0x15F0, W2
001474  208D81     MOV #0x8D8, W1
001476  208000     MOV #0x800, W0
001478  07F876     RCALL 0x566
53:                    dst= (char*)video_buffer+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*BYTES_PER_LINE;
54:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
00147A  21DF04     MOV #0x1DF0, W4
00147C  0900D7     REPEAT #0xD7
00147E  EB5A00     CLR.B [W4++]
55:                }//scroll_up();
001480  060000     RETURN
56:                
57:                void scroll_down(void){
58:                    char *src, *dst;
59:                    src = (char*)video_buffer;
60:                    dst = (char*)video_buffer+CHAR_HEIGHT*BYTES_PER_LINE;
61:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001482  215F02     MOV #0x15F0, W2
001484  208001     MOV #0x800, W1
001486  200D80     MOV #0xD8, W0
001488  400001     ADD W0, W1, W0
00148A  07F86D     RCALL 0x566
62:                    dst=(char*)video_buffer;
63:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
00148C  208004     MOV #0x800, W4
00148E  0900D7     REPEAT #0xD7
001490  EB5A00     CLR.B [W4++]
64:                }//scroll_down()
001492  060000     RETURN
65:                
66:                
67:                void cursor_right(void){
68:                    cx += CHAR_WIDTH;
001494  80FF74     MOV cx, W4
001496  420266     ADD W4, #0x6, W4
001498  88FF74     MOV W4, cx
69:                    if (cx>(CHAR_PER_LINE*CHAR_WIDTH)){
00149A  200D25     MOV #0xD2, W5
00149C  520F85     SUB W4, W5, [W15]
00149E  36000A     BRA LEU, 0x14B4
70:                        cx = 0;
0014A0  EF3FEE     CLR cx
71:                        cy += CHAR_HEIGHT;
0014A2  80FF84     MOV cy, W4
0014A4  420268     ADD W4, #0x8, W4
0014A6  88FF84     MOV W4, cy
72:                        if (cy>(LINE_PER_SCREEN*CHAR_HEIGHT)){
0014A8  4282E6     ADD W5, #0x6, W5
0014AA  520F85     SUB W4, W5, [W15]
0014AC  360003     BRA LEU, 0x14B4
73:                            scroll_up();
0014AE  07FFE1     RCALL scroll_up
74:                            cy -= CHAR_HEIGHT;
0014B0  2FFF80     MOV #0xFFF8, W0
0014B2  B43FF0     ADD cy
75:                        }
76:                    }
77:                } // cursor_right()
0014B4  060000     RETURN
78:                
79:                void cursor_left(void){
80:                    if (cx>=CHAR_WIDTH){
0014B6  80FF74     MOV cx, W4
0014B8  520FE5     SUB W4, #0x5, [W15]
0014BA  360003     BRA LEU, 0x14C2
81:                        cx -= CHAR_WIDTH;
0014BC  520266     SUB W4, #0x6, W4
0014BE  88FF74     MOV W4, cx
0014C0  370009     BRA 0x14D4
82:                    }else{
83:                        cx = CHAR_WIDTH*(CHAR_PER_LINE-1);
0014C2  200CC4     MOV #0xCC, W4
0014C4  88FF74     MOV W4, cx
84:                        if (cy>=CHAR_HEIGHT){
0014C6  80FF84     MOV cy, W4
0014C8  520FE7     SUB W4, #0x7, [W15]
0014CA  360003     BRA LEU, 0x14D2
85:                            cy -= CHAR_HEIGHT;
0014CC  520268     SUB W4, #0x8, W4
0014CE  88FF84     MOV W4, cy
0014D0  370001     BRA 0x14D4
86:                        }else{
87:                            scroll_down();
0014D2  07FFD7     RCALL scroll_down
88:                        }
89:                    }
90:                }// cursor_left()
0014D4  060000     RETURN
91:                
92:                void cursor_up(void){
93:                    if (cy>=CHAR_HEIGHT){
0014D6  80FF84     MOV cy, W4
0014D8  520FE7     SUB W4, #0x7, [W15]
0014DA  360003     BRA LEU, 0x14E2
94:                        cy -= CHAR_HEIGHT;
0014DC  520268     SUB W4, #0x8, W4
0014DE  88FF84     MOV W4, cy
0014E0  370001     BRA 0x14E4
95:                    }else{
96:                        scroll_down();
0014E2  07FFCF     RCALL scroll_down
97:                    }
98:                }// cursor_up()
0014E4  060000     RETURN
99:                
100:               void cursor_down(void){
101:                   if (cy<=(CHAR_HEIGHT*(LINE_PER_SCREEN-2))){
0014E6  80FF84     MOV cy, W4
0014E8  200C85     MOV #0xC8, W5
0014EA  520F85     SUB W4, W5, [W15]
0014EC  3E0003     BRA GTU, 0x14F4
102:                       cy += CHAR_HEIGHT;
0014EE  420268     ADD W4, #0x8, W4
0014F0  88FF84     MOV W4, cy
0014F2  370001     BRA 0x14F6
103:                   }else{
104:                       scroll_up();
0014F4  07FFBE     RCALL scroll_up
105:                   }
106:               }//cursor_down()
0014F6  060000     RETURN
107:               
108:               void crlf(void){
109:                   cx=0;
0014F8  EF3FEE     CLR cx
110:                   if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
0014FA  80FF84     MOV cy, W4
0014FC  200D05     MOV #0xD0, W5
0014FE  520F85     SUB W4, W5, [W15]
001500  3A0002     BRA NZ, 0x1506
111:                       scroll_up();
001502  07FFB7     RCALL scroll_up
001504  370002     BRA 0x150A
112:                   }else{
113:                       cy += CHAR_HEIGHT;
001506  420268     ADD W4, #0x8, W4
001508  88FF84     MOV W4, cy
114:                   }
115:               }//crlf()
00150A  060000     RETURN
116:               
117:               void put_char(unsigned char c){
00150C  4787E6     ADD W15, #0x6, W15
00150E  BE9F88     MOV.D W8, [W15++]
001510  BE9F8A     MOV.D W10, [W15++]
001512  BE9F8C     MOV.D W12, [W15++]
001514  781F8E     MOV W14, [W15++]
00158C  E80389     INC W9, W7
00158E  B94A7B     MUL.SU W9, #27, W4
001590  780284     MOV W4, W5
001592  42820D     ADD W5, W13, W4
001594  208000     MOV #0x800, W0
001596  420200     ADD W4, W0, W4
00159A  DD3743     SL W6, #3, W14
00159C  285CA6     MOV #0x85CA, W6
00159E  470306     ADD W14, W6, W6
0015A0  E8068D     INC W13, W13
0015A2  42828D     ADD W5, W13, W5
0015A4  428280     ADD W5, W0, W5
0015A6  448069     ADD W9, #0x9, W0
118:                   register int i,l,r,b,x,y;
119:                   x=cx;
001516  80FF73     MOV cx, W3
120:                   y=cy;
001518  80FF89     MOV cy, W9
121:                   switch (c){
00151A  504FE9     SUB.B W0, #0x9, [W15]
00151C  320007     BRA Z, 0x152C
00151E  504FED     SUB.B W0, #0xD, [W15]
001520  320003     BRA Z, 0x1528
001522  504FE8     SUB.B W0, #0x8, [W15]
001524  3A001B     BRA NZ, 0x155C
001526  370018     BRA 0x1558
122:                       case CR:
123:                           crlf();
001528  07FFE7     RCALL crlf
124:                           break;
00152A  37006E     BRA 0x1608
125:                       case TAB:
126:                           cx += (cx%tab_width);
00152C  21FFA4     MOV #0x1FFA, W4
00152E  784214     MOV.B [W4], W4
001530  FB8204     ZE W4, W4
001532  BE9F80     MOV.D W0, [W15++]
001534  090011     REPEAT #0x11
001536  D88184     DIV.UW W3, W4
001538  780201     MOV W1, W4
00153A  BE004F     MOV.D [--W15], W0
00153C  420183     ADD W4, W3, W3
00153E  88FF73     MOV W3, cx
127:                           if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
001540  200D14     MOV #0xD1, W4
001542  518F84     SUB W3, W4, [W15]
001544  360061     BRA LEU, 0x1608
128:                               cx = 0;
001546  EF3FEE     CLR cx
129:                               if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
001548  E90204     DEC W4, W4
00154A  548F84     SUB W9, W4, [W15]
00154C  3A0002     BRA NZ, 0x1552
130:                                   scroll_up();
00154E  07FF91     RCALL scroll_up
001550  37005B     BRA 0x1608
131:                               }else{
132:                                   cy += CHAR_HEIGHT;
001552  4484E8     ADD W9, #0x8, W9
001554  88FF89     MOV W9, cy
001556  370058     BRA 0x1608
133:                               }
134:                           }
135:                           break;
136:                       case '\b':
137:                           cursor_left();
001558  07FFAE     RCALL cursor_left
138:                           break;
00155A  370056     BRA 0x1608
139:                       default:
140:                           if ((c<32) || (c>=(FONT_SIZE+32))) break;
00155C  B3CE06     MOV #0xE0, W6
00155E  404306     ADD.B W0, W6, W6
001560  B3C6D4     MOV #0x6D, W4
001562  534F84     SUB.B W6, W4, [W15]
001564  3E0051     BRA GTU, 0x1608
141:                           c -=32;
142:                           b=x>>3; // character position in video_buffer
001566  DE9EC3     ASR W3, #3, W13
143:                           r=0;
144:                           l=(8-CHAR_WIDTH)-(x&7); // shift inside this byte
001568  6181E7     AND W3, #0x7, W3
00156A  1181E2     SUBR W3, #0x2, W3
145:                           if (l<0){
146:                               r=-l;
00156C  DE9A4F     ASR W3, #15, W4
00156E  EA0083     NEG W3, W1
001570  608084     AND W1, W4, W1
147:                           }
148:                           for (i=0;i<8;i++){
001602  538F80     SUB W7, W0, [W15]
001604  3AFFD1     BRA NZ, 0x15A8
149:                               if (r){
0015A8  508FE0     SUB W1, #0x0, [W15]
0015AA  320018     BRA Z, 0x15DC
150:                                   if (flags & INV_VID){
001572  80FF52     MOV flags, W2
001574  610164     AND W2, #0x4, W2
0015AC  510FE0     SUB W2, #0x0, [W15]
0015AE  32000B     BRA Z, 0x15C6
151:                                       video_buffer[y][b] |= (0x3f>>r);
001576  2003FA     MOV #0x3F, W10
001578  DED601     ASR W10, W1, W12
0015B8  764694     IOR.B W12, [W4], W13
152:                                       video_buffer[y][b] &=~(font6x8[(int)c][i]>>r);
0015B0  784696     MOV.B [W6], W13
0015B2  FB848D     ZE W13, W9
0015B4  DECF01     ASR W9, W1, W14
0015B6  EAC70E     COM.B W14, W14
0015BA  674A0D     AND.B W14, W13, [W4]
153:                                       video_buffer[y][b+1] |= (0x3f<<(8-r));
00157A  108468     SUBR W1, #0x8, W8
00157C  DD5588     SL W10, W8, W11
0015C0  75C695     IOR.B W11, [W5], W13
154:                                       video_buffer[y][b+1] &= ~(font6x8[(int)c][i]<<(8-r));
0015BC  DD4C88     SL W9, W8, W9
0015BE  EAC489     COM.B W9, W9
0015C2  64CA8D     AND.B W9, W13, [W5]
0015C4  37001A     BRA 0x15FA
155:                                   }else{
156:                                       video_buffer[y][b] &= ~(0x3f>>r);
00157E  EAC20C     COM.B W12, W4
001580  9FF784     MOV.B W4, [W15-16]
0015CA  97F68F     MOV.B [W15-16], W13
0015CC  66C714     AND.B W13, [W4], W14
157:                                       video_buffer[y][b] |= font6x8[(int)c][i]>>r;
0015C6  784716     MOV.B [W6], W14
0015C8  FB848E     ZE W14, W9
0015CE  DECE81     ASR W9, W1, W13
0015D0  774A0D     IOR.B W14, W13, [W4]
158:                                       video_buffer[y][b+1] &= ~(0x3f<<(8-r));
001582  EAC70B     COM.B W11, W14
001584  9FEFFE     MOV.B W14, [W15-17]
0015D2  97EF7F     MOV.B [W15-17], W14
0015D4  674695     AND.B W14, [W5], W13
159:                                       video_buffer[y][b+1] |= font6x8[(int)c][i]<<(8-r);
0015D6  DD4C88     SL W9, W8, W9
0015D8  76CA89     IOR.B W13, W9, [W5]
0015DA  37000F     BRA 0x15FA
160:                                   }
161:                                   y++;
162:                               } else{
163:                                   if (flags & INV_VID){
0015DC  510FE0     SUB W2, #0x0, [W15]
0015DE  320007     BRA Z, 0x15EE
164:                                       video_buffer[y][b] |= (0x3f<<l);
001586  DD5503     SL W10, W3, W10
0015E8  754494     IOR.B W10, [W4], W9
165:                                       video_buffer[y++][b] &=~(font6x8[(int)c][i]<<l);
001598  FB8306     ZE W6, W6
0015E0  784496     MOV.B [W6], W9
0015E2  FB8689     ZE W9, W13
0015E4  DD6E83     SL W13, W3, W13
0015E6  EAC68D     COM.B W13, W13
0015EA  66CA09     AND.B W13, W9, [W4]
0015EC  370006     BRA 0x15FA
166:                                   }else{
167:                                       video_buffer[y][b] &= ~(0x3f<<l);
001588  EAC20A     COM.B W10, W4
00158A  9FEFE4     MOV.B W4, [W15-18]
0015EE  97EF6F     MOV.B [W15-18], W14
0015F0  674694     AND.B W14, [W4], W13
168:                                       video_buffer[y++][b] |= font6x8[(int)c][i]<<l;
0015F2  784716     MOV.B [W6], W14
0015F4  FB848E     ZE W14, W9
0015F6  DD4C83     SL W9, W3, W9
0015F8  76CA09     IOR.B W13, W9, [W4]
0015FA  E80387     INC W7, W7
0015FC  42027B     ADD W4, #0x1B, W4
0015FE  E80306     INC W6, W6
001600  4282FB     ADD W5, #0x1B, W5
169:                                   }
170:                               }
171:                           }
172:                           cursor_right();
001606  07FF46     RCALL cursor_right
173:                   }//switch(c)
174:               }//put_char()
001608  78074F     MOV [--W15], W14
00160A  BE064F     MOV.D [--W15], W12
00160C  BE054F     MOV.D [--W15], W10
00160E  BE044F     MOV.D [--W15], W8
001610  B1006F     SUB #0x6, W15
001612  060000     RETURN
175:               
176:               void clear_screen(){
177:                   memset(video_buffer,0,HPIXELS/8*VPIXELS);
001614  208004     MOV #0x800, W4
001616  0916C7     REPEAT #0x16C7
001618  EB5A00     CLR.B [W4++]
178:                   cx=0;
00161A  EB0200     CLR W4
00161C  88FF74     MOV W4, cx
179:                   cy=0;
00161E  88FF84     MOV W4, cy
180:               } // clear_screen()
001620  060000     RETURN
181:               
182:               void print(const char *text){
001622  781F88     MOV W8, [W15++]
001624  780400     MOV W0, W8
183:                   while (*text){
001626  784018     MOV.B [W8], W0
001628  504FE0     SUB.B W0, #0x0, [W15]
00162A  320004     BRA Z, 0x1634
00162E  784058     MOV.B [++W8], W0
001630  504FE0     SUB.B W0, #0x0, [W15]
001632  3AFFFC     BRA NZ, 0x162C
184:                       put_char(*text++);
00162C  07FF6F     RCALL put_char
185:                   }
186:               }// print()
001634  78044F     MOV [--W15], W8
001636  060000     RETURN
187:               
188:               void print_hex(unsigned int hex, unsigned char width){
001638  FA000C     LNK #0xC
189:                   char c[12], *d;
190:                   int i;
191:                   c[11]=0;
00163A  EB4200     CLR.B W4
00163C  9FFFF4     MOV.B W4, [W15-1]
192:                   d= &c[10];
001640  E9820F     DEC2 W15, W4
193:                   for(i=width;i>=0||hex;i--){
00163E  FB8301     ZE W1, W6
001642  37000C     BRA 0x165C
00165A  E90306     DEC W6, W6
00165C  530FE0     SUB W6, #0x0, [W15]
00165E  3DFFF2     BRA GE, 0x1644
001660  500FE0     SUB W0, #0x0, [W15]
001662  3AFFF0     BRA NZ, 0x1644
194:                       *d=(hex%16);
001644  6042EF     AND.B W0, #0xF, W5
001646  784A05     MOV.B W5, [W4]
195:                       if (*d<10)
001648  52CFE9     SUB.B W5, #0x9, [W15]
00164A  3C0003     BRA GT, 0x1652
196:                           *d += '0';
00164C  B3C307     MOV #0x30, W7
00164E  42CA07     ADD.B W5, W7, [W4]
001650  370002     BRA 0x1656
197:                       else
198:                           *d += 'A'-10;
001652  B3C377     MOV #0x37, W7
001654  42CA07     ADD.B W5, W7, [W4]
199:                       hex /=16;
001656  DE0044     LSR W0, #4, W0
200:                       d--;
001658  E90204     DEC W4, W4
201:                   }
202:                   print(++d);
001664  E80004     INC W4, W0
001666  07FFDD     RCALL print
203:               } // print_hex()
001668  FA8000     ULNK
00166A  060000     RETURN
204:               
205:               void print_int(int number, unsigned short width){ // imprime entier,width inclus le signe
00166C  FA000E     LNK #0xE
0016B2  538005     SUB W7, W5, W0
0016B4  780207     MOV W7, W4
206:                   int sign=0, i;
001678  EB0100     CLR W2
207:                   char str[14], *d;
208:                   str[13]=0;
00166E  EB4200     CLR.B W4
001670  9FFFF4     MOV.B W4, [W15-1]
001672  508FED     SUB W1, #0xD, [W15]
001674  360001     BRA LEU, 0x1678
001676  2000D1     MOV #0xD, W1
209:                   d=&str[12];
001688  E9820F     DEC2 W15, W4
0016A2  E9838F     DEC2 W15, W7
210:                   if (width>13){width=13;}
211:                   if (number<0){
00167A  500F82     SUB W0, W2, [W15]
00167C  3D0002     BRA GE, 0x1682
212:                       sign=1;
001680  200012     MOV #0x1, W2
213:                       number = -number;
00167E  EA0000     NEG W0, W0
214:                   }
215:                   //for (i=--width;i>=0||number;i--){
216:                   i=width;
001682  780281     MOV W1, W5
217:                   while (number>0){
001684  500FE0     SUB W0, #0x0, [W15]
001686  34000D     BRA LE, 0x16A2
00169C  500FE0     SUB W0, #0x0, [W15]
00169E  3CFFF6     BRA GT, 0x168C
0016A0  370001     BRA 0x16A4
218:                      *d--=(number%10)+'0';
00168A  2000A6     MOV #0xA, W6
00168C  780381     MOV W1, W7
00168E  090011     REPEAT #0x11
001690  D80006     DIV.SW W0, W6
001692  FD0381     EXCH W1, W7
001694  B3C303     MOV #0x30, W3
001696  43D203     ADD.B W7, W3, [W4--]
001698  780384     MOV W4, W7
219:                       number /= 10;
220:                       i--;
00169A  E90285     DEC W5, W5
221:                   }
222:                   if (i==width){
0016A4  508F85     SUB W1, W5, [W15]
0016A6  3A0003     BRA NZ, 0x16AE
223:                       *d--='0';
0016A8  B3C304     MOV #0x30, W4
0016AA  785384     MOV.B W4, [W7--]
224:                       i--;
0016AC  E90285     DEC W5, W5
225:                   }
226:                   while (i>0){
0016AE  528FE0     SUB W5, #0x0, [W15]
0016B0  340007     BRA LE, 0x16C0
0016BA  520F80     SUB W4, W0, [W15]
0016BC  3AFFFD     BRA NZ, 0x16B8
0016BE  538385     SUB W7, W5, W7
227:                       *d--=' ';
0016B6  B3C206     MOV #0x20, W6
0016B8  785206     MOV.B W6, [W4--]
228:                       i--;
229:                   }
230:                   if (sign){*d='-';}else{*d=' ';}
0016C0  510FE0     SUB W2, #0x0, [W15]
0016C2  320003     BRA Z, 0x16CA
0016C4  B3C2D4     MOV #0x2D, W4
0016C6  784B84     MOV.B W4, [W7]
0016C8  370002     BRA 0x16CE
0016CA  B3C204     MOV #0x20, W4
0016CC  784B84     MOV.B W4, [W7]
231:                   print(d);
0016CE  780007     MOV W7, W0
0016D0  07FFA8     RCALL print
232:               }// print_int()
0016D2  FA8000     ULNK
0016D4  060000     RETURN
233:               
234:               void set_tab_width(unsigned char width){
235:                   tab_width=width;
0016D6  B7FFFA     MOV.B WREG, tab_width
236:               }// set_tab_width()
0016D8  060000     RETURN
237:               
238:               void clear_eol(void){
0016DA  BE9F88     MOV.D W8, [W15++]
0016DC  BE9F8A     MOV.D W10, [W15++]
239:                   int x,y;
240:                   x=cx;
0016DE  80FF7A     MOV cx, W10
241:                   y=cy;
0016E0  80FF8B     MOV cy, W11
242:                   while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
0016E2  200C54     MOV #0xC5, W4
0016E4  550F84     SUB W10, W4, [W15]
0016E6  3E0007     BRA GTU, 0x16F6
0016EA  780484     MOV W4, W9
0016F0  80FF74     MOV cx, W4
0016F2  520F89     SUB W4, W9, [W15]
0016F4  36FFFB     BRA LEU, 0x16EC
243:                       put_char(32);
0016E8  B3C208     MOV #0x20, W8
0016EC  784008     MOV.B W8, W0
0016EE  07FF0E     RCALL put_char
244:                   }
245:                   put_char(32);
0016F6  B3C200     MOV #0x20, W0
0016F8  07FF09     RCALL put_char
246:                   cx=x;
0016FA  88FF7A     MOV W10, cx
247:                   cy=y;
0016FC  88FF8B     MOV W11, cy
248:               }// clear_eol()
0016FE  BE054F     MOV.D [--W15], W10
001700  BE044F     MOV.D [--W15], W8
001702  060000     RETURN
249:               
250:               text_coord_t get_curpos(){
251:                   text_coord_t cpos;
252:                   cpos.x = cx/CHAR_WIDTH;
001704  80FF75     MOV cx, W5
001706  200064     MOV #0x6, W4
001708  781F80     MOV W0, [W15++]
00170A  090011     REPEAT #0x11
00170C  D88284     DIV.UW W5, W4
00170E  780200     MOV W0, W4
001710  78004F     MOV [--W15], W0
001712  780804     MOV W4, [W0]
253:                   cpos.y = cy/CHAR_HEIGHT;
001714  80FF84     MOV cy, W4
001716  DE2243     LSR W4, #3, W4
001718  980014     MOV W4, [W0+2]
254:                   return cpos;
255:               } // get_cursor_pos()
00171A  060000     RETURN
256:               
257:               void set_curpos(unsigned short x, unsigned short y){// {x,y} character coord.
258:                   if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
00171C  200224     MOV #0x22, W4
00171E  500F84     SUB W0, W4, [W15]
001720  3E0006     BRA GTU, 0x172E
001722  508FFA     SUB W1, #0x1A, [W15]
001724  3E0004     BRA GTU, 0x172E
259:                       return;
260:                   cx=x*CHAR_WIDTH;
001726  B90266     MUL.SU W0, #6, W4
001728  88FF74     MOV W4, cx
261:                   cy=y*CHAR_HEIGHT;
00172A  DD08C3     SL W1, #3, W1
00172C  88FF81     MOV W1, cy
262:               }//set_curpos()
00172E  060000     RETURN
263:               
264:               void invert_char(void){// invert pixels of character at cursor position
001730  BE9F88     MOV.D W8, [W15++]
00174C  E80287     INC W7, W5
00174E  B93C7B     MUL.SU W7, #27, W8
001750  420008     ADD W4, W8, W0
001752  208004     MOV #0x800, W4
001754  400204     ADD W0, W4, W4
001756  4383EA     ADD W7, #0xA, W7
265:                   register int i,l,r,b,x,y;
266:                   x=cx;
001732  80FF71     MOV cx, W1
267:                   y=cy;
001734  80FF87     MOV cy, W7
268:                   b=x>>3;
001736  DE8A43     ASR W1, #3, W4
269:                   r=0;
270:                   l=(8-CHAR_WIDTH)-(x&7);
001738  6080E7     AND W1, #0x7, W1
00173A  1080E2     SUBR W1, #0x2, W1
271:                   if (l<0){
272:                       r=-l;
00173C  DE8ACF     ASR W1, #15, W5
00173E  EA0301     NEG W1, W6
001740  630305     AND W6, W5, W6
273:                   }
274:                   for (i=9;i;i--){
00176C  528F87     SUB W5, W7, [W15]
00176E  3AFFF4     BRA NZ, 0x1758
275:                       if (r){
001758  530FE0     SUB W6, #0x0, [W15]
00175A  320005     BRA Z, 0x1766
276:                           video_buffer[y][b] ^= (0x3f>>r);
001742  2003F5     MOV #0x3F, W5
001744  DEA986     ASR W5, W6, W3
00175C  69CA14     XOR.B W3, [W4], [W4]
277:                           video_buffer[y][b+1] ^= (0x3f<<(8-r));
001746  130168     SUBR W6, #0x8, W2
001748  DD2902     SL W5, W2, W2
00175E  904014     MOV.B [W4+1], W0
001760  684002     XOR.B W0, W2, W0
001762  984210     MOV.B W0, [W4+1]
001764  370001     BRA 0x1768
278:                           y++;
279:                       } else{
280:                           video_buffer[y++][b] ^= (0x3f<<l);
00174A  DD2881     SL W5, W1, W1
001766  68CA14     XOR.B W1, [W4], [W4]
001768  E80285     INC W5, W5
00176A  42027B     ADD W4, #0x1B, W4
281:                       }
282:                   }
283:               }//invert_char()
001770  BE044F     MOV.D [--W15], W8
001772  060000     RETURN
284:               
285:               static void toggle_underscore(void){
286:                   register int l,r,b,x;
287:                   x=cx;
00142A  80FF74     MOV cx, W4
288:                   b=x>>5;
00142C  DEA2C5     ASR W4, #5, W5
289:                   r=0;
290:                   l=(8-CHAR_WIDTH)-(x&7);
00142E  620267     AND W4, #0x7, W4
001430  120262     SUBR W4, #0x2, W4
291:                   if (l<0){
001432  3B0014     BRA NN, 0x145C
292:                       r=-l;
001434  EA0304     NEG W4, W6
293:                   }
294:                   if (r){
001436  320012     BRA Z, 0x145C
295:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
001438  80FF80     MOV cy, W0
00143A  400067     ADD W0, #0x7, W0
00143C  208004     MOV #0x800, W4
00143E  B9007B     MUL.SU W0, #27, W0
001440  400085     ADD W0, W5, W1
001442  420101     ADD W4, W1, W2
001444  2003F7     MOV #0x3F, W7
001446  DEB986     ASR W7, W6, W3
001448  78C0E4     MOV.B [W4+W1], W1
00144A  68C903     XOR.B W1, W3, [W2]
296:                       video_buffer[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<(8-r));
00144C  E80285     INC W5, W5
00144E  400285     ADD W0, W5, W5
001450  420005     ADD W4, W5, W0
001452  130368     SUBR W6, #0x8, W6
001454  DD3B86     SL W7, W6, W7
001456  7AC264     MOV.B [W4+W5], W4
001458  6A4807     XOR.B W4, W7, [W0]
00145A  37000A     BRA 0x1470
297:                   } else{
298:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
00145C  80FF80     MOV cy, W0
00145E  400067     ADD W0, #0x7, W0
001460  208006     MOV #0x800, W6
001462  B9007B     MUL.SU W0, #27, W0
001464  428280     ADD W5, W0, W5
001466  430385     ADD W6, W5, W7
001468  2003F0     MOV #0x3F, W0
00146A  DD0204     SL W0, W4, W4
00146C  7AC2E6     MOV.B [W6+W5], W5
00146E  6ACB84     XOR.B W5, W4, [W7]
299:                   }
300:               }//toggle_underscore()
001470  060000     RETURN
301:               
302:               void show_cursor(BOOL show){
001774  781F88     MOV W8, [W15++]
303:                   if (show){
001776  500FE0     SUB W0, #0x0, [W15]
001778  32000B     BRA Z, 0x1790
304:                       flags |= CUR_SHOW;
00177A  80FF54     MOV flags, W4
00177C  A00004     BSET W4, #0
305:                       flags ^= CUR_VIS;
00177E  A21004     BTG W4, #1
001780  88FF54     MOV W4, flags
306:                       if (cur_shape==CR_BLOCK){
001782  80FF64     MOV cur_shape, W4
001784  520FE1     SUB W4, #0x1, [W15]
001786  3A0002     BRA NZ, 0x178C
307:                           invert_char();
001788  07FFD3     RCALL invert_char
00178A  37000E     BRA 0x17A8
308:                       }else{
309:                           toggle_underscore();
00178C  07FE4E     RCALL toggle_underscore
00178E  37000C     BRA 0x17A8
310:                       }
311:                   }else{
312:                       if (flags & CUR_VIS){
001790  80FF58     MOV flags, W8
001792  640262     AND W8, #0x2, W4
001794  320008     BRA Z, 0x17A6
313:                           if (cur_shape==CR_BLOCK){
001796  80FF64     MOV cur_shape, W4
001798  520FE1     SUB W4, #0x1, [W15]
00179A  3A0002     BRA NZ, 0x17A0
314:                               invert_char();
00179C  07FFC9     RCALL invert_char
00179E  370001     BRA 0x17A2
315:                           }else{
316:                               toggle_underscore();
0017A0  07FE44     RCALL toggle_underscore
317:                           }
318:                           flags &= ~CUR_VIS;
0017A2  A11008     BCLR W8, #1
0017A4  88FF58     MOV W8, flags
319:                       }
320:                       flags &= ~CUR_SHOW;
0017A6  A91FEA     BCLR flags, #0
321:                   }
322:               
323:               }// show_cursor()
0017A8  78044F     MOV [--W15], W8
0017AA  060000     RETURN
324:               
325:               void set_cursor(cursor_t shape){
0017AC  781F88     MOV W8, [W15++]
0017AE  780400     MOV W0, W8
326:                   if (flags & CUR_VIS){
0017B0  AB3FEA     BTST flags, #1
0017B2  320006     BRA Z, 0x17C0
327:                       show_cursor(FALSE);
0017B4  EB0000     CLR W0
0017B6  07FFDE     RCALL show_cursor
328:                       cur_shape=shape;
0017B8  88FF68     MOV W8, cur_shape
329:                       show_cursor(TRUE);
0017BA  200010     MOV #0x1, W0
0017BC  07FFDB     RCALL show_cursor
0017BE  370001     BRA 0x17C2
330:                   }else{
331:                       cur_shape=shape;
0017C0  88FF68     MOV W8, cur_shape
332:                   }
333:               }// set_cursor()
0017C2  78044F     MOV [--W15], W8
0017C4  060000     RETURN
334:               
335:               
336:               void invert_video(){
337:                   flags |= INV_VID;
0017C6  A85FEA     BSET flags, #2
338:               }//invert_video()
0017C8  060000     RETURN
339:               
340:               void normal_video(){
341:                   flags &= ~INV_VID;
0017CA  A95FEA     BCLR flags, #2
342:               }//normal_video()
0017CC  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/sound.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   sound.c
21:                 * Author: jacques Deschênes
22:                 * Description:  sound generation using PWM D.A.C.
23:                 * Created on 25 février 2014, 16:43
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include "sound.h"
28:                
29:                #define F_TONE  1  // tone playing flag
30:                #define F_TUNE  2  // flag tune playing
31:                #define F_WHITE 4  // white noise generation
32:                
33:                #define mTone_off() (AUDIOCON.OCM=0)
34:                #define mTone_on()  (AUDIOCON.OCM=5)
35:                
36:                
37:                volatile unsigned char fSound=0; // boolean flags
38:                volatile int tmrId;  // duratio timer identifier
39:                volatile unsigned int *tones_list;  // list of tones and interval for playing tune
40:                int tick_msec=10; // tick interval in milliseconds, default 10msec.
41:                
42:                void cb_tone(void){ // timer call back function
43:                    mTone_off();
001B3C  800C54     MOV OC2CON, W4
001B3E  A10004     BCLR W4, #0
001B40  A11004     BCLR W4, #1
001B42  A12004     BCLR W4, #2
001B44  880C54     MOV W4, OC2CON
44:                    fSound &= ~(F_TONE|F_WHITE);
001B46  21FF25     MOV #0x1FF2, W5
001B48  784295     MOV.B [W5], W5
001B4A  B3CFA4     MOV #0xFA, W4
001B4C  62C204     AND.B W5, W4, W4
001B4E  780004     MOV W4, W0
001B50  B7FFF2     MOV.B WREG, fSound
45:                }// f()
001B52  060000     RETURN
46:                
47:                void sound_init(int tick_time){
48:                    if (tick_time) tick_msec=tick_time;
001B54  500FE0     SUB W0, #0x0, [W15]
001B56  320001     BRA Z, 0x1B5A
001B58  88FFA0     MOV W0, tick_msec
49:                    tmrId=create_timer(1,TIMER_SINGLE,(timer_handler_t *)cb_tone);
001B5A  21B3C2     MOV #0x1B3C, W2
001B5C  EB0080     CLR W1
001B5E  200010     MOV #0x1, W0
001B60  07FE88     RCALL create_timer
001B62  88FFB0     MOV W0, tmrId
50:                    AUDIOCON.OCTSEL=1; // select OCx timer
001B64  A8618A     BSET OC2CON, #3
51:                    AUDIOR=0;
001B66  EF2188     CLR OC2R
52:                    AUDIOTMR.TON=0;
001B68  A9E113     BCLR 0x113, #7
53:                    AUDIOTMR.TCKPS=1; // 1:8  // timer clock prescale divisor
001B6A  800894     MOV T3CON, W4
001B6C  A04004     BSET W4, #4
001B6E  A15004     BCLR W4, #5
001B70  880894     MOV W4, T3CON
54:                }//f()
001B72  060000     RETURN
55:                
56:                // play tone in background
57:                void tone(unsigned freq, // frequency in hertz
58:                          unsigned msec){ // duration in  milliseconds
001B74  BE9F88     MOV.D W8, [W15++]
001B76  781F8A     MOV W10, [W15++]
001B78  780501     MOV W1, W10
59:                    //
60:                    mTone_off(); 
001B7A  800C54     MOV OC2CON, W4
001B7C  A10004     BCLR W4, #0
001B7E  A11004     BCLR W4, #1
001B80  A12004     BCLR W4, #2
001B82  880C54     MOV W4, OC2CON
61:                    AUDIORS=FCY/16/freq; // determine tone duty cycle
001B84  B80461     MUL.UU W0, #1, W8
001B86  BE0108     MOV.D W8, W2
001B88  242400     MOV #0x4240, W0
001B8A  2000F1     MOV #0xF, W1
001B8C  07F49D     RCALL 0x4C8
001B8E  880C30     MOV W0, OC2RS
62:                    AUDIOTMR.TON=0;
001B90  A9E113     BCLR 0x113, #7
63:                    AUDIOPR=(FCY/8/freq)-1; // pwm period
001B92  BE0108     MOV.D W8, W2
001B94  284800     MOV #0x8480, W0
001B96  2001E1     MOV #0x1E, W1
001B98  07F497     RCALL 0x4C8
001B9A  E90200     DEC W0, W4
001B9C  880874     MOV W4, PR3
64:                    fSound |=F_TONE;
001B9E  A81FF2     BSET fSound, #0
65:                    mTone_on(); 
001BA0  800C54     MOV OC2CON, W4
001BA2  A00004     BSET W4, #0
001BA4  A11004     BCLR W4, #1
001BA6  A02004     BSET W4, #2
001BA8  880C54     MOV W4, OC2CON
66:                    AUDIOTMR.TON=1;
001BAA  A8E113     BSET 0x113, #7
67:                    update_timer(tmrId,msec/tick_msec);
001BAC  80FFB0     MOV tmrId, W0
001BAE  80FFA4     MOV tick_msec, W4
001BB0  781F80     MOV W0, [W15++]
001BB2  090011     REPEAT #0x11
001BB4  D88504     DIV.UW W10, W4
001BB6  780080     MOV W0, W1
001BB8  78004F     MOV [--W15], W0
001BBA  07FEA0     RCALL update_timer
68:                    start_timer(tmrId);
001BBC  80FFB0     MOV tmrId, W0
001BBE  07FE8C     RCALL start_timer
69:                } //tone();
001BC0  78054F     MOV [--W15], W10
001BC2  BE044F     MOV.D [--W15], W8
001BC4  060000     RETURN
70:                
71:                // play tune in background
72:                void tune(const unsigned *buffer){
73:                    tones_list=(unsigned *)buffer;
001BC6  88FFC0     MOV W0, tones_list
74:                    if (*tones_list && *(tones_list+1)){
001BC8  EB0200     CLR W4
001BCA  120F90     SUBR W4, [W0], [W15]
001BCC  32000C     BRA Z, 0x1BE6
001BCE  780200     MOV W0, W4
001BD0  EB0280     CLR W5
001BD2  128FD4     SUBR W5, [++W4], [W15]
001BD4  320008     BRA Z, 0x1BE6
75:                        fSound |= F_TUNE;
001BD6  A83FF2     BSET fSound, #1
76:                        AUDIOIF=0;
001BD8  A90085     BCLR 0x85, #0
77:                        AUDIOIE=1;
001BDA  A80095     BSET 0x95, #0
78:                        tone(*tones_list++,*tones_list++);
001BDC  780090     MOV [W0], W1
001BDE  88FFC4     MOV W4, tones_list
001BE0  780034     MOV [W4++], W0
001BE2  88FFC4     MOV W4, tones_list
001BE4  07FFC7     RCALL tone
79:                    }
80:                }//tune()
001BE6  060000     RETURN
81:                
82:                
83:                void white_noise(unsigned msec){
84:                    if (!fSound){
001BE8  21FF24     MOV #0x1FF2, W4
001BEA  784214     MOV.B [W4], W4
001BEC  524FE0     SUB.B W4, #0x0, [W15]
001BEE  3A0010     BRA NZ, 0x1C10
85:                        AUDIOTMR.TON=0;
001BF0  A9E113     BCLR 0x113, #7
86:                        AUDIOPR=(FCY/8/10000)-1; // pwm period
001BF2  200C74     MOV #0xC7, W4
001BF4  880874     MOV W4, PR3
87:                        AUDIOTMR.TON=0;
001BF6  A9E113     BCLR 0x113, #7
88:                        AUDIOIF=0;
001BF8  A90085     BCLR 0x85, #0
89:                        AUDIOIE=1;
001BFA  A80095     BSET 0x95, #0
90:                        AUDIOTMR.TON=1;
001BFC  A8E113     BSET 0x113, #7
91:                        update_timer(tmrId,msec/tick_msec);
001BFE  80FFB4     MOV tmrId, W4
001C00  80FFA5     MOV tick_msec, W5
001C02  090011     REPEAT #0x11
001C04  D88005     DIV.UW W0, W5
001C06  FD0080     EXCH W0, W1
001C08  780004     MOV W4, W0
001C0A  07FE78     RCALL update_timer
92:                        start_timer(tmrId);
001C0C  80FFB0     MOV tmrId, W0
001C0E  07FE64     RCALL start_timer
93:                    }
94:                    fSound |= F_WHITE;
001C10  A85FF2     BSET fSound, #2
95:                }// f()
001C12  060000     RETURN
96:                
97:                void while_sound(){
98:                    while (fSound);
001C14  21FF24     MOV #0x1FF2, W4
001C16  784214     MOV.B [W4], W4
001C18  524FE0     SUB.B W4, #0x0, [W15]
001C1A  3AFFFC     BRA NZ, while_sound
99:                }// f()
001C1C  060000     RETURN
100:               
101:               // interrupt at end of tone cycle
102:               void __attribute__((interrupt, no_auto_psv))  _AUDIO_ISR(void){
001C1E  F80036     PUSH RCOUNT
001C20  BE9F80     MOV.D W0, [W15++]
001C22  BE9F82     MOV.D W2, [W15++]
001C24  BE9F84     MOV.D W4, [W15++]
001C26  BE9F86     MOV.D W6, [W15++]
103:                  unsigned int f,d;
104:                  if (fSound&F_WHITE){
001C28  21FF24     MOV #0x1FF2, W4
001C2A  784214     MOV.B [W4], W4
001C2C  620264     AND W4, #0x4, W4
001C2E  320007     BRA Z, 0x1C3E
105:                      P_NOISE_OUT=rand()&1;
001C30  07F4B2     RCALL 0x596
001C32  6002E1     AND W0, #0x1, W5
001C34  DD2ACA     SL W5, #10, W5
001C36  801664     MOV LATB, W4
001C38  A1A004     BCLR W4, #10
001C3A  720205     IOR W4, W5, W4
001C3C  881664     MOV W4, LATB
106:                  }
107:                  if (!fSound) {
001C3E  21FF24     MOV #0x1FF2, W4
001C40  784214     MOV.B [W4], W4
001C42  524FE0     SUB.B W4, #0x0, [W15]
001C44  3A0003     BRA NZ, 0x1C4C
108:                      AUDIOIE=0;
001C46  A90095     BCLR 0x95, #0
109:                      AUDIOTMR.TON=0;
001C48  A9E113     BCLR 0x113, #7
001C4A  370027     BRA 0x1C9A
110:                  }else if (fSound==(fSound & F_TUNE)){
001C4C  21FF25     MOV #0x1FF2, W5
001C4E  784295     MOV.B [W5], W5
001C50  21FF24     MOV #0x1FF2, W4
001C52  784214     MOV.B [W4], W4
001C54  FB8285     ZE W5, W5
001C56  620262     AND W4, #0x2, W4
001C58  528F84     SUB W5, W4, [W15]
001C5A  3A001F     BRA NZ, 0x1C9A
111:                      f=*tones_list++;
001C5C  80FFC4     MOV tones_list, W4
001C5E  780034     MOV [W4++], W0
001C60  88FFC4     MOV W4, tones_list
112:                      d=*tones_list++;
001C62  7800B4     MOV [W4++], W1
001C64  88FFC4     MOV W4, tones_list
113:                      if (d){
001C66  508FE0     SUB W1, #0x0, [W15]
001C68  320015     BRA Z, 0x1C94
114:                           if (f){
001C6A  500FE0     SUB W0, #0x0, [W15]
001C6C  320002     BRA Z, 0x1C72
115:                               tone(f,d);
001C6E  07FF82     RCALL tone
001C70  370014     BRA 0x1C9A
116:                           }else{
117:                               update_timer(tmrId,d/tick_msec);
001C72  80FFB0     MOV tmrId, W0
001C74  80FFA4     MOV tick_msec, W4
001C76  781F80     MOV W0, [W15++]
001C78  090011     REPEAT #0x11
001C7A  D88084     DIV.UW W1, W4
001C7C  780080     MOV W0, W1
001C7E  78004F     MOV [--W15], W0
001C80  07FE3D     RCALL update_timer
118:                               start_timer(tmrId);
001C82  80FFB0     MOV tmrId, W0
001C84  07FE29     RCALL start_timer
119:                               fSound |= F_TONE;
001C86  A81FF2     BSET fSound, #0
120:                               mTone_on();
001C88  800C54     MOV OC2CON, W4
001C8A  A00004     BSET W4, #0
001C8C  A11004     BCLR W4, #1
001C8E  A02004     BSET W4, #2
001C90  880C54     MOV W4, OC2CON
001C92  370003     BRA 0x1C9A
121:                           }
122:                      }else{
123:                          fSound=0;
001C94  EF7FF2     CLR.B fSound
124:                          AUDIOIE=0;
001C96  A90095     BCLR 0x95, #0
125:                          AUDIOTMR.TON=0;
001C98  A9E113     BCLR 0x113, #7
126:                      } // if
127:                  }
128:                  AUDIOIF=0;
001C9A  A90085     BCLR 0x85, #0
129:               }// _AUDIO_ISR
001C9C  BE034F     MOV.D [--W15], W6
001C9E  BE024F     MOV.D [--W15], W4
001CA0  BE014F     MOV.D [--W15], W2
001CA2  BE004F     MOV.D [--W15], W0
001CA4  F90036     POP RCOUNT
001CA6  064000     RETFIE
130:               
131:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snes_paddle.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snes_paddle.c
21:                 * Author: jacques Deschênes
22:                 * Description:  SNES gemepad interface
23:                 *              1) a pulse on paddle latch input store last switches state in shift register
24:                 *              2) each rising edge of clock signal shift one bit out, bit 0 first.
25:                 *                 bit 0 is at output after latch so there is only 15 shift to do.
26:                 * Created on 25 février 2014, 16:41
27:                 */
28:                
29:                #include <stdlib.h>
30:                #include "snes_paddle.h"
31:                //#include "TVout.h"
32:                
33:                
34:                
35:                // the loop execute in 4 Tcy
36:                #define mDelay(usec) __asm__("MOV #%0,W4\n NOP\n DEC W4,W4\n BRA NZ .-4"::"i"(usec))
37:                
38:                void latch(){
39:                    P_PDL_LATCH=1;
001D22  A822CC     BSET LATB, #1
40:                    mDelay(CYCLES_PER_USEC/4);
001D24  200044     MOV #0x4, W4
001D26  000000     NOP
001D28  E90204     DEC W4, W4
001D2A  3AFFFD     BRA NZ, 0x1D26
41:                    P_PDL_LATCH=0;
001D2C  A922CC     BCLR LATB, #1
42:                    mDelay(CYCLES_PER_USEC/4);
001D2E  200044     MOV #0x4, W4
001D30  000000     NOP
001D32  E90204     DEC W4, W4
001D34  3AFFFD     BRA NZ, 0x1D30
43:                }//f()
001D36  060000     RETURN
44:                
45:                void bit_shift(){
46:                    P_PDL_CLK=1;
001D38  A802CC     BSET LATB, #0
47:                    mDelay(CYCLES_PER_USEC/4);
001D3A  200044     MOV #0x4, W4
001D3C  000000     NOP
001D3E  E90204     DEC W4, W4
001D40  3AFFFD     BRA NZ, 0x1D3C
48:                    P_PDL_CLK=0;
001D42  A902CC     BCLR LATB, #0
49:                    mDelay(CYCLES_PER_USEC/4);
001D44  200044     MOV #0x4, W4
001D46  000000     NOP
001D48  E90204     DEC W4, W4
001D4A  3AFFFD     BRA NZ, 0x1D46
50:                }// f()
001D4C  060000     RETURN
51:                
52:                unsigned read_paddle(int paddleId) {
001D4E  BE9F88     MOV.D W8, [W15++]
001D50  BE9F8A     MOV.D W10, [W15++]
001D52  BE9F8C     MOV.D W12, [W15++]
001D54  780680     MOV W0, W13
53:                    unsigned i,pdata, p1,p2;
54:                    p1=0;
001D5A  780509     MOV W9, W10
55:                    p2=0;
001D58  EB0480     CLR W9
56:                    latch(); // latch data in paddles shift register
001D56  07FFE5     RCALL latch
57:                    // shift out is least significant bit first.
58:                    for (i=0;i<15;i++){ // SNES paddle have 16 bits shift register
001D5C  780409     MOV W9, W8
001D76  E80408     INC W8, W8
001D78  540FEF     SUB W8, #0xF, [W15]
001D7A  3AFFF3     BRA NZ, 0x1D62
59:                        pdata=PADDLES_DATA_PORT;
001D62  801614     MOV PORTA, W4
60:                        p1 |= (pdata&PADDLE1)<<i;
001D64  6202E1     AND W4, #0x1, W5
001D66  DD2A88     SL W5, W8, W5
001D68  750505     IOR W10, W5, W10
61:                        p2 |= (pdata&PADDLE2)?1<<i:0;
001D5E  EB0580     CLR W11
001D60  20001C     MOV #0x1, W12
001D6A  620262     AND W4, #0x2, W4
001D6C  78028B     MOV W11, W5
001D6E  320001     BRA Z, 0x1D72
001D70  DD6288     SL W12, W8, W5
001D72  748485     IOR W9, W5, W9
62:                        bit_shift();
001D74  07FFE1     RCALL bit_shift
63:                    }
64:                    return paddleId==1?(~p1)&0xfff:(~p2)&0xfff;
001D7C  568FE1     SUB W13, #0x1, [W15]
001D7E  3A0004     BRA NZ, 0x1D88
001D80  EA800A     COM W10, W0
001D82  20FFF4     MOV #0xFFF, W4
001D84  600004     AND W0, W4, W0
001D86  370003     BRA 0x1D8E
001D88  EA8009     COM W9, W0
001D8A  20FFF4     MOV #0xFFF, W4
001D8C  600004     AND W0, W4, W0
65:                }//f()
001D8E  BE064F     MOV.D [--W15], W12
001D90  BE054F     MOV.D [--W15], W10
001D92  BE044F     MOV.D [--W15], W8
001D94  060000     RETURN
66:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snake.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   snake.c
21:                 * Author: jacques Deschênes
22:                 * Description: snake game.
23:                 * Created on 5 mars 2014, 16:01
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <time.h>
28:                #include "PICvision.h"
29:                
30:                
31:                // PIC24FJ64GA002 Configuration Bit Settings
32:                // CONFIG2
33:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
34:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
35:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
36:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
37:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
38:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
39:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
40:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
41:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
42:                
43:                // CONFIG1
44:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
45:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
46:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
47:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
48:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
49:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
50:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
51:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
52:                
53:                typedef struct symbol{
54:                    unsigned char x;
55:                    unsigned char y;
56:                    char part;
57:                }symbol_t;
58:                
59:                #define SNAKE_MAX_LEN  64
60:                
61:                typedef struct snake_struct{
62:                    unsigned length;
63:                    unsigned calories;
64:                    unsigned lifespan;
65:                    unsigned short dx;
66:                    unsigned short dy;
67:                    symbol_t body[SNAKE_MAX_LEN];
68:                }snake_t;
69:                
70:                typedef struct msg_struct{
71:                    unsigned char x;
72:                    unsigned char y;
73:                    char *text;
74:                }msg_t;
75:                
76:                // snake some symbols
77:                #define RING  102+32
78:                #define HEAD_RIGHT  103+32
79:                #define HEAD_LEFT 104+32
80:                #define HEAD_UP  105+32
81:                #define HEAD_DOWN 106+32
82:                #define MOUSE 109+32
83:                
84:                #define BASE_METABOLISM 2   // calories lost per seconde
85:                #define MOUSE_CALORIES  20  // calories gain by eating mouse
86:                
87:                snake_t snake;
88:                
89:                symbol_t mouse;
90:                
91:                const msg_t msgCALORIES={0,0,"calories: "};
92:                const msg_t msgSECONDS={16,0,"lifespan: "};
93:                const msg_t msgGAME_OVER={6,13,"game over"};
94:                const msg_t msgSTART={8,20, "press START to begin"};
95:                const msg_t msgSTARVATION={6,14,"died of starvation"};
96:                const msg_t msgWALL_COLLIDE={6,14,"died of wall collision"};
97:                const msg_t msgTAIL_BITE={6,14,"died of tail bite."};
98:                
99:                void print_msg(const msg_t msg){
000F94  BE9F88     MOV.D W8, [W15++]
000F96  BE0400     MOV.D W0, W8
100:                   set_curpos(msg.x,msg.y);
000F98  DE00C8     LSR W0, #8, W1
000F9A  FB8008     ZE W8, W0
000F9C  0703BF     RCALL set_curpos
101:                   print(msg.text);
000F9E  780009     MOV W9, W0
000FA0  070340     RCALL print
102:               }//f()
000FA2  BE044F     MOV.D [--W15], W8
000FA4  060000     RETURN
103:               
104:               void new_mouse(){
000FA6  BE9F88     MOV.D W8, [W15++]
000FA8  781F8A     MOV W10, [W15++]
105:                   unsigned short i, collide,mouseX,mouseY;
106:                   collide=1;
107:                   while (collide){
108:                       mouseX=rand()%(CHAR_PER_LINE-3)+2;
000FAA  200209     MOV #0x20, W9
000FAE  07FAF3     RCALL 0x596
000FB0  780401     MOV W1, W8
000FB2  090011     REPEAT #0x11
000FB4  D80009     DIV.SW W0, W9
000FB6  FD0401     EXCH W1, W8
000FB8  E88408     INC2 W8, W8
109:                       mouseY=rand()%(LINE_PER_SCREEN-3)+2;
000FBA  07FAED     RCALL 0x596
000FBC  200184     MOV #0x18, W4
000FBE  090011     REPEAT #0x11
000FC0  D80004     DIV.SW W0, W4
000FC2  E88081     INC2 W1, W1
110:                       for (i=0;i<snake.length;i++){
000FAC  21EE2A     MOV #0x1EE2, W10
000FC4  80F6C0     MOV snake, W0
000FC6  500FE0     SUB W0, #0x0, [W15]
000FC8  320010     BRA Z, 0xFEA
000FCA  78020A     MOV W10, W4
000FCC  EB0280     CLR W5
000FDE  E80285     INC W5, W5
000FE0  420263     ADD W4, #0x3, W4
000FE2  528F80     SUB W5, W0, [W15]
000FE4  39FFF4     BRA NC, 0xFCE
111:                           if ((mouseX==snake.body[i].x)&&(mouseY==snake.body[i].y)) break;
000FCE  784114     MOV.B [W4], W2
000FD0  FB8302     ZE W2, W6
000FD2  530F88     SUB W6, W8, [W15]
000FD4  3A0004     BRA NZ, 0xFDE
000FD6  904314     MOV.B [W4+1], W6
000FD8  FB8306     ZE W6, W6
000FDA  530F81     SUB W6, W1, [W15]
000FDC  320004     BRA Z, 0xFE6
112:                       }
113:                       if (i==snake.length) collide=0;
000FE6  500F85     SUB W0, W5, [W15]
000FE8  3AFFE2     BRA NZ, 0xFAE
114:                   }//while
115:                   mouse.x=mouseX;
000FEA  780008     MOV W8, W0
000FEC  B7FFA2     MOV.B WREG, mouse
116:                   mouse.y=mouseY;
000FEE  780001     MOV W1, W0
000FF0  B7FFA3     MOV.B WREG, 0x1FA3
117:                   set_curpos(mouse.x,mouse.y);
000FF2  FB8081     ZE W1, W1
000FF4  FB8008     ZE W8, W0
000FF6  070392     RCALL set_curpos
118:                   put_char(mouse.part);
000FF8  BFDFA4     MOV.B 0x1FA4, WREG
000FFA  070288     RCALL put_char
119:               }//f()
000FFC  78054F     MOV [--W15], W10
000FFE  BE044F     MOV.D [--W15], W8
001000  060000     RETURN
120:               
121:               void hide_snake(){
001002  BE9F88     MOV.D W8, [W15++]
001004  781F8A     MOV W10, [W15++]
122:                   unsigned i;
123:                   for (i=0;i<snake.length;i++){
001006  80F6C4     MOV snake, W4
001008  520FE0     SUB W4, #0x0, [W15]
00100A  32000F     BRA Z, 0x102A
00100C  21EE38     MOV #0x1EE3, W8
00100E  EB0480     CLR W9
001020  E80489     INC W9, W9
001022  440463     ADD W8, #0x3, W8
001024  80F6C4     MOV snake, W4
001026  520F89     SUB W4, W9, [W15]
001028  3EFFF4     BRA GTU, 0x1012
124:                       set_curpos(snake.body[i].x,snake.body[i].y);
001012  784218     MOV.B [W8], W4
001014  FB8084     ZE W4, W1
001016  97F878     MOV.B [W8-1], W0
001018  FB8000     ZE W0, W0
00101A  070380     RCALL set_curpos
125:                       put_char(SPACE);
001010  B3C20A     MOV #0x20, W10
00101C  78400A     MOV.B W10, W0
00101E  070276     RCALL put_char
126:                   }
127:               }//f()
00102A  78054F     MOV [--W15], W10
00102C  BE044F     MOV.D [--W15], W8
00102E  060000     RETURN
128:               
129:               void show_snake(){
001030  BE9F88     MOV.D W8, [W15++]
130:                   unsigned i;
131:                   for (i=0;i<snake.length;i++){
001032  80F6C4     MOV snake, W4
001034  520FE0     SUB W4, #0x0, [W15]
001036  32000E     BRA Z, 0x1054
001038  21EE38     MOV #0x1EE3, W8
00103A  EB0480     CLR W9
00104A  E80489     INC W9, W9
00104C  440463     ADD W8, #0x3, W8
00104E  80F6C4     MOV snake, W4
001050  520F89     SUB W4, W9, [W15]
001052  3EFFF4     BRA GTU, 0x103C
132:                       set_curpos(snake.body[i].x,snake.body[i].y);
00103C  784218     MOV.B [W8], W4
00103E  FB8084     ZE W4, W1
001040  97F878     MOV.B [W8-1], W0
001042  FB8000     ZE W0, W0
001044  07036B     RCALL set_curpos
133:                       put_char(snake.body[i].part);
001046  904018     MOV.B [W8+1], W0
001048  070261     RCALL put_char
134:                       
135:                   }//for
136:               }//f()
001054  BE044F     MOV.D [--W15], W8
001056  060000     RETURN
137:               
138:               
139:               void wait_start_signal(){
001058  781F88     MOV W8, [W15++]
140:                   unsigned p;
141:                   p=0;
142:                   print_msg(msgSTART);
00105A  845490     MOV 0x8A92, W0
00105C  8454A1     MOV 0x8A94, W1
00105E  07FF9A     RCALL print_msg
143:                   while (!(p&SNES_START)){
001066  600068     AND W0, #0x8, W0
001068  32FFFC     BRA Z, 0x1062
144:                     p=read_paddle(PADDLE1);
001060  200018     MOV #0x1, W8
001062  780008     MOV W8, W0
001064  070674     RCALL read_paddle
145:                   }
146:               }//f()
00106A  78044F     MOV [--W15], W8
00106C  060000     RETURN
147:               
148:               void animate_death(){
00106E  BE9F88     MOV.D W8, [W15++]
001070  BE9F8A     MOV.D W10, [W15++]
001072  781F8C     MOV W12, [W15++]
001080  B94B63     MUL.SU W9, #3, W6
001082  21EE34     MOV #0x1EE3, W4
001084  430404     ADD W6, W4, W8
149:                   int i,freq;
150:                   show_snake();
001074  07FFDD     RCALL show_snake
151:                   freq=snake.length*200;
001076  80F6C4     MOV snake, W4
00107C  200C8A     MOV #0xC8, W10
00107E  B9A50A     MUL.SS W4, W10, W10
152:                   for (i=snake.length-1;i>=0;i--){
001078  E90484     DEC W4, W9
00107A  330018     BRA N, 0x10AC
0010A4  E90489     DEC W9, W9
0010A6  540463     SUB W8, #0x3, W8
0010A8  548FE0     SUB W9, #0x0, [W15]
0010AA  3DFFEF     BRA GE, 0x108A
153:                       set_curpos(snake.body[i].x,snake.body[i].y);
00108A  784218     MOV.B [W8], W4
00108C  FB8084     ZE W4, W1
00108E  97F878     MOV.B [W8-1], W0
001090  FB8000     ZE W0, W0
001092  070344     RCALL set_curpos
154:                       put_char(32);
001086  B3C20B     MOV #0x20, W11
001094  78400B     MOV.B W11, W0
001096  07023A     RCALL put_char
155:                       tone(freq,500);
001088  201F4C     MOV #0x1F4, W12
001098  78008C     MOV W12, W1
00109A  78000A     MOV W10, W0
00109C  07056B     RCALL tone
156:                       wait_n_frame(frames_per_second/2);
00109E  D51ECA     LSR frames_per_second, WREG
0010A0  0704C1     RCALL wait_n_frame
157:                       freq -= 100;
0010A2  B1064A     SUB #0x64, W10
158:                   }//for
159:               }//f()
0010AC  78064F     MOV [--W15], W12
0010AE  BE054F     MOV.D [--W15], W10
0010B0  BE044F     MOV.D [--W15], W8
0010B2  060000     RETURN
160:               
161:               // dead cause
162:               typedef enum DEATH {STARVATION,WALL_COLLISION,TAIL_BITE} death_t;
163:               
164:               unsigned char reset=0;
165:               void game_over(death_t cause){
0010B4  781F88     MOV W8, [W15++]
0010B6  780400     MOV W0, W8
166:                   animate_death();
0010B8  07FFDA     RCALL animate_death
167:                   print_msg(msgGAME_OVER);
0010BA  8453C0     MOV 0x8A78, W0
0010BC  8453D1     MOV 0x8A7A, W1
0010BE  07FF6A     RCALL print_msg
168:                   switch (cause){
0010C0  540FE1     SUB W8, #0x1, [W15]
0010C2  320008     BRA Z, 0x10D4
0010C4  390003     BRA NC, 0x10CC
0010C6  540FE2     SUB W8, #0x2, [W15]
0010C8  3A000C     BRA NZ, 0x10E2
0010CA  370008     BRA 0x10DC
169:                       case STARVATION:
170:                           print_msg(msgSTARVATION);
0010CC  845550     MOV 0x8AAA, W0
0010CE  845561     MOV 0x8AAC, W1
0010D0  07FF61     RCALL print_msg
171:                           break;
0010D2  370007     BRA 0x10E2
172:                       case WALL_COLLISION:
173:                           print_msg(msgWALL_COLLIDE);
0010D4  845630     MOV 0x8AC6, W0
0010D6  845641     MOV 0x8AC8, W1
0010D8  07FF5D     RCALL print_msg
174:                           break;
0010DA  370003     BRA 0x10E2
175:                       case TAIL_BITE:
176:                           print_msg(msgTAIL_BITE);
0010DC  8456F0     MOV 0x8ADE, W0
0010DE  845701     MOV 0x8AE0, W1
0010E0  07FF59     RCALL print_msg
177:                           break;
178:                   }//switch
179:                   reset=1;
0010E2  B3C014     MOV #0x1, W4
0010E4  FD0200     EXCH W0, W4
0010E6  B7FFFC     MOV.B WREG, reset
0010E8  FD0200     EXCH W0, W4
180:                   wait_start_signal();
0010EA  07FFB6     RCALL wait_start_signal
181:               }//f()
0010EC  78044F     MOV [--W15], W8
0010EE  060000     RETURN
182:               
183:               void add_calories(unsigned short gain){
184:                   snake.calories+=gain;
0010F0  B43EDA     ADD 0x1EDA
185:                   print_msg(msgCALORIES);
0010F2  8452D0     MOV 0x8A5A, W0
0010F4  8452E1     MOV 0x8A5C, W1
0010F6  07FF4E     RCALL print_msg
186:                   print_int(snake.calories,1);
0010F8  200011     MOV #0x1, W1
0010FA  80F6D0     MOV 0x1EDA, W0
0010FC  0702B7     RCALL print_int
187:               }//f()
0010FE  060000     RETURN
188:               
189:               
190:               void burn_calories(unsigned short lost){
191:                   unsigned newLength;
192:                   if (lost < BASE_METABOLISM) lost=BASE_METABOLISM;
001100  500FE1     SUB W0, #0x1, [W15]
001102  3E0001     BRA GTU, 0x1106
001104  200020     MOV #0x2, W0
193:                   snake.calories -= lost;
001106  B53EDA     SUB 0x1EDA
194:                   if (snake.calories<0) snake.calories=0;
195:                   print_msg(msgCALORIES);
001108  8452D0     MOV 0x8A5A, W0
00110A  8452E1     MOV 0x8A5C, W1
00110C  07FF43     RCALL print_msg
196:                   clear_eol();
00110E  0702E5     RCALL clear_eol
197:                   print_int(snake.calories,1);
001110  200011     MOV #0x1, W1
001112  80F6D0     MOV 0x1EDA, W0
001114  0702AB     RCALL print_int
198:                   print_msg(msgSECONDS);
001116  845350     MOV 0x8A6A, W0
001118  845361     MOV 0x8A6C, W1
00111A  07FF3C     RCALL print_msg
199:                   print_int(snake.lifespan,1);
00111C  200011     MOV #0x1, W1
00111E  80F6E0     MOV 0x1EDC, W0
001120  0702A5     RCALL print_int
200:                   hide_snake();
001122  07FF6F     RCALL hide_snake
201:                   newLength=snake.calories/MOUSE_CALORIES+1;
001124  80F6D4     MOV 0x1EDA, W4
00112A  200145     MOV #0x14, W5
00112C  BE9F80     MOV.D W0, [W15++]
00112E  090011     REPEAT #0x11
001130  D88205     DIV.UW W4, W5
001132  780200     MOV W0, W4
001134  BE004F     MOV.D [--W15], W0
202:                   if (snake.calories){
001126  520FE0     SUB W4, #0x0, [W15]
001128  32000A     BRA Z, 0x113E
203:                       snake.length=newLength+1;
001136  E88204     INC2 W4, W4
001138  88F6C4     MOV W4, snake
204:                       show_snake();
00113A  07FF7A     RCALL show_snake
00113C  370002     BRA 0x1142
205:                   } else{
206:                       game_over(STARVATION);
00113E  EB0000     CLR W0
001140  07FFB9     RCALL game_over
207:                       return;
208:                   }
209:               }//f()
001142  060000     RETURN
210:               
211:               void check_if_got_mouse(){
212:                   if ((mouse.x==snake.body[0].x) && (mouse.y==snake.body[0].y)){
001144  21EE24     MOV #0x1EE2, W4
001146  784214     MOV.B [W4], W4
001148  21FA25     MOV #0x1FA2, W5
00114A  784295     MOV.B [W5], W5
00114C  52CF84     SUB.B W5, W4, [W15]
00114E  3A006A     BRA NZ, 0x1224
001150  21EE34     MOV #0x1EE3, W4
001152  784214     MOV.B [W4], W4
001154  21FA35     MOV #0x1FA3, W5
001156  784295     MOV.B [W5], W5
001158  52CF84     SUB.B W5, W4, [W15]
00115A  3A0064     BRA NZ, 0x1224
213:                       add_calories(MOUSE_CALORIES);
00115C  200140     MOV #0x14, W0
00115E  07FFC8     RCALL add_calories
214:                       snake.length++;
001160  80F6C4     MOV snake, W4
001162  E80284     INC W4, W5
001164  88F6C5     MOV W5, snake
215:                       snake.body[snake.length-1].part=RING;
001166  B92363     MUL.SU W4, #3, W6
001168  B3C861     MOV #0x86, W1
00116A  21EE40     MOV #0x1EE4, W0
00116C  7B7001     MOV.B W1, [W0+W6]
216:                       if (snake.dx){
00116E  80F6F6     MOV 0x1EDE, W6
001170  530FE0     SUB W6, #0x0, [W15]
001172  32002D     BRA Z, 0x11CE
217:                           if (snake.body[snake.length-2].y==snake.body[0].y){
001174  E98285     DEC2 W5, W5
001176  B92863     MUL.SU W5, #3, W0
001178  21EE27     MOV #0x1EE2, W7
00117A  400387     ADD W0, W7, W7
00117C  904017     MOV.B [W7+1], W0
00117E  21EE37     MOV #0x1EE3, W7
001180  784397     MOV.B [W7], W7
001182  504F87     SUB.B W0, W7, [W15]
001184  3A000C     BRA NZ, 0x119E
218:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x-snake.dx;
001186  B92063     MUL.SU W4, #3, W0
001188  21EE24     MOV #0x1EE2, W4
00118A  420200     ADD W4, W0, W4
00118C  B92863     MUL.SU W5, #3, W0
00118E  4002EA     ADD W0, #0xA, W5
001190  21ED87     MOV #0x1ED8, W7
001192  7AC067     MOV.B [W7+W5], W0
001194  504A06     SUB.B W0, W6, [W4]
219:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
001196  438285     ADD W7, W5, W5
001198  904295     MOV.B [W5+1], W5
00119A  984215     MOV.B W5, [W4+1]
00119C  370042     BRA 0x1222
220:                           }else{
221:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
00119E  B92063     MUL.SU W4, #3, W0
0011A0  B92B63     MUL.SU W5, #3, W6
0011A2  4302EA     ADD W6, #0xA, W5
0011A4  21ED86     MOV #0x1ED8, W6
0011A6  4303EA     ADD W6, #0xA, W7
0011A8  7AC166     MOV.B [W6+W5], W2
0011AA  787382     MOV.B W2, [W7+W0]
222:                               if (snake.body[0].y>snake.body[snake.length-2].y){
0011AC  430285     ADD W6, W5, W5
0011AE  904295     MOV.B [W5+1], W5
0011B0  21EE36     MOV #0x1EE3, W6
0011B2  784316     MOV.B [W6], W6
0011B4  534F85     SUB.B W6, W5, [W15]
0011B6  360005     BRA LEU, 0x11C2
223:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y-1;
0011B8  21EE24     MOV #0x1EE2, W4
0011BA  420200     ADD W4, W0, W4
0011BC  E94285     DEC.B W5, W5
0011BE  984215     MOV.B W5, [W4+1]
0011C0  370030     BRA 0x1222
224:                               }else{
225:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y+1;
0011C2  B92363     MUL.SU W4, #3, W6
0011C4  21EE24     MOV #0x1EE2, W4
0011C6  420206     ADD W4, W6, W4
0011C8  E84285     INC.B W5, W5
0011CA  984215     MOV.B W5, [W4+1]
0011CC  37002A     BRA 0x1222
226:                               }//if
227:                           }//if
228:                       }else {
229:                           if (snake.body[snake.length-2].x==snake.body[0].x){
0011CE  E98285     DEC2 W5, W5
0011D0  B92B63     MUL.SU W5, #3, W6
0011D2  43036A     ADD W6, #0xA, W6
0011D4  21ED87     MOV #0x1ED8, W7
0011D6  7B43E7     MOV.B [W7+W6], W7
0011D8  21EE26     MOV #0x1EE2, W6
0011DA  784316     MOV.B [W6], W6
0011DC  53CF86     SUB.B W7, W6, [W15]
0011DE  3A000C     BRA NZ, 0x11F8
230:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
0011E0  B92063     MUL.SU W4, #3, W0
0011E2  21EE24     MOV #0x1EE2, W4
0011E4  420200     ADD W4, W0, W4
0011E6  784A07     MOV.B W7, [W4]
231:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y-snake.dy;
0011E8  B92863     MUL.SU W5, #3, W0
0011EA  21EE26     MOV #0x1EE2, W6
0011EC  400286     ADD W0, W6, W5
0011EE  904315     MOV.B [W5+1], W6
0011F0  80F705     MOV 0x1EE0, W5
0011F2  534285     SUB.B W6, W5, W5
0011F4  984215     MOV.B W5, [W4+1]
0011F6  370015     BRA 0x1222
232:                           }else{
233:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
0011F8  B92063     MUL.SU W4, #3, W0
0011FA  21EE27     MOV #0x1EE2, W7
0011FC  438000     ADD W7, W0, W0
0011FE  B92963     MUL.SU W5, #3, W2
001200  4102EA     ADD W2, #0xA, W5
001202  21ED87     MOV #0x1ED8, W7
001204  438085     ADD W7, W5, W1
001206  904091     MOV.B [W1+1], W1
001208  984011     MOV.B W1, [W0+1]
234:                               if (snake.body[0].x>snake.body[snake.length-2].x){
00120A  7AC2E7     MOV.B [W7+W5], W5
00120C  534F85     SUB.B W6, W5, [W15]
00120E  360005     BRA LEU, 0x121A
235:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x-1;
001210  B92363     MUL.SU W4, #3, W6
001212  21EE24     MOV #0x1EE2, W4
001214  420206     ADD W4, W6, W4
001216  E94A05     DEC.B W5, [W4]
001218  370004     BRA 0x1222
236:                               }else{
237:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x+1;
00121A  B92363     MUL.SU W4, #3, W6
00121C  21EE24     MOV #0x1EE2, W4
00121E  420206     ADD W4, W6, W4
001220  E84A05     INC.B W5, [W4]
238:                               }//if
239:                           }//if
240:               
241:                       }//if
242:                       new_mouse();
001222  07FEC1     RCALL new_mouse
243:                   }
244:               }//f()
001224  060000     RETURN
245:               
246:               int bit_himself(){
247:                   int i;
248:                   for (i=1;i<snake.length;i++){
001226  80F6C7     MOV snake, W7
00122A  538FE1     SUB W7, #0x1, [W15]
00122C  360011     BRA LEU, 0x1250
001236  200015     MOV #0x1, W5
001242  E80285     INC W5, W5
001244  420263     ADD W4, #0x3, W4
001246  538F85     SUB W7, W5, [W15]
001248  3EFFF7     BRA GTU, 0x1238
249:                       if ((snake.body[0].x==snake.body[i].x) &&(snake.body[0].y==snake.body[i].y)){
00122E  BFDEE2     MOV.B 0x1EE2, WREG
001230  21EE31     MOV #0x1EE3, W1
001232  784091     MOV.B [W1], W1
001234  21EE54     MOV #0x1EE5, W4
001238  504F94     SUB.B W0, [W4], [W15]
00123A  3A0003     BRA NZ, 0x1242
00123C  904314     MOV.B [W4+1], W6
00123E  50CF86     SUB.B W1, W6, [W15]
001240  320006     BRA Z, 0x124E
250:                           return 1;
00124E  200010     MOV #0x1, W0
251:                       }
252:                   }
253:                   return 0;
001228  EB0000     CLR W0
00124A  EB0000     CLR W0
00124C  370001     BRA 0x1250
254:               }//f()
001250  060000     RETURN
255:               
256:               void move_snake(){
001268  B92363     MUL.SU W4, #3, W6
00126A  21EE24     MOV #0x1EE2, W4
00126C  430204     ADD W6, W4, W4
00126E  21EDF5     MOV #0x1EDF, W5
257:                   unsigned i;
258:                   if (!(snake.dx || snake.dy)) return;
001252  80F6F4     MOV 0x1EDE, W4
001254  520FE0     SUB W4, #0x0, [W15]
001256  3A0003     BRA NZ, 0x125E
001258  80F704     MOV 0x1EE0, W4
00125A  520FE0     SUB W4, #0x0, [W15]
00125C  32002F     BRA Z, 0x12BC
259:                   hide_snake();
00125E  07FED1     RCALL hide_snake
260:                   for (i=snake.length-1;i;i--){
001260  80F6C4     MOV snake, W4
001262  520FE1     SUB W4, #0x1, [W15]
001264  32000C     BRA Z, 0x127E
00127A  520F85     SUB W4, W5, [W15]
00127C  3AFFF9     BRA NZ, 0x1270
261:                       snake.body[i].x = snake.body[i-1].x;
001266  E98204     DEC2 W4, W4
001270  784314     MOV.B [W4], W6
001272  984236     MOV.B W6, [W4+3]
262:                       snake.body[i].y = snake.body[i-1].y;
001274  904314     MOV.B [W4+1], W6
001276  984246     MOV.B W6, [W4+4]
001278  520263     SUB W4, #0x3, W4
263:                   }
264:                   snake.body[0].x += snake.dx;
00127E  80F6F5     MOV 0x1EDE, W5
001280  21EE24     MOV #0x1EE2, W4
001282  42C294     ADD.B W5, [W4], W5
001284  FD0280     EXCH W0, W5
001286  B7FEE2     MOV.B WREG, 0x1EE2
001288  FD0280     EXCH W0, W5
265:                   snake.body[0].y += snake.dy;
00128A  80F704     MOV 0x1EE0, W4
00128C  21EE36     MOV #0x1EE3, W6
00128E  424216     ADD.B W4, [W6], W4
001290  FD0200     EXCH W0, W4
001292  B7FEE3     MOV.B WREG, 0x1EE3
001294  FD0200     EXCH W0, W4
266:                   if ((snake.body[0].x<1)||(snake.body[0].x>=(CHAR_PER_LINE-1)) ||
001296  E94285     DEC.B W5, W5
001298  B3C206     MOV #0x20, W6
00129A  52CF86     SUB.B W5, W6, [W15]
00129C  3E0004     BRA GTU, 0x12A6
00129E  524FE1     SUB.B W4, #0x1, [W15]
0012A0  360002     BRA LEU, 0x12A6
267:                       (snake.body[0].y<2) || (snake.body[0].y>=LINE_PER_SCREEN)){
0012A2  524FFA     SUB.B W4, #0x1A, [W15]
0012A4  360003     BRA LEU, 0x12AC
268:                       game_over(WALL_COLLISION);
0012A6  200010     MOV #0x1, W0
0012A8  07FF05     RCALL game_over
0012AA  370008     BRA 0x12BC
269:                   }else if (bit_himself()){
0012AC  07FFBC     RCALL bit_himself
0012AE  500FE0     SUB W0, #0x0, [W15]
0012B0  320003     BRA Z, 0x12B8
270:                       game_over(TAIL_BITE);
0012B2  200020     MOV #0x2, W0
0012B4  07FEFF     RCALL game_over
0012B6  370002     BRA 0x12BC
271:                   }else{
272:                       check_if_got_mouse();
0012B8  07FF45     RCALL check_if_got_mouse
273:                       show_snake();
0012BA  07FEBA     RCALL show_snake
274:                   }//if
275:               }//f()
0012BC  060000     RETURN
276:               
277:               void present_game(){
278:                   clear_screen();
0012BE  0701AA     RCALL clear_screen
279:                   print("**************\r");
0012C0  2893A0     MOV #0x893A, W0
0012C2  0701AF     RCALL print
280:                   print("* SNAKE GAME *\r");
0012C4  2894A0     MOV #0x894A, W0
0012C6  0701AD     RCALL print
281:                   print("**************\r\r");
0012C8  2895A0     MOV #0x895A, W0
0012CA  0701AB     RCALL print
282:                   print("Eating a mouse increase snake length.\r");
0012CC  2896B0     MOV #0x896B, W0
0012CE  0701A9     RCALL print
283:                   print("Snake burn 10% of is calaries/sec.\r");
0012D0  289920     MOV #0x8992, W0
0012D2  0701A7     RCALL print
284:                   print("Die of starvation when calories=0.\r");
0012D4  289B60     MOV #0x89B6, W0
0012D6  0701A5     RCALL print
285:                   print("Eating a mouse give 20 calories.\r");
0012D8  289DA0     MOV #0x89DA, W0
0012DA  0701A3     RCALL print
286:                   print("Die when hitting wall.\r");
0012DC  289FC0     MOV #0x89FC, W0
0012DE  0701A1     RCALL print
287:                   print("Die when bitting his tail.\r\r");
0012E0  28A140     MOV #0x8A14, W0
0012E2  07019F     RCALL print
288:                   print("Use ARROWS to control snake.\r");
0012E4  28A310     MOV #0x8A31, W0
0012E6  07019D     RCALL print
289:                   wait_start_signal();
0012E8  07FEB7     RCALL wait_start_signal
290:               }//f()
0012EA  060000     RETURN
291:               
292:               void game_init(){
0012EC  781F88     MOV W8, [W15++]
293:                   reset=0;
0012EE  EF7FFC     CLR.B reset
294:                   srand(time(0));
0012F0  EB0000     CLR W0
0012F2  07F7D4     RCALL 0x29C
0012F4  07F949     RCALL 0x588
295:                   //snake initialisation
296:                   snake.dx=0;
0012F6  EB0400     CLR W8
0012F8  88F6F8     MOV W8, 0x1EDE
297:                   snake.dy=0;
0012FA  88F708     MOV W8, 0x1EE0
298:                   snake.length=2;
0012FC  200024     MOV #0x2, W4
0012FE  88F6C4     MOV W4, snake
299:                   snake.calories=MOUSE_CALORIES;
001300  200144     MOV #0x14, W4
001302  88F6D4     MOV W4, 0x1EDA
300:                   snake.lifespan=0;
001304  88F6E8     MOV W8, 0x1EDC
301:                   snake.body[0].x=12;
001306  B3C0C4     MOV #0xC, W4
001308  FD0200     EXCH W0, W4
00130A  B7FEE2     MOV.B WREG, 0x1EE2
00130C  B7FEE3     MOV.B WREG, 0x1EE3
00130E  FD0200     EXCH W0, W4
302:                   snake.body[0].y=12;
303:                   snake.body[0].part=HEAD_RIGHT;
001310  B3C875     MOV #0x87, W5
001312  FD0280     EXCH W0, W5
001314  B7FEE4     MOV.B WREG, 0x1EE4
001316  FD0280     EXCH W0, W5
304:                   snake.body[1].x=11;
001318  B3C0B5     MOV #0xB, W5
00131A  FD0280     EXCH W0, W5
00131C  B7FEE5     MOV.B WREG, 0x1EE5
00131E  FD0280     EXCH W0, W5
305:                   snake.body[1].y=12;
001320  FD0200     EXCH W0, W4
001322  B7FEE6     MOV.B WREG, 0x1EE6
001324  FD0200     EXCH W0, W4
306:                   snake.body[1].part=RING;
001326  B3C864     MOV #0x86, W4
001328  FD0200     EXCH W0, W4
00132A  B7FEE7     MOV.B WREG, 0x1EE7
00132C  FD0200     EXCH W0, W4
307:                   mouse.part=MOUSE;
00132E  424267     ADD.B W4, #0x7, W4
001330  FD0200     EXCH W0, W4
001332  B7FFA4     MOV.B WREG, 0x1FA4
001334  FD0200     EXCH W0, W4
308:                   clear_screen();
001336  07016E     RCALL clear_screen
309:                   print_msg(msgCALORIES);
001338  8452D0     MOV 0x8A5A, W0
00133A  8452E1     MOV 0x8A5C, W1
00133C  07FE2B     RCALL print_msg
310:                   print_int(snake.calories,1);
00133E  200011     MOV #0x1, W1
001340  80F6D0     MOV 0x1EDA, W0
001342  070194     RCALL print_int
311:                   print_msg(msgSECONDS);
001344  845350     MOV 0x8A6A, W0
001346  845361     MOV 0x8A6C, W1
001348  07FE25     RCALL print_msg
312:                   print_int(snake.lifespan,1);
00134A  200011     MOV #0x1, W1
00134C  80F6E0     MOV 0x1EDC, W0
00134E  07018E     RCALL print_int
313:                   //draw  borders
314:                   rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001350  200014     MOV #0x1, W4
001352  200D73     MOV #0xD7, W3
001354  780103     MOV W3, W2
001356  200081     MOV #0x8, W1
001358  780008     MOV W8, W0
00135A  07FC5A     RCALL rectangle
315:                   new_mouse();
00135C  07FE24     RCALL new_mouse
316:                   show_snake();
00135E  07FE68     RCALL show_snake
317:               }//f()
001360  78044F     MOV [--W15], W8
001362  060000     RETURN
318:               
319:               
320:               
321:               int main(void) {
001364  BE9F88     MOV.D W8, [W15++]
001366  781F8A     MOV W10, [W15++]
322:                   unsigned p,frame_count;
323:                   PICvision_init();
001368  070536     RCALL PICvision_init
324:                   timers_init(100);
00136A  200640     MOV #0x64, W0
00136C  070230     RCALL timers_init
325:                   sound_init(10);
00136E  2000A0     MOV #0xA, W0
001370  0703F1     RCALL sound_init
326:                   present_game();
001372  07FFA5     RCALL present_game
327:                   game_init();
001374  07FFBB     RCALL game_init
328:                   frame_count=0;
001376  EB0400     CLR W8
329:                   while (1){
330:                       wait_n_frame(10);
00137C  2000A0     MOV #0xA, W0
00137E  070352     RCALL wait_n_frame
331:                       frame_count += 10;
001380  44046A     ADD W8, #0xA, W8
332:                       if (frame_count%frames_per_second==0){
001382  80F654     MOV frames_per_second, W4
001384  BE9F80     MOV.D W0, [W15++]
001386  090011     REPEAT #0x11
001388  D88404     DIV.UW W8, W4
00138A  780201     MOV W1, W4
00138C  BE004F     MOV.D [--W15], W0
00138E  520FE0     SUB W4, #0x0, [W15]
001390  3A000E     BRA NZ, 0x13AE
333:                           snake.lifespan +=1;
001392  EC3EDC     INC 0x1EDC
334:                           burn_calories(snake.calories / 10);
001394  80F6D0     MOV 0x1EDA, W0
001396  2000A4     MOV #0xA, W4
001398  781F81     MOV W1, [W15++]
00139A  090011     REPEAT #0x11
00139C  D88004     DIV.UW W0, W4
00139E  7800CF     MOV [--W15], W1
0013A0  07FEAF     RCALL burn_calories
335:                           rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
0013A2  200014     MOV #0x1, W4
0013A4  200D73     MOV #0xD7, W3
0013A6  780103     MOV W3, W2
0013A8  200081     MOV #0x8, W1
0013AA  EB0000     CLR W0
0013AC  07FC31     RCALL rectangle
336:                       }
337:                       p=read_paddle(PADDLE1);
0013AE  200010     MOV #0x1, W0
0013B0  0704CE     RCALL read_paddle
338:                       switch (p){
001378  200209     MOV #0x20, W9
0013B2  500F89     SUB W0, W9, [W15]
0013B4  32002A     BRA Z, 0x140A
0013B6  3E0003     BRA GTU, 0x13BE
0013B8  500FF0     SUB W0, #0x10, [W15]
0013BA  3A0030     BRA NZ, 0x141C
0013BC  37001C     BRA 0x13F6
0013BE  200404     MOV #0x40, W4
0013C0  500F84     SUB W0, W4, [W15]
0013C2  320004     BRA Z, 0x13CC
0013C4  200804     MOV #0x80, W4
0013C6  500F84     SUB W0, W4, [W15]
0013C8  3A0029     BRA NZ, 0x141C
0013CA  37000A     BRA 0x13E0
339:                           case SNES_LEFT:
340:                               if (snake.dx==1){
0013CC  80F6F4     MOV 0x1EDE, W4
0013CE  520FE1     SUB W4, #0x1, [W15]
0013D0  320025     BRA Z, 0x141C
341:                                   break;
342:                               }
343:                               snake.dx =-1;
0013D2  EFBEDE     SETM 0x1EDE
344:                               snake.dy=0;
0013D4  EF3EE0     CLR 0x1EE0
345:                               snake.body[0].part=HEAD_LEFT;
0013D6  B3C884     MOV #0x88, W4
0013D8  FD0200     EXCH W0, W4
0013DA  B7FEE4     MOV.B WREG, 0x1EE4
0013DC  FD0200     EXCH W0, W4
346:                               break;
0013DE  37001E     BRA 0x141C
347:                           case SNES_RIGHT:
348:                               if (snake.dx==-1){
0013E0  80F6F4     MOV 0x1EDE, W4
0013E2  420FE1     ADD W4, #0x1, [W15]
0013E4  32001B     BRA Z, 0x141C
349:                                   break;
350:                               }
351:                               snake.dx=1;
0013E6  200014     MOV #0x1, W4
0013E8  88F6F4     MOV W4, 0x1EDE
352:                               snake.dy=0;
0013EA  EF3EE0     CLR 0x1EE0
353:                               snake.body[0].part=HEAD_RIGHT;
0013EC  B3C874     MOV #0x87, W4
0013EE  FD0200     EXCH W0, W4
0013F0  B7FEE4     MOV.B WREG, 0x1EE4
0013F2  FD0200     EXCH W0, W4
354:                               break;
0013F4  370013     BRA 0x141C
355:                           case SNES_UP:
356:                               if (snake.dy==1){
0013F6  80F704     MOV 0x1EE0, W4
0013F8  520FE1     SUB W4, #0x1, [W15]
0013FA  320010     BRA Z, 0x141C
357:                                   break;
358:                               }
359:                               snake.dy=-1;
0013FC  EFBEE0     SETM 0x1EE0
360:                               snake.dx=0;
0013FE  EF3EDE     CLR 0x1EDE
361:                               snake.body[0].part=HEAD_UP;
001400  B3C894     MOV #0x89, W4
001402  FD0200     EXCH W0, W4
001404  B7FEE4     MOV.B WREG, 0x1EE4
001406  FD0200     EXCH W0, W4
362:                               break;
001408  370009     BRA 0x141C
363:                           case SNES_DOWN:
364:                               if (snake.dy==-1){
00140A  80F704     MOV 0x1EE0, W4
00140C  420FE1     ADD W4, #0x1, [W15]
00140E  320006     BRA Z, 0x141C
365:                                   break;
366:                               }
367:                               snake.dy=1;
001410  200014     MOV #0x1, W4
001412  88F704     MOV W4, 0x1EE0
368:                               snake.dx=0;
001414  EF3EDE     CLR 0x1EDE
369:                               snake.body[0].part=HEAD_DOWN;
00137A  B3C8AA     MOV #0x8A, W10
001416  FD0500     EXCH W0, W10
001418  B7FEE4     MOV.B WREG, 0x1EE4
00141A  FD0500     EXCH W0, W10
370:                               break;
371:               //            default:
372:               //                snake.dx=0;
373:               //                snake.dy=0;
374:               //                break;
375:                       }//switch
376:                       move_snake();
00141C  07FF1A     RCALL move_snake
377:                       if (reset) game_init();
00141E  21FFC4     MOV #0x1FFC, W4
001420  784214     MOV.B [W4], W4
001422  524FE0     SUB.B W4, #0x0, [W15]
001424  32FFAB     BRA Z, 0x137C
001426  07FF62     RCALL game_init
001428  37FFA9     BRA 0x137C
378:                   }//while
379:                   return (EXIT_SUCCESS);
380:               }//main()
381:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/hardwareProfile.c  ------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   hardwareProfile.h
21:                 * Author: jacques Deschênes
22:                 * Description:  try to centralize  hardware specific.
23:                 * Created on 1 march 2014
24:                 */
25:                
26:                #include "hardwareProfile.h"
27:                
28:                void HardwareConfig(){
29:                    // peripheral to pin association.
30:                    PPSUnLock;
001CA8  803A16     MOV OSCCON, W6
001CAA  B20BF6     AND #0xBF, W6
001CAC  200464     MOV #0x46, W4
001CAE  200575     MOV #0x57, W5
001CB0  207427     MOV #0x742, W7
001CB2  784B84     MOV.B W4, [W7]
001CB4  784B85     MOV.B W5, [W7]
001CB6  784B86     MOV.B W6, [W7]
31:                    PPSOutput(PPS_RP5,PPS_SDO1);   // video pixels output
001CB8  803626     MOV RPOR2, W6
001CBA  2E0FF7     MOV #0xE0FF, W7
001CBC  630307     AND W6, W7, W6
001CBE  207000     MOV #0x700, W0
001CC0  730300     IOR W6, W0, W6
001CC2  883626     MOV W6, RPOR2
32:                    PPSOutput(PPS_RP6,PPS_OC4);  // video delay output
001CC4  803630     MOV RPOR3, W0
001CC6  2FFE06     MOV #0xFFE0, W6
001CC8  600006     AND W0, W6, W0
001CCA  B30150     IOR #0x15, W0
001CCC  883630     MOV W0, RPOR3
33:                    PPSOutput(PPS_RP7,PPS_OC1);  // video sync output
001CCE  803630     MOV RPOR3, W0
001CD0  600387     AND W0, W7, W7
001CD2  212000     MOV #0x1200, W0
001CD4  738380     IOR W7, W0, W7
001CD6  883637     MOV W7, RPOR3
34:                    PPSOutput(PPS_RP8,PPS_OC2);  // audio output
001CD8  803647     MOV RPOR4, W7
001CDA  638306     AND W7, W6, W6
001CDC  B30136     IOR #0x13, W6
001CDE  883646     MOV W6, RPOR4
35:                    PPSLock;
001CE0  803A16     MOV OSCCON, W6
001CE2  A06006     BSET W6, #6
001CE4  207427     MOV #0x742, W7
001CE6  784B84     MOV.B W4, [W7]
001CE8  784B85     MOV.B W5, [W7]
001CEA  784B86     MOV.B W6, [W7]
36:                    // pins data direction
37:                    P_PIXEL_OUT_TRIS=0;     // video pixels output
001CEC  A9A2C8     BCLR TRISB, #5
38:                    P_VDLY_OUT_TRIS=0;     // video delay output
001CEE  A9C2C8     BCLR TRISB, #6
39:                    P_VSYNC_OUT_TRIS=0;     // video sync output
001CF0  A9E2C8     BCLR TRISB, #7
40:                    P_AUDIO_OUT_TRIS=0;     // audio output
001CF2  A902C9     BCLR 0x2C9, #0
41:                    P_NOISE_OUT_TRIS=0;     /// white noise output
001CF4  A942C9     BCLR 0x2C9, #2
42:                    P_PIXDLY_IN_TRIS=1;     //input video pixels delay
001CF6  A822C9     BSET 0x2C9, #1
43:                    P_VIDEO_MODE_TRIS=1;    //input NTSC/PAL select input
001CF8  A882C9     BSET 0x2C9, #4
44:                    VIDMODE_ANDIS=1;   // disable ADC  on NTSC/PAL select input.
001CFA  A8832D     BSET 0x32D, #4
45:                    // paddles interface I/O setting
46:                    P_PDL1_DAT_TRIS=1;      // paddle 1 data as input
001CFC  A802C0     BSET TRISA, #0
47:                    P_PDL2_DAT_TRIS=1;      // paddle 2 data as input
001CFE  A822C0     BSET TRISA, #1
48:                    P_PDL_CLK_TRIS=0;       // paddles clock signal as output
001D00  A902C8     BCLR TRISB, #0
49:                    P_PDL_LATCH_TRIS=0;     // paddles latch signal as output
001D02  A922C8     BCLR TRISB, #1
50:                    P_PDL1_ANDIS=1;         // disable analog input
001D04  A8032C     BSET AD1PCFG, #0
51:                    P_PDL2_ANDIS=1;         // disable analog input
001D06  A8232C     BSET AD1PCFG, #1
52:                    // interrupts priorities
53:                    VSYNCIP=7;  // timer interrupt used for video output must have highest priority
001D08  270000     MOV #0x7000, W0
001D0A  B720A6     IOR IPC1
54:                    PIXIP=7;  // change notification interrupt used for video pixels must have highest priority
001D0C  B720AC     IOR IPC4
55:                    AUDIOIP=3; // audio output timer interrupt priority
001D0E  800544     MOV IPC2, W4
001D10  B30034     IOR #0x3, W4
001D12  A12004     BCLR W4, #2
001D14  880544     MOV W4, IPC2
56:                    SYSTICKIP=2; // system ticks timer interrupt priority
001D16  800524     MOV IPC0, W4
001D18  A1C004     BCLR W4, #12
001D1A  A0D004     BSET W4, #13
001D1C  A1E004     BCLR W4, #14
001D1E  880524     MOV W4, IPC0
57:                }//f()
001D20  060000     RETURN
58:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/graphics.c  -------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   graphics.h
21:                 * Author: jacques Deschênes
22:                 * Description: Draw geometrics figures.
23:                 *      coordinates origin is screen top,left, x increase to right, y increase to bottom
24:                 * Created on 28 février 2014, 13:07
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "graphics.h"
29:                
30:                // draw a dot
31:                
32:                void plot(int x, int y, int color){
33:                    int h,ofs;
34:                    if ((y>=VPIXELS)||(x>=HPIXELS)) return; // bound check
000AE2  200D74     MOV #0xD7, W4
000AE4  508F84     SUB W1, W4, [W15]
000AE6  3C0028     BRA GT, 0xB38
000AE8  500F84     SUB W0, W4, [W15]
000AEA  3C0026     BRA GT, 0xB38
35:                    h= x/8;
000AEC  200084     MOV #0x8, W4
000AEE  781F81     MOV W1, [W15++]
000AF0  090011     REPEAT #0x11
000AF2  D80004     DIV.SW W0, W4
000AF4  780201     MOV W1, W4
000AF6  7800CF     MOV [--W15], W1
36:                    ofs = 7 - x%8;
000AF8  1202E7     SUBR W4, #0x7, W5
37:                    if (color==INVERT)
000AFA  510FE2     SUB W2, #0x2, [W15]
000AFC  3A0009     BRA NZ, 0xB10
38:                        video_buffer[y][h] ^= (1<<ofs);
000AFE  208006     MOV #0x800, W6
000B00  B9097B     MUL.SU W1, #27, W2
000B02  400082     ADD W0, W2, W1
000B04  430381     ADD W6, W1, W7
000B06  200014     MOV #0x1, W4
000B08  DD2285     SL W4, W5, W5
000B0A  78C266     MOV.B [W6+W1], W4
000B0C  6A4B85     XOR.B W4, W5, [W7]
000B0E  370014     BRA 0xB38
39:                    else if (color==WHITE)
000B10  510FE1     SUB W2, #0x1, [W15]
000B12  3A0009     BRA NZ, 0xB26
40:                        video_buffer[y][h]|= (1<<ofs);
000B14  208006     MOV #0x800, W6
000B16  B9097B     MUL.SU W1, #27, W2
000B18  400082     ADD W0, W2, W1
000B1A  430381     ADD W6, W1, W7
000B1C  200014     MOV #0x1, W4
000B1E  DD2285     SL W4, W5, W5
000B20  78C266     MOV.B [W6+W1], W4
000B22  724B85     IOR.B W4, W5, [W7]
000B24  370009     BRA 0xB38
41:                    else
42:                        video_buffer[y][h]&= ~(1<<ofs);
000B26  208006     MOV #0x800, W6
000B28  B9097B     MUL.SU W1, #27, W2
000B2A  400082     ADD W0, W2, W1
000B2C  430381     ADD W6, W1, W7
000B2E  200014     MOV #0x1, W4
000B30  DD2285     SL W4, W5, W5
000B32  EAC285     COM.B W5, W5
000B34  78C366     MOV.B [W6+W1], W6
000B36  62CB86     AND.B W5, W6, [W7]
43:                } // plot()
000B38  060000     RETURN
44:                
45:                // dessine une droite en utilisant l'algorithme de Bresenham
46:                void line(int x1, int y1, int x2, int y2, int color){
000B3A  4787EA     ADD W15, #0xA, W15
000B3C  BE9F88     MOV.D W8, [W15++]
000B3E  BE9F8A     MOV.D W10, [W15++]
000B40  BE9F8C     MOV.D W12, [W15++]
000B42  781F8E     MOV W14, [W15++]
000B44  780400     MOV W0, W8
000B46  780501     MOV W1, W10
000B48  780582     MOV W2, W11
000B4A  9FB7F3     MOV W3, [W15-18]
000B4C  780604     MOV W4, W12
000B62  448408     ADD W9, W8, W8
000B64  370004     BRA 0xB6E
000B78  540209     SUB W8, W9, W4
000B8E  44850A     ADD W9, W10, W10
000B9A  550209     SUB W10, W9, W4
47:                    int deltax,deltay;
48:                    plot(x1,y1,color);
000B4E  78010C     MOV W12, W2
000B50  78008A     MOV W10, W1
000B52  780008     MOV W8, W0
000B54  07FFC6     RCALL plot
49:                    if (y1==y2){// cas particulier ligne horizontale
000B56  97B27F     MOV [W15-18], W4
000B58  550F84     SUB W10, W4, [W15]
000B5A  3A0012     BRA NZ, 0xB80
50:                        deltax= x1<x2?1:-1;
000B5C  540F8B     SUB W8, W11, [W15]
000B5E  3D0003     BRA GE, 0xB66
000B60  200019     MOV #0x1, W9
000B66  EB8480     SETM W9
51:                        while (x1!=x2){
000B68  540F8B     SUB W8, W11, [W15]
000B6A  3AFFFB     BRA NZ, 0xB62
000B6C  37004B     BRA 0xC04
000B7A  558F84     SUB W11, W4, [W15]
000B7C  3AFFF8     BRA NZ, 0xB6E
000B7E  370042     BRA 0xC04
52:                            x1 += deltax;
53:                            plot(x1,y1,color);
000B6E  78010C     MOV W12, W2
000B70  78008A     MOV W10, W1
000B72  780008     MOV W8, W0
000B74  07FFB6     RCALL plot
000B76  440409     ADD W8, W9, W8
54:                        }
55:                    }else if (x1==x2){ // cas particulier ligne verticale
000B80  540F8B     SUB W8, W11, [W15]
000B82  3A0010     BRA NZ, 0xBA4
56:                        deltay= y1<y2?1:-1;
000B84  EB8480     SETM W9
000B86  97B2FF     MOV [W15-18], W5
000B88  550F85     SUB W10, W5, [W15]
000B8A  3D0001     BRA GE, 0xB8E
000B8C  200019     MOV #0x1, W9
57:                        while (y1!=y2){
000B9C  97B2FF     MOV [W15-18], W5
000B9E  528F84     SUB W5, W4, [W15]
000BA0  3AFFF7     BRA NZ, 0xB90
000BA2  370030     BRA 0xC04
58:                            y1+=deltay;
59:                            plot(x1,y1,color);
000B90  78010C     MOV W12, W2
000B92  78008A     MOV W10, W1
000B94  780008     MOV W8, W0
000B96  07FFA5     RCALL plot
000B98  450509     ADD W10, W9, W10
60:                        }
61:                    }else{
62:                        int sx,sy,err,e2;
63:                        deltax=abs(x2-x1);
000BA4  558708     SUB W11, W8, W14
000BA6  A7F00E     BTSC W14, #15
000BA8  EA070E     NEG W14, W14
64:                        deltay=abs(y2-y1);
000BAA  97B2FF     MOV [W15-18], W5
000BAC  52820A     SUB W5, W10, W4
000BAE  A7F004     BTSC W4, #15
000BB0  EA0204     NEG W4, W4
000BB2  9FBF84     MOV W4, [W15-16]
65:                        sx = x1<x2?1:-1;
000BB4  EB8200     SETM W4
000BB6  9FB7E4     MOV W4, [W15-20]
000BB8  540F8B     SUB W8, W11, [W15]
000BBA  3D0002     BRA GE, 0xBC0
000BBC  200015     MOV #0x1, W5
000BBE  9FB7E5     MOV W5, [W15-20]
66:                        sy = y1<y2?1:-1;
000BC0  EB8200     SETM W4
000BC2  9FB7D4     MOV W4, [W15-22]
000BC4  97B2FF     MOV [W15-18], W5
000BC6  550F85     SUB W10, W5, [W15]
000BC8  3D0002     BRA GE, 0xBCE
000BCA  200014     MOV #0x1, W4
000BCC  9FB7D4     MOV W4, [W15-22]
67:                        err=deltax-deltay;
000BCE  97BA8F     MOV [W15-16], W5
000BD0  570485     SUB W14, W5, W9
68:                        while (!((x1==x2) && (y1==y2))){
000BD6  78040B     MOV W11, W8
000BFA  540F8B     SUB W8, W11, [W15]
000BFC  3AFFED     BRA NZ, 0xBD8
000BFE  97B2FF     MOV [W15-18], W5
000C00  550F85     SUB W10, W5, [W15]
000C02  3AFFE9     BRA NZ, 0xBD6
69:                            e2=err<<1;
000BD8  448209     ADD W9, W9, W4
70:                            if (e2>-deltay){
000BD2  EA0685     NEG W5, W13
000BD4  370001     BRA 0xBD8
000BDA  520F8D     SUB W4, W13, [W15]
000BDC  340005     BRA LE, 0xBE8
71:                               err -= deltay;
000BDE  97BA0F     MOV [W15-16], W4
000BE0  548484     SUB W9, W4, W9
72:                               x1 += sx;
000BE2  97B2EF     MOV [W15-20], W5
000BE4  440405     ADD W8, W5, W8
000BE6  370005     BRA 0xBF2
73:                            }else if (e2<deltax){
000BE8  570F84     SUB W14, W4, [W15]
000BEA  340003     BRA LE, 0xBF2
74:                                err +=deltax;
000BEC  44848E     ADD W9, W14, W9
75:                                y1 += sy;
000BEE  97B25F     MOV [W15-22], W4
000BF0  450504     ADD W10, W4, W10
76:                            }
77:                            plot(x1,y1,color);
000BF2  78010C     MOV W12, W2
000BF4  78008A     MOV W10, W1
000BF6  780008     MOV W8, W0
000BF8  07FF74     RCALL plot
78:                        }
79:                    }
80:                } // line()
000C04  78074F     MOV [--W15], W14
000C06  BE064F     MOV.D [--W15], W12
000C08  BE054F     MOV.D [--W15], W10
000C0A  BE044F     MOV.D [--W15], W8
000C0C  B100AF     SUB #0xA, W15
000C0E  060000     RETURN
81:                
82:                void rectangle(int x1, int y1, int x2, int y2, int color){
000C10  BE9F88     MOV.D W8, [W15++]
000C12  BE9F8A     MOV.D W10, [W15++]
000C14  781F8C     MOV W12, [W15++]
000C16  780480     MOV W0, W9
000C18  780401     MOV W1, W8
000C1A  780502     MOV W2, W10
000C1C  780603     MOV W3, W12
000C1E  780584     MOV W4, W11
83:                    line(x1,y1,x1,y2,color);
000C20  780109     MOV W9, W2
000C22  780088     MOV W8, W1
000C24  780009     MOV W9, W0
000C26  07FF89     RCALL line
84:                    line(x2,y1,x2,y2,color);
000C28  78020B     MOV W11, W4
000C2A  78018C     MOV W12, W3
000C2C  78010A     MOV W10, W2
000C2E  780088     MOV W8, W1
000C30  78000A     MOV W10, W0
000C32  07FF83     RCALL line
85:                    line(x1,y1,x2,y1,color);
000C34  78020B     MOV W11, W4
000C36  780188     MOV W8, W3
000C38  78010A     MOV W10, W2
000C3A  780088     MOV W8, W1
000C3C  780009     MOV W9, W0
000C3E  07FF7D     RCALL line
86:                    line(x1,y2,x2,y2,color);
000C40  78020B     MOV W11, W4
000C42  78018C     MOV W12, W3
000C44  78010A     MOV W10, W2
000C46  78008C     MOV W12, W1
000C48  780009     MOV W9, W0
000C4A  07FF77     RCALL line
87:                }//rectangle()
000C4C  78064F     MOV [--W15], W12
000C4E  BE054F     MOV.D [--W15], W10
000C50  BE044F     MOV.D [--W15], W8
000C52  060000     RETURN
88:                
89:                /*  algorthme mid-point
90:                 * REF: http://www.hhhprogram.com/2013/05/draw-elipse-midpoint-elipse-algorithm.html
91:                 */
92:                void ellipse (int xc, int yc, long rx, long ry, int color){
000C54  B0036F     ADD #0x36, W15
000C56  BE9F88     MOV.D W8, [W15++]
000C58  BE9F8A     MOV.D W10, [W15++]
000C5A  BE9F8C     MOV.D W12, [W15++]
000C5C  781F8E     MOV W14, [W15++]
000C5E  9FAF90     MOV W0, [W15-46]
000C60  9FAFE1     MOV W1, [W15-36]
000C62  BE0504     MOV.D W4, W10
000C64  780706     MOV W6, W14
000CE0  9FA7F2     MOV W2, [W15-50]
000CE2  9FAF83     MOV W3, [W15-48]
000CEE  97AA9F     MOV [W15-46], W5
000CF0  E90285     DEC W5, W5
000CF2  9FA7C5     MOV W5, [W15-56]
000CF4  97AB1F     MOV [W15-46], W6
000CF6  E80306     INC W6, W6
000CF8  9FA7B6     MOV W6, [W15-58]
000CFA  9F9FFA     MOV W10, [W15-66]
000CFC  9FA78B     MOV W11, [W15-64]
000D06  97B47F     MOV [W15-18], W8
000D08  97A0CF     MOV [W15-56], W1
000D0A  408088     ADD W1, W8, W1
000D0C  9FB791     MOV W1, [W15-30]
000D1A  97A1BF     MOV [W15-58], W3
000D1C  518408     SUB W3, W8, W8
000D46  97A07F     MOV [W15-50], W0
000D48  97A88F     MOV [W15-48], W1
000D4A  40030C     ADD W0, W12, W6
000D4C  48838D     ADDC W1, W13, W7
000D7C  97A47F     MOV [W15-50], W8
000D7E  97AC8F     MOV [W15-48], W9
000D80  44030C     ADD W8, W12, W6
000D82  4C838D     ADDC W9, W13, W7
000DA0  97B37F     MOV [W15-18], W6
000DA2  97BB8F     MOV [W15-16], W7
000DA4  530061     SUB W6, #0x1, W0
000DA6  5B80E0     SUBB W7, #0x0, W1
000E50  97AA4F     MOV [W15-40], W4
000E52  97AADF     MOV [W15-38], W5
000E54  120260     SUBR W4, #0x0, W4
000E56  1A82E0     SUBBR W5, #0x0, W5
000E58  9FB794     MOV W4, [W15-30]
000E5A  9FB7A5     MOV W5, [W15-28]
000E5C  97AADF     MOV [W15-38], W5
000E5E  97B47F     MOV [W15-18], W8
000E60  B9AB08     MUL.SS W5, W8, W6
000E62  97BC8F     MOV [W15-16], W9
000E64  97A84F     MOV [W15-40], W0
000E66  B9CA00     MUL.SS W9, W0, W4
000E68  420206     ADD W4, W6, W4
000E6A  97A9CF     MOV [W15-40], W3
000E6C  97B15F     MOV [W15-22], W2
000E6E  B81902     MUL.UU W3, W2, W2
000E70  9FB7B2     MOV W2, [W15-26]
000E72  9FB7C3     MOV W3, [W15-24]
000E74  420183     ADD W4, W3, W3
000E76  9FB7C3     MOV W3, [W15-24]
000E78  97B23F     MOV [W15-26], W4
000E7A  97B2CF     MOV [W15-24], W5
000E7C  9FB7D4     MOV W4, [W15-22]
000E7E  9FB7E5     MOV W5, [W15-20]
000E88  97ABEF     MOV [W15-36], W7
000E8A  53858C     SUB W7, W12, W11
000E98  97A8EF     MOV [W15-36], W1
000E9A  40848C     ADD W1, W12, W9
000EC0  560261     SUB W12, #0x1, W4
000EC2  5E82E0     SUBB W13, #0x0, W5
000EDE  560261     SUB W12, #0x1, W4
000EE0  5E82E0     SUBB W13, #0x0, W5
93:                          long  x=0,y=ry;
94:                          long  p=(ry*ry)-(rx*rx*ry)+((rx*rx)/4);
000C66  B99A02     MUL.SS W3, W2, W4
000C68  420204     ADD W4, W4, W4
000C6A  B81002     MUL.UU W2, W2, W0
000C6C  9FAFA0     MOV W0, [W15-44]
000C6E  9FAFB1     MOV W1, [W15-42]
000C70  420081     ADD W4, W1, W1
000C72  9FAFB1     MOV W1, [W15-42]
000C74  97A92F     MOV [W15-44], W2
000C76  97A9BF     MOV [W15-42], W3
000C78  550202     SUB W10, W2, W4
000C7A  5D8283     SUBB W11, W3, W5
000C7C  B9AB0A     MUL.SS W5, W10, W6
000C7E  B9D804     MUL.SS W11, W4, W0
000C80  400306     ADD W0, W6, W6
000C82  B8220A     MUL.UU W4, W10, W4
000C84  430285     ADD W6, W5, W5
000C86  BE0302     MOV.D W2, W6
000C88  510FE0     SUB W2, #0x0, [W15]
000C8A  598FE0     SUBB W3, #0x0, [W15]
000C8C  3D0002     BRA GE, 0xC92
000C8E  410363     ADD W2, #0x3, W6
000C90  4983E0     ADDC W3, #0x0, W7
000C92  DD39CE     SL W7, #14, W3
000C94  DE3342     LSR W6, #2, W6
000C96  718306     IOR W3, W6, W6
000C98  DEBBC2     ASR W7, #2, W7
000C9A  430404     ADD W6, W4, W8
000C9C  4B8485     ADDC W7, W5, W9
000C9E  9FB7B8     MOV W8, [W15-26]
000CA0  9FB7C9     MOV W9, [W15-24]
95:                          while((2*x*ry*ry)<(2*y*rx*rx)){
000CA2  B9DA0A     MUL.SS W11, W10, W4
000CA4  420204     ADD W4, W4, W4
000CA6  B8500A     MUL.UU W10, W10, W0
000CA8  9FA7D0     MOV W0, [W15-54]
000CAA  9FA7E1     MOV W1, [W15-52]
000CAC  420081     ADD W4, W1, W1
000CAE  9FA7E1     MOV W1, [W15-52]
000CB0  97A15F     MOV [W15-54], W2
000CB2  97A1EF     MOV [W15-52], W3
000CB4  410102     ADD W2, W2, W2
000CB6  498183     ADDC W3, W3, W3
000CB8  9FA792     MOV W2, [W15-62]
000CBA  9FA7A3     MOV W3, [W15-60]
000CBC  97AA2F     MOV [W15-44], W4
000CBE  97AABF     MOV [W15-42], W5
000CC0  420204     ADD W4, W4, W4
000CC2  4A8285     ADDC W5, W5, W5
000CC4  9FB7D4     MOV W4, [W15-22]
000CC6  9FB7E5     MOV W5, [W15-20]
000CE4  200014     MOV #0x1, W4
000CE6  200005     MOV #0x0, W5
000CE8  9FB7F4     MOV W4, [W15-18]
000CEA  9FBF85     MOV W5, [W15-16]
000CEC  B86660     MUL.UU W12, #0, W12
000CFE  370050     BRA 0xDA0
000DA8  97B3DF     MOV [W15-22], W7
000DAA  B9DA07     MUL.SS W11, W7, W4
000DAC  97B46F     MOV [W15-20], W8
000DAE  B9C30A     MUL.SS W8, W10, W6
000DB0  430304     ADD W6, W4, W6
000DB2  97B4DF     MOV [W15-22], W9
000DB4  B85209     MUL.UU W10, W9, W4
000DB6  430285     ADD W6, W5, W5
000DB8  520F8C     SUB W4, W12, [W15]
000DBA  5A8F8D     SUBB W5, W13, [W15]
000DBC  3CFFA1     BRA GT, 0xD00
000DBE  BE010A     MOV.D W10, W2
000DC0  9FB79A     MOV W10, [W15-30]
000DC2  9FB7AB     MOV W11, [W15-28]
000DC4  9FAFF0     MOV W0, [W15-34]
000DC6  9FB781     MOV W1, [W15-32]
000DC8  979D7F     MOV [W15-66], W10
000DCA  97A58F     MOV [W15-64], W11
000DCC  BE0600     MOV.D W0, W12
96:                               plot(xc+x,yc-y,color);
000D00  97A86F     MOV [W15-36], W0
000D02  50000A     SUB W0, W10, W0
000D04  9FAFF0     MOV W0, [W15-34]
000D0E  78010E     MOV W14, W2
000D10  780080     MOV W0, W1
000D12  97B01F     MOV [W15-30], W0
000D14  07FEE6     RCALL plot
97:                               plot(xc-x,yc+y,color);
000D16  97A96F     MOV [W15-36], W2
000D18  450482     ADD W10, W2, W9
000D1E  78010E     MOV W14, W2
000D20  BE0008     MOV.D W8, W0
000D22  07FEDF     RCALL plot
98:                               plot(xc+x,yc+y,color);
000D24  78010E     MOV W14, W2
000D26  780089     MOV W9, W1
000D28  97B01F     MOV [W15-30], W0
000D2A  07FEDB     RCALL plot
99:                               plot(xc-x,yc-y,color);
000D2C  78010E     MOV W14, W2
000D2E  97A8FF     MOV [W15-34], W1
000D30  780008     MOV W8, W0
000D32  07FED7     RCALL plot
100:                              if(p<0){
000D34  97B23F     MOV [W15-26], W4
000D36  97B2CF     MOV [W15-24], W5
000D38  520FE0     SUB W4, #0x0, [W15]
000D3A  5A8FE0     SUBB W5, #0x0, [W15]
000D3C  3D000D     BRA GE, 0xD58
101:                                  x=x+1;
102:                                  p=p+(2*ry*ry*x)+(ry*ry);
000D3E  97A45F     MOV [W15-54], W8
000D40  97A4EF     MOV [W15-52], W9
000D42  440204     ADD W8, W4, W4
000D44  4C8285     ADDC W9, W5, W5
000D4E  420106     ADD W4, W6, W2
000D50  4A8187     ADDC W5, W7, W3
000D52  9FB7B2     MOV W2, [W15-26]
000D54  9FB7C3     MOV W3, [W15-24]
000D56  37001A     BRA 0xD8C
103:                              }else {
104:                                  x=x+1;
105:                                  y=y-1;
000D58  550561     SUB W10, #0x1, W10
000D5A  5D85E0     SUBB W11, #0x0, W11
106:                                  p=p+(2*ry*ry*x+ry*ry)-(2*rx*rx*y);
000CC8  2FFFE4     MOV #0xFFFE, W4
000CCA  97AB3F     MOV [W15-42], W6
000CCC  B9B204     MUL.SS W6, W4, W4
000CCE  97ABAF     MOV [W15-44], W7
000CD0  520207     SUB W4, W7, W4
000CD2  2FFFE5     MOV #0xFFFE, W5
000CD4  97ACAF     MOV [W15-44], W9
000CD6  B84C05     MUL.UU W9, W5, W8
000CD8  9FAFC8     MOV W8, [W15-40]
000CDA  9FAFD9     MOV W9, [W15-38]
000CDC  420489     ADD W4, W9, W9
000CDE  9FAFD9     MOV W9, [W15-38]
000D5C  97B23F     MOV [W15-26], W4
000D5E  97B2CF     MOV [W15-24], W5
000D60  97A45F     MOV [W15-54], W8
000D62  97A4EF     MOV [W15-52], W9
000D64  440304     ADD W8, W4, W6
000D66  4C8385     ADDC W9, W5, W7
000D68  97ACCF     MOV [W15-40], W9
000D6A  B9DA09     MUL.SS W11, W9, W4
000D6C  97A95F     MOV [W15-38], W2
000D6E  B9900A     MUL.SS W2, W10, W0
000D70  400004     ADD W0, W4, W0
000D72  97A9CF     MOV [W15-40], W3
000D74  B85203     MUL.UU W10, W3, W4
000D76  400285     ADD W0, W5, W5
000D78  420206     ADD W4, W6, W4
000D7A  4A8287     ADDC W5, W7, W5
000D84  420006     ADD W4, W6, W0
000D86  4A8087     ADDC W5, W7, W1
000D88  9FB7B0     MOV W0, [W15-26]
000D8A  9FB7C1     MOV W1, [W15-24]
000D8C  97A17F     MOV [W15-50], W2
000D8E  97A98F     MOV [W15-48], W3
000D90  41060C     ADD W2, W12, W12
000D92  49868D     ADDC W3, W13, W13
000D94  97B27F     MOV [W15-18], W4
000D96  97BA8F     MOV [W15-16], W5
000D98  420261     ADD W4, #0x1, W4
000D9A  4A82E0     ADDC W5, #0x0, W5
000D9C  9FB7F4     MOV W4, [W15-18]
000D9E  9FBF85     MOV W5, [W15-16]
107:                              }
108:                         }
109:                         p=((float)x+0.5)*((float)x+0.5)*ry*ry+(y-1)*(y-1)*rx*rx-rx*rx*ry*ry;
000DD4  BE000A     MOV.D W10, W0
000DD6  07FAEE     RCALL 0x3B4
000DD8  BE0400     MOV.D W0, W8
000DDA  97B31F     MOV [W15-30], W6
000DDC  97B3AF     MOV [W15-28], W7
000DDE  530361     SUB W6, #0x1, W6
000DE0  5B83E0     SUBB W7, #0x0, W7
000DE2  9FB7F6     MOV W6, [W15-18]
000DE4  9FBF87     MOV W7, [W15-16]
000DE6  BE000C     MOV.D W12, W0
000DE8  07FAE5     RCALL 0x3B4
000DEA  200002     MOV #0x0, W2
000DEC  23F003     MOV #0x3F00, W3
000DEE  07FA64     RCALL 0x2B8
000DF0  BE0100     MOV.D W0, W2
000DF2  07FB36     RCALL 0x460
000DF4  BE0108     MOV.D W8, W2
000DF6  07FB34     RCALL 0x460
000DF8  BE0100     MOV.D W0, W2
000DFA  BE0008     MOV.D W8, W0
000DFC  07FB31     RCALL 0x460
000DFE  BE0400     MOV.D W0, W8
000E00  97BB8F     MOV [W15-16], W7
000E02  97B07F     MOV [W15-18], W0
000E04  B9BA00     MUL.SS W7, W0, W4
000E06  420204     ADD W4, W4, W4
000E08  97B0FF     MOV [W15-18], W1
000E0A  9FB7D1     MOV W1, [W15-22]
000E0C  780101     MOV W1, W2
000E0E  B81002     MUL.UU W2, W2, W0
000E10  420081     ADD W4, W1, W1
000E12  97A9AF     MOV [W15-44], W3
000E14  B98B03     MUL.SS W1, W3, W6
000E16  97A93F     MOV [W15-42], W2
000E18  B99200     MUL.SS W2, W0, W4
000E1A  420206     ADD W4, W6, W4
000E1C  97AD2F     MOV [W15-44], W10
000E1E  B8000A     MUL.UU W0, W10, W0
000E20  420081     ADD W4, W1, W1
000E22  07FAC8     RCALL 0x3B4
000E24  BE0100     MOV.D W0, W2
000E26  BE0008     MOV.D W8, W0
000E28  07FA47     RCALL 0x2B8
000E2A  BE0400     MOV.D W0, W8
000E2C  97A9BF     MOV [W15-42], W3
000E2E  97A25F     MOV [W15-54], W4
000E30  B99B04     MUL.SS W3, W4, W6
000E32  97A06F     MOV [W15-52], W0
000E34  97A8AF     MOV [W15-44], W1
000E36  B98201     MUL.SS W0, W1, W4
000E38  420206     ADD W4, W6, W4
000E3A  97A15F     MOV [W15-54], W2
000E3C  B85002     MUL.UU W10, W2, W0
000E3E  420081     ADD W4, W1, W1
000E40  07FAB9     RCALL 0x3B4
000E42  BE0100     MOV.D W0, W2
000E44  BE0008     MOV.D W8, W0
000E46  07FA37     RCALL 0x2B6
000E48  07FA94     RCALL 0x372
000E4A  BE0500     MOV.D W0, W10
000E4C  97B61F     MOV [W15-30], W12
000E4E  97B6AF     MOV [W15-28], W13
110:                         while(y>=0){
000DCE  510FE0     SUB W2, #0x0, [W15]
000DD0  598FE0     SUBB W3, #0x0, [W15]
000DD2  3500B8     BRA LT, 0xF44
000F3E  520FE0     SUB W4, #0x0, [W15]
000F40  5A8FE0     SUBB W5, #0x0, [W15]
000F42  3DFFA2     BRA GE, 0xE88
111:                              plot(xc+x,yc-y,color);
000E8C  97AC7F     MOV [W15-34], W8
000E8E  97A81F     MOV [W15-46], W0
000E90  440500     ADD W8, W0, W10
000E92  78010E     MOV W14, W2
000E94  BE000A     MOV.D W10, W0
000E96  07FE25     RCALL plot
112:                              plot(xc-x,yc+y,color);
000E9C  97A91F     MOV [W15-46], W2
000E9E  510408     SUB W2, W8, W8
000EA0  78010E     MOV W14, W2
000EA2  BE0008     MOV.D W8, W0
000EA4  07FE1E     RCALL plot
113:                              plot(xc+x,yc+y,color);
000EA6  78010E     MOV W14, W2
000EA8  780089     MOV W9, W1
000EAA  78000A     MOV W10, W0
000EAC  07FE1A     RCALL plot
114:                              plot(xc-x,yc-y,color);
000EAE  78010E     MOV W14, W2
000EB0  78008B     MOV W11, W1
000EB2  780008     MOV W8, W0
000EB4  07FE16     RCALL plot
115:                              if(p>0){
000EB6  97B27F     MOV [W15-18], W4
000EB8  97BA8F     MOV [W15-16], W5
000EBA  520FE0     SUB W4, #0x0, [W15]
000EBC  5A8FE0     SUBB W5, #0x0, [W15]
000EBE  34000F     BRA LE, 0xEDE
116:                                  y=y-1;
117:                                  p=p-(2*rx*rx*y)+(rx*rx);
000EC4  97B47F     MOV [W15-18], W8
000EC6  97BC8F     MOV [W15-16], W9
000EC8  97A82F     MOV [W15-44], W0
000ECA  97A8BF     MOV [W15-42], W1
000ECC  400308     ADD W0, W8, W6
000ECE  488389     ADDC W1, W9, W7
000ED0  97B15F     MOV [W15-22], W2
000ED2  97B1EF     MOV [W15-20], W3
000ED4  430102     ADD W6, W2, W2
000ED6  4B8183     ADDC W7, W3, W3
000ED8  9FB7F2     MOV W2, [W15-18]
000EDA  9FBF83     MOV W3, [W15-16]
000EDC  370020     BRA 0xF1E
118:                              }else{
119:                                  y=y-1;
120:                                  x=x+1;
000EE2  97AB7F     MOV [W15-34], W6
000EE4  97B38F     MOV [W15-32], W7
000EE6  430361     ADD W6, #0x1, W6
000EE8  4B83E0     ADDC W7, #0x0, W7
000EEA  9FAFF6     MOV W6, [W15-34]
000EEC  9FB787     MOV W7, [W15-32]
121:                                  p=p+(2*ry*ry*x)-(2*rx*rx*y)-(rx*rx);
000E80  97A29F     MOV [W15-62], W5
000E82  9FAFC5     MOV W5, [W15-40]
000E84  9FB7FA     MOV W10, [W15-18]
000E86  9FBF8B     MOV W11, [W15-16]
000EEE  97B47F     MOV [W15-18], W8
000EF0  97BC8F     MOV [W15-16], W9
000EF2  97A82F     MOV [W15-44], W0
000EF4  97A8BF     MOV [W15-42], W1
000EF6  540100     SUB W8, W0, W2
000EF8  5C8181     SUBB W9, W1, W3
000EFA  97A3AF     MOV [W15-60], W7
000EFC  B9B806     MUL.SS W7, W6, W0
000EFE  97B40F     MOV [W15-32], W8
000F00  97A49F     MOV [W15-62], W9
000F02  B9C309     MUL.SS W8, W9, W6
000F04  430000     ADD W6, W0, W0
000F06  97A8CF     MOV [W15-40], W1
000F08  97AC7F     MOV [W15-34], W8
000F0A  B80B08     MUL.UU W1, W8, W6
000F0C  400387     ADD W0, W7, W7
000F0E  430302     ADD W6, W2, W6
000F10  4B8383     ADDC W7, W3, W7
000F12  97B03F     MOV [W15-26], W0
000F14  97B0CF     MOV [W15-24], W1
000F16  430000     ADD W6, W0, W0
000F18  4B8081     ADDC W7, W1, W1
000F1A  9FB7F0     MOV W0, [W15-18]
000F1C  9FBF81     MOV W1, [W15-16]
000F1E  560661     SUB W12, #0x1, W12
000F20  5E86E0     SUBB W13, #0x0, W13
000F22  97B15F     MOV [W15-22], W2
000F24  97B1EF     MOV [W15-20], W3
000F26  97B31F     MOV [W15-30], W6
000F28  97B3AF     MOV [W15-28], W7
000F2A  430102     ADD W6, W2, W2
000F2C  4B8183     ADDC W7, W3, W3
000F2E  9FB7D2     MOV W2, [W15-22]
000F30  9FB7E3     MOV W3, [W15-20]
000F32  97B43F     MOV [W15-26], W8
000F34  97B4CF     MOV [W15-24], W9
000F36  430408     ADD W6, W8, W8
000F38  4B8489     ADDC W7, W9, W9
000F3A  9FB7B8     MOV W8, [W15-26]
000F3C  9FB7C9     MOV W9, [W15-24]
122:                              }
123:                         }
124:               }//ellipse()
000F44  78074F     MOV [--W15], W14
000F46  BE064F     MOV.D [--W15], W12
000F48  BE054F     MOV.D [--W15], W10
000F4A  BE044F     MOV.D [--W15], W8
000F4C  B1036F     SUB #0x36, W15
000F4E  060000     RETURN
125:               
126:               /*
127:                * points[]={x1,y1,x2,y2,x3,y3,...}
128:                * vertices est le nombre de points
129:                */
130:               void polygon(int points[], int vertices, int color){
000F50  BE9F88     MOV.D W8, [W15++]
000F52  BE9F8A     MOV.D W10, [W15++]
000F54  781F8C     MOV W12, [W15++]
000F56  780600     MOV W0, W12
000F58  780582     MOV W2, W11
131:                   int i;
132:                   for(i=0;i<(2*vertices-2);i+=2){
000F5A  E90501     DEC W1, W10
000F5C  45050A     ADD W10, W10, W10
000F5E  EB0480     CLR W9
000F60  550F89     SUB W10, W9, [W15]
000F62  34000B     BRA LE, 0xF7A
000F64  78040C     MOV W12, W8
000F72  E88489     INC2 W9, W9
000F74  440464     ADD W8, #0x4, W8
000F76  550F89     SUB W10, W9, [W15]
000F78  3CFFF6     BRA GT, 0xF66
133:                       line(points[i],points[i+1],points[i+2],points[i+3],color);
000F66  900128     MOV [W8+4], W2
000F68  900098     MOV [W8+2], W1
000F6A  78020B     MOV W11, W4
000F6C  9001B8     MOV [W8+6], W3
000F6E  780018     MOV [W8], W0
000F70  07FDE4     RCALL line
134:                   }
135:                   line(points[0],points[1],points[i],points[i+1],color);
000F7A  E80289     INC W9, W5
000F7C  428285     ADD W5, W5, W5
000F7E  448489     ADD W9, W9, W9
000F80  90009C     MOV [W12+2], W1
000F82  78020B     MOV W11, W4
000F84  7A81EC     MOV [W12+W5], W3
000F86  7C816C     MOV [W12+W9], W2
000F88  78001C     MOV [W12], W0
000F8A  07FDD7     RCALL line
136:               }//polygon()
000F8C  78064F     MOV [--W15], W12
000F8E  BE054F     MOV.D [--W15], W10
000F90  BE044F     MOV.D [--W15], W8
000F92  060000     RETURN
137:               
138:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NTSC_FRAMES_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE+40)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAMES_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE+45)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8 // flag screen in retrace phase
60:                
61:                unsigned frames_per_second;
62:                static unsigned int frame_line_cntr=0; // count line in video frame
63:                volatile static unsigned long frame_cntr=0; // number of frame since reset
64:                volatile static unsigned int flags;
65:                
66:                
67:                char video_buffer[VPIXELS][BYTES_PER_LINE];
68:                int vsync, hsync, video_mode;
69:                
70:                void ntsc_init(){
71:                    VIDPR = NTSC_LINE_PERIOD;  // video timer PRx SFR
0019A8  203F85     MOV #0x3F8, W5
0019AA  880865     MOV W5, PR2
72:                    VSYNCR= NTSC_HPULSE;       // video OCxR  SFR
0019AC  2004B4     MOV #0x4B, W4
0019AE  880C14     MOV W4, OC1R
73:                    VSYNCRS=NTSC_LINE_PERIOD;  // video OCxRS SFR
0019B0  880C05     MOV W5, OC1RS
74:                    VDLYR=NTSC_VIDEO_DELAY;     // video delay OCxR SFR
0019B2  200BE5     MOV #0xBE, W5
0019B4  880CA5     MOV W5, OC4R
75:                    VDLYRS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;  // video delay OCxRS SFR
0019B6  203E05     MOV #0x3E0, W5
0019B8  880C95     MOV W5, OC4RS
76:                    hsync=NTSC_HPULSE;
0019BA  88F674     MOV W4, hsync
77:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
0019BC  203AC4     MOV #0x3AC, W4
0019BE  88F664     MOV W4, vsync
78:                    video_mode=NTSC_MODE;
0019C0  EF3EC8     CLR video_mode
79:                    frames_per_second=NTSC_FRAMES_PER_SECOND;
0019C2  2003C4     MOV #0x3C, W4
0019C4  88F654     MOV W4, frames_per_second
80:                }//f()
0019C6  060000     RETURN
81:                
82:                void pal_init(){
83:                    VIDPR = PAL_LINE_PERIOD;
0019C8  204005     MOV #0x400, W5
0019CA  880865     MOV W5, PR2
84:                    VSYNCR= PAL_HPULSE;
0019CC  2004B4     MOV #0x4B, W4
0019CE  880C14     MOV W4, OC1R
85:                    VSYNCRS=PAL_LINE_PERIOD;
0019D0  880C05     MOV W5, OC1RS
86:                    VDLYR=PAL_VIDEO_DELAY;
0019D2  200C35     MOV #0xC3, W5
0019D4  880CA5     MOV W5, OC4R
87:                    VDLYRS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
0019D6  203E65     MOV #0x3E6, W5
0019D8  880C95     MOV W5, OC4RS
88:                    hsync=PAL_HPULSE;
0019DA  88F674     MOV W4, hsync
89:                    vsync=PAL_LINE_PERIOD-PAL_HPULSE;
0019DC  203B44     MOV #0x3B4, W4
0019DE  88F664     MOV W4, vsync
90:                    video_mode=PAL_MODE;
0019E0  200014     MOV #0x1, W4
0019E2  88F644     MOV W4, video_mode
91:                    frames_per_second=PAL_FRAMES_PER_SECOND;
0019E4  200324     MOV #0x32, W4
0019E6  88F654     MOV W4, frames_per_second
92:                }//f()
0019E8  060000     RETURN
93:                
94:                void  video_init(){ // initialisation sorties NTSC
95:                    VIDTMR.TON=0; // désactivation TIMER2
0019EA  A9E111     BCLR 0x111, #7
96:                    if (P_VIDEO_MODE){
0019EC  801655     MOV PORTB, W5
0019EE  210004     MOV #0x1000, W4
0019F0  628204     AND W5, W4, W4
0019F2  320002     BRA Z, 0x19F8
97:                        ntsc_init();
0019F4  07FFD9     RCALL ntsc_init
0019F6  370001     BRA 0x19FA
98:                    }else{
99:                        pal_init();
0019F8  07FFE7     RCALL pal_init
100:                   }
101:                   //  video sync OC mode
102:                   VSYNCCON.OCM=5; // mode 5, timer 2
0019FA  800C24     MOV OC1CON, W4
0019FC  A00004     BSET W4, #0
0019FE  A11004     BCLR W4, #1
001A00  A02004     BSET W4, #2
001A02  880C24     MOV W4, OC1CON
103:                   //video delay change notification interrupt enable on that pin.
104:                   PIXIE=1;
001A04  A8A062     BSET CNEN2, #5
105:                   // video sync interrupt enabling
106:                   VSYNCIF=0;
001A06  A9E084     BCLR IFS0, #7
107:                   VSYNCIE=1;
001A08  A8E094     BSET IEC0, #7
108:                   // SPIx configuration (pixels output)
109:                   PIXCON1.DISSCK=1;
001A0A  A88243     BSET 0x243, #4
110:                   PIXCON1.MSTEN=1;
001A0C  A8A242     BSET SPI1CON1, #5
111:                   PIXCON1.SPRE=5;
001A0E  801214     MOV SPI1CON1, W4
001A10  A02004     BSET W4, #2
001A12  A13004     BCLR W4, #3
001A14  A04004     BSET W4, #4
001A16  881214     MOV W4, SPI1CON1
112:                   PIXCON1.PPRE=3;
001A18  200030     MOV #0x3, W0
001A1A  B72242     IOR SPI1CON1
113:                   PIXCON2.SPIBEN=1;  // enhanced buffer mode
001A1C  A80244     BSET SPI1CON2, #0
114:                   PIXSTAT.SPIEN=1;
001A1E  A8E241     BSET 0x241, #7
115:                   VIDTMR.TON=1;
001A20  A8E111     BSET 0x111, #7
116:               }//horz_sync_init()
001A22  060000     RETURN
117:               
118:               void  wait_n_frame(unsigned n){
119:               unsigned long f0;
120:                   f0=frame_cntr+n;
001A24  80F6A4     MOV frame_cntr, W4
001A26  80F6B5     MOV 0x1ED6, W5
001A28  420000     ADD W4, W0, W0
001A2A  4A80E0     ADDC W5, #0x0, W1
121:                   while (frame_cntr<f0);
001A2C  80F6A4     MOV frame_cntr, W4
001A2E  80F6B5     MOV 0x1ED6, W5
001A30  500F84     SUB W0, W4, [W15]
001A32  588F85     SUBB W1, W5, [W15]
001A34  3EFFFB     BRA GTU, 0x1A2C
122:               }//f()
001A36  060000     RETURN
123:               
124:               
125:               
126:               
127:               // video sync signal generation
128:               void __attribute__((interrupt,no_auto_psv,shadow)) _VSYNC_ISR(void){
001A38  FEA000     PUSH.S
001A3A  BE9F84     MOV.D W4, [W15++]
129:                   frame_line_cntr++;
001A3C  80F684     MOV frame_line_cntr, W4
001A3E  E80204     INC W4, W4
001A40  88F684     MOV W4, frame_line_cntr
130:                   switch (frame_line_cntr){
001A42  200375     MOV #0x37, W5
001A44  520F85     SUB W4, W5, [W15]
001A46  320034     BRA Z, 0x1AB0
001A48  3E0007     BRA GTU, 0x1A58
001A4A  520FE4     SUB W4, #0x4, [W15]
001A4C  32001C     BRA Z, 0x1A86
001A4E  520FFE     SUB W4, #0x1E, [W15]
001A50  320022     BRA Z, 0x1A96
001A52  520FE1     SUB W4, #0x1, [W15]
001A54  3A004F     BRA NZ, 0x1AF4
001A56  37000F     BRA 0x1A76
001A58  201075     MOV #0x107, W5
001A5A  520F85     SUB W4, W5, [W15]
001A5C  320036     BRA Z, 0x1ACA
001A5E  3E0004     BRA GTU, 0x1A68
001A60  5282F1     SUB W5, #0x11, W5
001A62  520F85     SUB W4, W5, [W15]
001A64  3A0047     BRA NZ, 0x1AF4
001A66  37001E     BRA 0x1AA4
001A68  2010F5     MOV #0x10F, W5
001A6A  520F85     SUB W4, W5, [W15]
001A6C  320028     BRA Z, 0x1ABE
001A6E  201395     MOV #0x139, W5
001A70  520F85     SUB W4, W5, [W15]
001A72  3A0040     BRA NZ, 0x1AF4
001A74  370035     BRA 0x1AE0
131:                       case 1:
132:                           VSYNCR=vsync;
001A76  F81ECC     PUSH vsync
001A78  F90182     POP OC1R
133:                           VDLYCON.OCM=0;
001A7A  800CB4     MOV OC4CON, W4
001A7C  A10004     BCLR W4, #0
001A7E  A11004     BCLR W4, #1
001A80  A12004     BCLR W4, #2
001A82  880CB4     MOV W4, OC4CON
134:                           break;
001A84  370037     BRA 0x1AF4
135:                       case 4:
136:                           VDLYCON.OCM=5;
001A86  800CB4     MOV OC4CON, W4
001A88  A00004     BSET W4, #0
001A8A  A11004     BCLR W4, #1
001A8C  A02004     BSET W4, #2
001A8E  880CB4     MOV W4, OC4CON
137:                           VSYNCR=hsync;
001A90  F81ECE     PUSH hsync
001A92  F90182     POP OC1R
138:                           break;
001A94  37002F     BRA 0x1AF4
139:                       case NTSC_FIRST_VISIBLE:
140:                           if (video_mode==NTSC_MODE){
001A96  80F644     MOV video_mode, W4
001A98  520FE0     SUB W4, #0x0, [W15]
001A9A  3A002C     BRA NZ, 0x1AF4
141:                               VDLYIF=0;
001A9C  A96086     BCLR IFS1, #3
142:                               VDLYIE=1;
001A9E  A86096     BSET IEC1, #3
143:                               flags &= ~F_RETRACE;
001AA0  A97ED2     BCLR flags, #3
001AA2  370028     BRA 0x1AF4
144:                           }
145:                           break;
146:                       case NTSC_LAST_VISIBLE:
147:                           if (video_mode==NTSC_MODE){
001AA4  80F644     MOV video_mode, W4
001AA6  520FE0     SUB W4, #0x0, [W15]
001AA8  3A0025     BRA NZ, 0x1AF4
148:                               VDLYIE=0;
001AAA  A96096     BCLR IEC1, #3
149:                               flags |= F_RETRACE;
001AAC  A87ED2     BSET flags, #3
001AAE  370022     BRA 0x1AF4
150:                           }
151:                           break;
152:                       case PAL_FIRST_VISIBLE:
153:                           if (video_mode==PAL_MODE){
001AB0  80F644     MOV video_mode, W4
001AB2  520FE1     SUB W4, #0x1, [W15]
001AB4  3A001F     BRA NZ, 0x1AF4
154:                               VDLYIF=0;
001AB6  A96086     BCLR IFS1, #3
155:                               VDLYIE=1;
001AB8  A86096     BSET IEC1, #3
156:                               flags &= ~F_RETRACE;
001ABA  A97ED2     BCLR flags, #3
001ABC  37001B     BRA 0x1AF4
157:                           }
158:                           break;
159:                       case PAL_LAST_VISIBLE:
160:                           if (video_mode==PAL_MODE){
001ABE  80F644     MOV video_mode, W4
001AC0  520FE1     SUB W4, #0x1, [W15]
001AC2  3A0018     BRA NZ, 0x1AF4
161:                               VDLYIE=0;
001AC4  A96096     BCLR IEC1, #3
162:                               flags |= F_RETRACE;
001AC6  A87ED2     BSET flags, #3
001AC8  370015     BRA 0x1AF4
163:                           }
164:                           break;
165:                       case NTSC_LINES_PER_FRAME+1:
166:                           if (video_mode==NTSC_MODE){
001ACA  80F644     MOV video_mode, W4
001ACC  520FE0     SUB W4, #0x0, [W15]
001ACE  3A0012     BRA NZ, 0x1AF4
167:                               frame_line_cntr=0;
001AD0  EF3ED0     CLR frame_line_cntr
168:                               frame_cntr++;
001AD2  80F6A4     MOV frame_cntr, W4
001AD4  80F6B5     MOV 0x1ED6, W5
001AD6  420261     ADD W4, #0x1, W4
001AD8  4A82E0     ADDC W5, #0x0, W5
001ADA  88F6A4     MOV W4, frame_cntr
001ADC  88F6B5     MOV W5, 0x1ED6
001ADE  37000A     BRA 0x1AF4
169:                           }
170:                           break;
171:                       case PAL_LINES_PER_FRAME+1:
172:                           if (video_mode==PAL_MODE){
001AE0  80F644     MOV video_mode, W4
001AE2  520FE1     SUB W4, #0x1, [W15]
001AE4  3A0007     BRA NZ, 0x1AF4
173:                               frame_line_cntr=0;
001AE6  EF3ED0     CLR frame_line_cntr
174:                               frame_cntr++;
001AE8  80F6A4     MOV frame_cntr, W4
001AEA  80F6B5     MOV 0x1ED6, W5
001AEC  420261     ADD W4, #0x1, W4
001AEE  4A82E0     ADDC W5, #0x0, W5
001AF0  88F6A4     MOV W4, frame_cntr
001AF2  88F6B5     MOV W5, 0x1ED6
175:                           }
176:                           break;
177:                   }//switch
178:                   VSYNCIF=0;
001AF4  A9E084     BCLR IFS0, #7
179:               }// _VSYNC_ISR()
001AF6  BE024F     MOV.D [--W15], W4
001AF8  FE8000     POP.S
001AFA  064000     RETFIE
180:               
181:               void __attribute__((interrupt,no_auto_psv,shadow)) _VIDEO_OUT_ISR(void){
001AFC  FEA000     PUSH.S
001AFE  BE9F84     MOV.D W4, [W15++]
001B00  BE9F86     MOV.D W6, [W15++]
001B16  B9337B     MUL.SU W6, #27, W6
001B18  207FF4     MOV #0x7FF, W4
001B1A  430304     ADD W6, W4, W6
182:                   int y,x;
183:                   if (PIXDLY_INP){
001B02  AB22CB     BTST 0x2CB, #1
001B04  320016     BRA Z, 0x1B32
184:                       if (video_mode==NTSC_MODE){
001B06  80F644     MOV video_mode, W4
001B08  520FE0     SUB W4, #0x0, [W15]
001B0A  3A0003     BRA NZ, 0x1B12
185:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE);
001B0C  80F686     MOV frame_line_cntr, W6
001B0E  53037E     SUB W6, #0x1E, W6
001B10  370002     BRA 0x1B16
186:                       }else{
187:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE);
001B12  80F686     MOV frame_line_cntr, W6
001B14  B10376     SUB #0x37, W6
188:                       }
189:                       for (x=0;x<BYTES_PER_LINE;x++){
001B1C  EB0280     CLR W5
001B26  E80285     INC W5, W5
001B28  528FFB     SUB W5, #0x1B, [W15]
001B2A  3AFFF9     BRA NZ, 0x1B1E
190:                           while (PIXSTAT.SPITBF);
001B1E  AB2240     BTST SPI1STAT, #1
001B20  3AFFFE     BRA NZ, 0x1B1E
191:                           PIXBUF=video_buffer[y][x];
001B22  FB0256     SE [++W6], W4
001B24  881244     MOV W4, SPI1BUF
192:                       }//for
193:                       while (PIXSTAT.SPITBF);
001B2C  AB2240     BTST SPI1STAT, #1
001B2E  3AFFFE     BRA NZ, 0x1B2C
194:                       PIXBUF=0;
001B30  EF2248     CLR SPI1BUF
195:                   }
196:                   VDLYIF=0;
001B32  A96086     BCLR IFS1, #3
197:               }// _VIDEO_OUT_ISR
001B34  BE034F     MOV.D [--W15], W6
001B36  BE024F     MOV.D [--W15], W4
001B38  FE8000     POP.S
001B3A  064000     RETFIE
198:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  216x216 pixels
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include "PICvision.h"
34:                
35:                
36:                void PICvision_init(void) {
37:                    HardwareConfig();
001DD6  07FF68     RCALL HardwareConfig
38:                    timers_init(TICK_FREQ);
001DD8  200640     MOV #0x64, W0
001DDA  07FCF9     RCALL timers_init
39:                    video_init();
001DDC  07FE06     RCALL video_init
40:                    sound_init(1000/TICK_FREQ);
001DDE  2000A0     MOV #0xA, W0
001DE0  07FEB9     RCALL sound_init
41:                }//f()
001DE2  060000     RETURN
42:                
43:                
