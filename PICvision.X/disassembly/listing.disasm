Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-03-28 14:00:32

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/text_console/text_console.c  --------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   text_console.h
21:                 * Author: jacques Deschênes
22:                 * Description: manage text writing in video_buffer
23:                 * Created on 28 février 2014, 10:04
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                #include "text_console.h"
29:                
30:                //static text_coord_t cursor_pos;
31:                
32:                //#define X_OFS  ((HPIXELS-CHAR_PER_LINE*CHAR_WIDTH)/2)  // x offset to cursor from screen edge
33:                //#define Y_OFS  ((VPIXELS-LINE_PER_SCREEN*CHAR_HEIGHT)/2) // y offset to cursor from screen edge
34:                
35:                // boolean flags
36:                #define CUR_SHOW 1  // cursor active
37:                #define CUR_VIS  2  // cursor state visible
38:                #define INV_VID  4  // invert video
39:                
40:                
41:                static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
42:                static unsigned char tab_width=TAB_WIDTH;
43:                static cursor_t cur_shape=CR_UNDER;
44:                static unsigned short flags=0;
45:                
46:                
47:                
48:                void scroll_up(void){
49:                    char *src, *dst;
50:                    dst = (char*)video_buffer;
51:                    src = (char*)video_buffer + CHAR_HEIGHT*BYTES_PER_LINE;
52:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001FAC  215F02     MOV #0x15F0, W2
001FAE  208D81     MOV #0x8D8, W1
001FB0  208000     MOV #0x800, W0
001FB2  07F2D9     RCALL 0x566
53:                    dst= (char*)video_buffer+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*BYTES_PER_LINE;
54:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
001FB4  21DF04     MOV #0x1DF0, W4
001FB6  0900D7     REPEAT #0xD7
001FB8  EB5A00     CLR.B [W4++]
55:                }//scroll_up();
001FBA  060000     RETURN
56:                
57:                void scroll_down(void){
58:                    char *src, *dst;
59:                    src = (char*)video_buffer;
60:                    dst = (char*)video_buffer+CHAR_HEIGHT*BYTES_PER_LINE;
61:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001FBC  215F02     MOV #0x15F0, W2
001FBE  208001     MOV #0x800, W1
001FC0  200D80     MOV #0xD8, W0
001FC2  400001     ADD W0, W1, W0
001FC4  07F2D0     RCALL 0x566
62:                    dst=(char*)video_buffer;
63:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
001FC6  208004     MOV #0x800, W4
001FC8  09006B     REPEAT #0x6B
001FCA  EB1A00     CLR [W4++]
64:                }//scroll_down()
001FCC  060000     RETURN
65:                
66:                
67:                void cursor_right(void){
68:                    cx += CHAR_WIDTH;
001FCE  80FD84     MOV cx, W4
001FD0  420266     ADD W4, #0x6, W4
001FD2  88FD84     MOV W4, cx
69:                    if (cx>(CHAR_PER_LINE*CHAR_WIDTH)){
001FD4  200D25     MOV #0xD2, W5
001FD6  520F85     SUB W4, W5, [W15]
001FD8  36000A     BRA LEU, 0x1FEE
70:                        cx = 0;
001FDA  EF3FB0     CLR cx
71:                        cy += CHAR_HEIGHT;
001FDC  80FD94     MOV cy, W4
001FDE  420268     ADD W4, #0x8, W4
001FE0  88FD94     MOV W4, cy
72:                        if (cy>(LINE_PER_SCREEN*CHAR_HEIGHT)){
001FE2  4282E6     ADD W5, #0x6, W5
001FE4  520F85     SUB W4, W5, [W15]
001FE6  360003     BRA LEU, 0x1FEE
73:                            scroll_up();
001FE8  07FFE1     RCALL scroll_up
74:                            cy -= CHAR_HEIGHT;
001FEA  2FFF80     MOV #0xFFF8, W0
001FEC  B43FB2     ADD cy
75:                        }
76:                    }
77:                } // cursor_right()
001FEE  060000     RETURN
78:                
79:                void cursor_left(void){
80:                    if (cx>=CHAR_WIDTH){
001FF0  80FD84     MOV cx, W4
001FF2  520FE5     SUB W4, #0x5, [W15]
001FF4  360003     BRA LEU, 0x1FFC
81:                        cx -= CHAR_WIDTH;
001FF6  520266     SUB W4, #0x6, W4
001FF8  88FD84     MOV W4, cx
001FFA  370009     BRA 0x200E
82:                    }else{
83:                        cx = CHAR_WIDTH*(CHAR_PER_LINE-1);
001FFC  200CC4     MOV #0xCC, W4
001FFE  88FD84     MOV W4, cx
84:                        if (cy>=CHAR_HEIGHT){
002000  80FD94     MOV cy, W4
002002  520FE7     SUB W4, #0x7, [W15]
002004  360003     BRA LEU, 0x200C
85:                            cy -= CHAR_HEIGHT;
002006  520268     SUB W4, #0x8, W4
002008  88FD94     MOV W4, cy
00200A  370001     BRA 0x200E
86:                        }else{
87:                            scroll_down();
00200C  07FFD7     RCALL scroll_down
88:                        }
89:                    }
90:                }// cursor_left()
00200E  060000     RETURN
91:                
92:                void cursor_up(void){
93:                    if (cy>=CHAR_HEIGHT){
002010  80FD94     MOV cy, W4
002012  520FE7     SUB W4, #0x7, [W15]
002014  360003     BRA LEU, 0x201C
94:                        cy -= CHAR_HEIGHT;
002016  520268     SUB W4, #0x8, W4
002018  88FD94     MOV W4, cy
00201A  370001     BRA 0x201E
95:                    }else{
96:                        scroll_down();
00201C  07FFCF     RCALL scroll_down
97:                    }
98:                }// cursor_up()
00201E  060000     RETURN
99:                
100:               void cursor_down(void){
101:                   if (cy<=(CHAR_HEIGHT*(LINE_PER_SCREEN-2))){
002020  80FD94     MOV cy, W4
002022  200C85     MOV #0xC8, W5
002024  520F85     SUB W4, W5, [W15]
002026  3E0003     BRA GTU, 0x202E
102:                       cy += CHAR_HEIGHT;
002028  420268     ADD W4, #0x8, W4
00202A  88FD94     MOV W4, cy
00202C  370001     BRA 0x2030
103:                   }else{
104:                       scroll_up();
00202E  07FFBE     RCALL scroll_up
105:                   }
106:               }//cursor_down()
002030  060000     RETURN
107:               
108:               void crlf(void){
109:                   cx=0;
002032  EF3FB0     CLR cx
110:                   if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
002034  80FD94     MOV cy, W4
002036  200D05     MOV #0xD0, W5
002038  520F85     SUB W4, W5, [W15]
00203A  3A0002     BRA NZ, 0x2040
111:                       scroll_up();
00203C  07FFB7     RCALL scroll_up
00203E  370002     BRA 0x2044
112:                   }else{
113:                       cy += CHAR_HEIGHT;
002040  420268     ADD W4, #0x8, W4
002042  88FD94     MOV W4, cy
114:                   }
115:               }//crlf()
002044  060000     RETURN
116:               
117:               void put_char(unsigned char c){
002046  4787E6     ADD W15, #0x6, W15
002048  BE9F88     MOV.D W8, [W15++]
00204A  BE9F8A     MOV.D W10, [W15++]
00204C  BE9F8C     MOV.D W12, [W15++]
00204E  781F8E     MOV W14, [W15++]
0020C6  E80389     INC W9, W7
0020C8  B94A7B     MUL.SU W9, #27, W4
0020CA  780284     MOV W4, W5
0020CC  42820D     ADD W5, W13, W4
0020CE  208000     MOV #0x800, W0
0020D0  420200     ADD W4, W0, W4
0020D4  DD3743     SL W6, #3, W14
0020D6  28D4A6     MOV #0x8D4A, W6
0020D8  470306     ADD W14, W6, W6
0020DA  E8068D     INC W13, W13
0020DC  42828D     ADD W5, W13, W5
0020DE  428280     ADD W5, W0, W5
0020E0  448069     ADD W9, #0x9, W0
118:                   register int i,l,r,b,x,y;
119:                   x=cx;
002050  80FD83     MOV cx, W3
120:                   y=cy;
002052  80FD99     MOV cy, W9
121:                   switch (c){
002054  504FE9     SUB.B W0, #0x9, [W15]
002056  320007     BRA Z, 0x2066
002058  504FED     SUB.B W0, #0xD, [W15]
00205A  320003     BRA Z, 0x2062
00205C  504FE8     SUB.B W0, #0x8, [W15]
00205E  3A001B     BRA NZ, 0x2096
002060  370018     BRA 0x2092
122:                       case CR:
123:                           crlf();
002062  07FFE7     RCALL crlf
124:                           break;
002064  37006E     BRA 0x2142
125:                       case TAB:
126:                           cx += (cx%tab_width);
002066  21FBC4     MOV #0x1FBC, W4
002068  784214     MOV.B [W4], W4
00206A  FB8204     ZE W4, W4
00206C  BE9F80     MOV.D W0, [W15++]
00206E  090011     REPEAT #0x11
002070  D88184     DIV.UW W3, W4
002072  780201     MOV W1, W4
002074  BE004F     MOV.D [--W15], W0
002076  420183     ADD W4, W3, W3
002078  88FD83     MOV W3, cx
127:                           if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
00207A  200D14     MOV #0xD1, W4
00207C  518F84     SUB W3, W4, [W15]
00207E  360061     BRA LEU, 0x2142
128:                               cx = 0;
002080  EF3FB0     CLR cx
129:                               if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
002082  E90204     DEC W4, W4
002084  548F84     SUB W9, W4, [W15]
002086  3A0002     BRA NZ, 0x208C
130:                                   scroll_up();
002088  07FF91     RCALL scroll_up
00208A  37005B     BRA 0x2142
131:                               }else{
132:                                   cy += CHAR_HEIGHT;
00208C  4484E8     ADD W9, #0x8, W9
00208E  88FD99     MOV W9, cy
002090  370058     BRA 0x2142
133:                               }
134:                           }
135:                           break;
136:                       case '\b':
137:                           cursor_left();
002092  07FFAE     RCALL cursor_left
138:                           break;
002094  370056     BRA 0x2142
139:                       default:
140:                           if ((c<32) || (c>=(FONT_SIZE+32))) break;
002096  B3CE06     MOV #0xE0, W6
002098  404306     ADD.B W0, W6, W6
00209A  B3C6D4     MOV #0x6D, W4
00209C  534F84     SUB.B W6, W4, [W15]
00209E  3E0051     BRA GTU, 0x2142
141:                           c -=32;
142:                           b=x>>3; // character position in video_buffer
0020A0  DE9EC3     ASR W3, #3, W13
143:                           r=0;
144:                           l=(8-CHAR_WIDTH)-(x&7); // shift inside this byte
0020A2  6181E7     AND W3, #0x7, W3
0020A4  1181E2     SUBR W3, #0x2, W3
145:                           if (l<0){
146:                               r=-l;
0020A6  DE9A4F     ASR W3, #15, W4
0020A8  EA0083     NEG W3, W1
0020AA  608084     AND W1, W4, W1
147:                           }
148:                           for (i=0;i<8;i++){
00213C  538F80     SUB W7, W0, [W15]
00213E  3AFFD1     BRA NZ, 0x20E2
149:                               if (r){
0020E2  508FE0     SUB W1, #0x0, [W15]
0020E4  320018     BRA Z, 0x2116
150:                                   if (flags & INV_VID){
0020AC  80FD62     MOV flags, W2
0020AE  610164     AND W2, #0x4, W2
0020E6  510FE0     SUB W2, #0x0, [W15]
0020E8  32000B     BRA Z, 0x2100
151:                                       video_buffer[y][b] |= (0x3f>>r);
0020B0  2003FA     MOV #0x3F, W10
0020B2  DED601     ASR W10, W1, W12
0020F2  764694     IOR.B W12, [W4], W13
152:                                       video_buffer[y][b] &=~(font6x8[(int)c][i]>>r);
0020EA  784696     MOV.B [W6], W13
0020EC  FB848D     ZE W13, W9
0020EE  DECF01     ASR W9, W1, W14
0020F0  EAC70E     COM.B W14, W14
0020F4  674A0D     AND.B W14, W13, [W4]
153:                                       video_buffer[y][b+1] |= (0x3f<<(8-r));
0020B4  108468     SUBR W1, #0x8, W8
0020B6  DD5588     SL W10, W8, W11
0020FA  75C695     IOR.B W11, [W5], W13
154:                                       video_buffer[y][b+1] &= ~(font6x8[(int)c][i]<<(8-r));
0020F6  DD4C88     SL W9, W8, W9
0020F8  EAC489     COM.B W9, W9
0020FC  64CA8D     AND.B W9, W13, [W5]
0020FE  37001A     BRA 0x2134
155:                                   }else{
156:                                       video_buffer[y][b] &= ~(0x3f>>r);
0020B8  EAC20C     COM.B W12, W4
0020BA  9FF784     MOV.B W4, [W15-16]
002104  97F68F     MOV.B [W15-16], W13
002106  66C714     AND.B W13, [W4], W14
157:                                       video_buffer[y][b] |= font6x8[(int)c][i]>>r;
002100  784716     MOV.B [W6], W14
002102  FB848E     ZE W14, W9
002108  DECE81     ASR W9, W1, W13
00210A  774A0D     IOR.B W14, W13, [W4]
158:                                       video_buffer[y][b+1] &= ~(0x3f<<(8-r));
0020BC  EAC70B     COM.B W11, W14
0020BE  9FEFFE     MOV.B W14, [W15-17]
00210C  97EF7F     MOV.B [W15-17], W14
00210E  674695     AND.B W14, [W5], W13
159:                                       video_buffer[y][b+1] |= font6x8[(int)c][i]<<(8-r);
002110  DD4C88     SL W9, W8, W9
002112  76CA89     IOR.B W13, W9, [W5]
002114  37000F     BRA 0x2134
160:                                   }
161:                                   y++;
162:                               } else{
163:                                   if (flags & INV_VID){
002116  510FE0     SUB W2, #0x0, [W15]
002118  320007     BRA Z, 0x2128
164:                                       video_buffer[y][b] |= (0x3f<<l);
0020C0  DD5503     SL W10, W3, W10
002122  754494     IOR.B W10, [W4], W9
165:                                       video_buffer[y++][b] &=~(font6x8[(int)c][i]<<l);
0020D2  FB8306     ZE W6, W6
00211A  784496     MOV.B [W6], W9
00211C  FB8689     ZE W9, W13
00211E  DD6E83     SL W13, W3, W13
002120  EAC68D     COM.B W13, W13
002124  66CA09     AND.B W13, W9, [W4]
002126  370006     BRA 0x2134
166:                                   }else{
167:                                       video_buffer[y][b] &= ~(0x3f<<l);
0020C2  EAC20A     COM.B W10, W4
0020C4  9FEFE4     MOV.B W4, [W15-18]
002128  97EF6F     MOV.B [W15-18], W14
00212A  674694     AND.B W14, [W4], W13
168:                                       video_buffer[y++][b] |= font6x8[(int)c][i]<<l;
00212C  784716     MOV.B [W6], W14
00212E  FB848E     ZE W14, W9
002130  DD4C83     SL W9, W3, W9
002132  76CA09     IOR.B W13, W9, [W4]
002134  E80387     INC W7, W7
002136  42027B     ADD W4, #0x1B, W4
002138  E80306     INC W6, W6
00213A  4282FB     ADD W5, #0x1B, W5
169:                                   }
170:                               }
171:                           }
172:                           cursor_right();
002140  07FF46     RCALL cursor_right
173:                   }//switch(c)
174:               }//put_char()
002142  78074F     MOV [--W15], W14
002144  BE064F     MOV.D [--W15], W12
002146  BE054F     MOV.D [--W15], W10
002148  BE044F     MOV.D [--W15], W8
00214A  B1006F     SUB #0x6, W15
00214C  060000     RETURN
175:               
176:               void clear_screen(){
177:                   memset(video_buffer,0,HPIXELS/8*VPIXELS);
00214E  208004     MOV #0x800, W4
002150  090B63     REPEAT #0xB63
002152  EB1A00     CLR [W4++]
178:                   cx=0;
002154  EB0200     CLR W4
002156  88FD84     MOV W4, cx
179:                   cy=0;
002158  88FD94     MOV W4, cy
180:               } // clear_screen()
00215A  060000     RETURN
181:               
182:               void print(const char *text){
00215C  781F88     MOV W8, [W15++]
00215E  780400     MOV W0, W8
183:                   while (*text){
002160  784018     MOV.B [W8], W0
002162  504FE0     SUB.B W0, #0x0, [W15]
002164  320004     BRA Z, 0x216E
002168  784058     MOV.B [++W8], W0
00216A  504FE0     SUB.B W0, #0x0, [W15]
00216C  3AFFFC     BRA NZ, 0x2166
184:                       put_char(*text++);
002166  07FF6F     RCALL put_char
185:                   }
186:               }// print()
00216E  78044F     MOV [--W15], W8
002170  060000     RETURN
187:               
188:               void print_hex(unsigned int hex, unsigned char width){
002172  FA000C     LNK #0xC
189:                   char c[12], *d;
190:                   int i;
191:                   c[11]=0;
002174  EB4200     CLR.B W4
002176  9FFFF4     MOV.B W4, [W15-1]
192:                   d= &c[10];
00217A  E9820F     DEC2 W15, W4
193:                   for(i=width;i>=0||hex;i--){
002178  FB8301     ZE W1, W6
00217C  37000C     BRA 0x2196
002194  E90306     DEC W6, W6
002196  530FE0     SUB W6, #0x0, [W15]
002198  3DFFF2     BRA GE, 0x217E
00219A  500FE0     SUB W0, #0x0, [W15]
00219C  3AFFF0     BRA NZ, 0x217E
194:                       *d=(hex%16);
00217E  6042EF     AND.B W0, #0xF, W5
002180  784A05     MOV.B W5, [W4]
195:                       if (*d<10)
002182  52CFE9     SUB.B W5, #0x9, [W15]
002184  3C0003     BRA GT, 0x218C
196:                           *d += '0';
002186  B3C307     MOV #0x30, W7
002188  42CA07     ADD.B W5, W7, [W4]
00218A  370002     BRA 0x2190
197:                       else
198:                           *d += 'A'-10;
00218C  B3C377     MOV #0x37, W7
00218E  42CA07     ADD.B W5, W7, [W4]
199:                       hex /=16;
002190  DE0044     LSR W0, #4, W0
200:                       d--;
002192  E90204     DEC W4, W4
201:                   }
202:                   print(++d);
00219E  E80004     INC W4, W0
0021A0  07FFDD     RCALL print
203:               } // print_hex()
0021A2  FA8000     ULNK
0021A4  060000     RETURN
204:               
205:               void print_int(int number, unsigned short width){ // imprime entier,width inclus le signe
0021A6  FA000E     LNK #0xE
0021EC  538005     SUB W7, W5, W0
0021EE  780207     MOV W7, W4
206:                   int sign=0, i;
0021B2  EB0100     CLR W2
207:                   char str[14], *d;
208:                   str[13]=0;
0021A8  EB4200     CLR.B W4
0021AA  9FFFF4     MOV.B W4, [W15-1]
0021AC  508FED     SUB W1, #0xD, [W15]
0021AE  360001     BRA LEU, 0x21B2
0021B0  2000D1     MOV #0xD, W1
209:                   d=&str[12];
0021C2  E9820F     DEC2 W15, W4
0021DC  E9838F     DEC2 W15, W7
210:                   if (width>13){width=13;}
211:                   if (number<0){
0021B4  500F82     SUB W0, W2, [W15]
0021B6  3D0002     BRA GE, 0x21BC
212:                       sign=1;
0021BA  200012     MOV #0x1, W2
213:                       number = -number;
0021B8  EA0000     NEG W0, W0
214:                   }
215:                   //for (i=--width;i>=0||number;i--){
216:                   i=width;
0021BC  780281     MOV W1, W5
217:                   while (number>0){
0021BE  500FE0     SUB W0, #0x0, [W15]
0021C0  34000D     BRA LE, 0x21DC
0021D6  500FE0     SUB W0, #0x0, [W15]
0021D8  3CFFF6     BRA GT, 0x21C6
0021DA  370001     BRA 0x21DE
218:                      *d--=(number%10)+'0';
0021C4  2000A6     MOV #0xA, W6
0021C6  780381     MOV W1, W7
0021C8  090011     REPEAT #0x11
0021CA  D80006     DIV.SW W0, W6
0021CC  FD0381     EXCH W1, W7
0021CE  B3C303     MOV #0x30, W3
0021D0  43D203     ADD.B W7, W3, [W4--]
0021D2  780384     MOV W4, W7
219:                       number /= 10;
220:                       i--;
0021D4  E90285     DEC W5, W5
221:                   }
222:                   if (i==width){
0021DE  508F85     SUB W1, W5, [W15]
0021E0  3A0003     BRA NZ, 0x21E8
223:                       *d--='0';
0021E2  B3C304     MOV #0x30, W4
0021E4  785384     MOV.B W4, [W7--]
224:                       i--;
0021E6  E90285     DEC W5, W5
225:                   }
226:                   while (i>0){
0021E8  528FE0     SUB W5, #0x0, [W15]
0021EA  340007     BRA LE, 0x21FA
0021F4  520F80     SUB W4, W0, [W15]
0021F6  3AFFFD     BRA NZ, 0x21F2
0021F8  538385     SUB W7, W5, W7
227:                       *d--=' ';
0021F0  B3C206     MOV #0x20, W6
0021F2  785206     MOV.B W6, [W4--]
228:                       i--;
229:                   }
230:                   if (sign){*d='-';}else{*d=' ';}
0021FA  510FE0     SUB W2, #0x0, [W15]
0021FC  320003     BRA Z, 0x2204
0021FE  B3C2D4     MOV #0x2D, W4
002200  784B84     MOV.B W4, [W7]
002202  370002     BRA 0x2208
002204  B3C204     MOV #0x20, W4
002206  784B84     MOV.B W4, [W7]
231:                   print(d);
002208  780007     MOV W7, W0
00220A  07FFA8     RCALL print
232:               }// print_int()
00220C  FA8000     ULNK
00220E  060000     RETURN
233:               
234:               void set_tab_width(unsigned char width){
235:                   tab_width=width;
002210  B7FFBC     MOV.B WREG, tab_width
236:               }// set_tab_width()
002212  060000     RETURN
237:               
238:               void clear_eol(void){
002214  BE9F88     MOV.D W8, [W15++]
002216  BE9F8A     MOV.D W10, [W15++]
239:                   int x,y;
240:                   x=cx;
002218  80FD8A     MOV cx, W10
241:                   y=cy;
00221A  80FD9B     MOV cy, W11
242:                   while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
00221C  200C54     MOV #0xC5, W4
00221E  550F84     SUB W10, W4, [W15]
002220  3E0007     BRA GTU, 0x2230
002224  780484     MOV W4, W9
00222A  80FD84     MOV cx, W4
00222C  520F89     SUB W4, W9, [W15]
00222E  36FFFB     BRA LEU, 0x2226
243:                       put_char(32);
002222  B3C208     MOV #0x20, W8
002226  784008     MOV.B W8, W0
002228  07FF0E     RCALL put_char
244:                   }
245:                   put_char(32);
002230  B3C200     MOV #0x20, W0
002232  07FF09     RCALL put_char
246:                   cx=x;
002234  88FD8A     MOV W10, cx
247:                   cy=y;
002236  88FD9B     MOV W11, cy
248:               }// clear_eol()
002238  BE054F     MOV.D [--W15], W10
00223A  BE044F     MOV.D [--W15], W8
00223C  060000     RETURN
249:               
250:               text_coord_t get_curpos(){
251:                   text_coord_t cpos;
252:                   cpos.x = cx/CHAR_WIDTH;
00223E  80FD85     MOV cx, W5
002240  200064     MOV #0x6, W4
002242  781F80     MOV W0, [W15++]
002244  090011     REPEAT #0x11
002246  D88284     DIV.UW W5, W4
002248  780200     MOV W0, W4
00224A  78004F     MOV [--W15], W0
00224C  780804     MOV W4, [W0]
253:                   cpos.y = cy/CHAR_HEIGHT;
00224E  80FD94     MOV cy, W4
002250  DE2243     LSR W4, #3, W4
002252  980014     MOV W4, [W0+2]
254:                   return cpos;
255:               } // get_cursor_pos()
002254  060000     RETURN
256:               
257:               void set_curpos(unsigned short x, unsigned short y){// {x,y} character coord.
258:                   if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
002256  200224     MOV #0x22, W4
002258  500F84     SUB W0, W4, [W15]
00225A  3E0006     BRA GTU, 0x2268
00225C  508FFA     SUB W1, #0x1A, [W15]
00225E  3E0004     BRA GTU, 0x2268
259:                       return;
260:                   cx=x*CHAR_WIDTH;
002260  B90266     MUL.SU W0, #6, W4
002262  88FD84     MOV W4, cx
261:                   cy=y*CHAR_HEIGHT;
002264  DD08C3     SL W1, #3, W1
002266  88FD91     MOV W1, cy
262:               }//set_curpos()
002268  060000     RETURN
263:               
264:               void invert_char(void){// invert pixels of character at cursor position
00226A  BE9F88     MOV.D W8, [W15++]
002286  E80287     INC W7, W5
002288  B93C7B     MUL.SU W7, #27, W8
00228A  420008     ADD W4, W8, W0
00228C  208004     MOV #0x800, W4
00228E  400204     ADD W0, W4, W4
002290  4383EA     ADD W7, #0xA, W7
265:                   register int i,l,r,b,x,y;
266:                   x=cx;
00226C  80FD81     MOV cx, W1
267:                   y=cy;
00226E  80FD97     MOV cy, W7
268:                   b=x>>3;
002270  DE8A43     ASR W1, #3, W4
269:                   r=0;
270:                   l=(8-CHAR_WIDTH)-(x&7);
002272  6080E7     AND W1, #0x7, W1
002274  1080E2     SUBR W1, #0x2, W1
271:                   if (l<0){
272:                       r=-l;
002276  DE8ACF     ASR W1, #15, W5
002278  EA0301     NEG W1, W6
00227A  630305     AND W6, W5, W6
273:                   }
274:                   for (i=9;i;i--){
0022A6  528F87     SUB W5, W7, [W15]
0022A8  3AFFF4     BRA NZ, 0x2292
275:                       if (r){
002292  530FE0     SUB W6, #0x0, [W15]
002294  320005     BRA Z, 0x22A0
276:                           video_buffer[y][b] ^= (0x3f>>r);
00227C  2003F5     MOV #0x3F, W5
00227E  DEA986     ASR W5, W6, W3
002296  69CA14     XOR.B W3, [W4], [W4]
277:                           video_buffer[y][b+1] ^= (0x3f<<(8-r));
002280  130168     SUBR W6, #0x8, W2
002282  DD2902     SL W5, W2, W2
002298  904014     MOV.B [W4+1], W0
00229A  684002     XOR.B W0, W2, W0
00229C  984210     MOV.B W0, [W4+1]
00229E  370001     BRA 0x22A2
278:                           y++;
279:                       } else{
280:                           video_buffer[y++][b] ^= (0x3f<<l);
002284  DD2881     SL W5, W1, W1
0022A0  68CA14     XOR.B W1, [W4], [W4]
0022A2  E80285     INC W5, W5
0022A4  42027B     ADD W4, #0x1B, W4
281:                       }
282:                   }
283:               }//invert_char()
0022AA  BE044F     MOV.D [--W15], W8
0022AC  060000     RETURN
284:               
285:               static void toggle_underscore(void){
286:                   register int l,r,b,x;
287:                   x=cx;
001F64  80FD84     MOV cx, W4
288:                   b=x>>5;
001F66  DEA2C5     ASR W4, #5, W5
289:                   r=0;
290:                   l=(8-CHAR_WIDTH)-(x&7);
001F68  620267     AND W4, #0x7, W4
001F6A  120262     SUBR W4, #0x2, W4
291:                   if (l<0){
001F6C  3B0014     BRA NN, 0x1F96
292:                       r=-l;
001F6E  EA0304     NEG W4, W6
293:                   }
294:                   if (r){
001F70  320012     BRA Z, 0x1F96
295:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
001F72  80FD90     MOV cy, W0
001F74  400067     ADD W0, #0x7, W0
001F76  208004     MOV #0x800, W4
001F78  B9007B     MUL.SU W0, #27, W0
001F7A  400085     ADD W0, W5, W1
001F7C  420101     ADD W4, W1, W2
001F7E  2003F7     MOV #0x3F, W7
001F80  DEB986     ASR W7, W6, W3
001F82  78C0E4     MOV.B [W4+W1], W1
001F84  68C903     XOR.B W1, W3, [W2]
296:                       video_buffer[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<(8-r));
001F86  E80285     INC W5, W5
001F88  400285     ADD W0, W5, W5
001F8A  420005     ADD W4, W5, W0
001F8C  130368     SUBR W6, #0x8, W6
001F8E  DD3B86     SL W7, W6, W7
001F90  7AC264     MOV.B [W4+W5], W4
001F92  6A4807     XOR.B W4, W7, [W0]
001F94  37000A     BRA 0x1FAA
297:                   } else{
298:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
001F96  80FD90     MOV cy, W0
001F98  400067     ADD W0, #0x7, W0
001F9A  208006     MOV #0x800, W6
001F9C  B9007B     MUL.SU W0, #27, W0
001F9E  428280     ADD W5, W0, W5
001FA0  430385     ADD W6, W5, W7
001FA2  2003F0     MOV #0x3F, W0
001FA4  DD0204     SL W0, W4, W4
001FA6  7AC2E6     MOV.B [W6+W5], W5
001FA8  6ACB84     XOR.B W5, W4, [W7]
299:                   }
300:               }//toggle_underscore()
001FAA  060000     RETURN
301:               
302:               void show_cursor(BOOL show){
0022AE  781F88     MOV W8, [W15++]
303:                   if (show){
0022B0  500FE0     SUB W0, #0x0, [W15]
0022B2  32000B     BRA Z, 0x22CA
304:                       flags |= CUR_SHOW;
0022B4  80FD64     MOV flags, W4
0022B6  A00004     BSET W4, #0
305:                       flags ^= CUR_VIS;
0022B8  A21004     BTG W4, #1
0022BA  88FD64     MOV W4, flags
306:                       if (cur_shape==CR_BLOCK){
0022BC  80FD74     MOV cur_shape, W4
0022BE  520FE1     SUB W4, #0x1, [W15]
0022C0  3A0002     BRA NZ, 0x22C6
307:                           invert_char();
0022C2  07FFD3     RCALL invert_char
0022C4  37000E     BRA 0x22E2
308:                       }else{
309:                           toggle_underscore();
0022C6  07FE4E     RCALL toggle_underscore
0022C8  37000C     BRA 0x22E2
310:                       }
311:                   }else{
312:                       if (flags & CUR_VIS){
0022CA  80FD68     MOV flags, W8
0022CC  640262     AND W8, #0x2, W4
0022CE  320008     BRA Z, 0x22E0
313:                           if (cur_shape==CR_BLOCK){
0022D0  80FD74     MOV cur_shape, W4
0022D2  520FE1     SUB W4, #0x1, [W15]
0022D4  3A0002     BRA NZ, 0x22DA
314:                               invert_char();
0022D6  07FFC9     RCALL invert_char
0022D8  370001     BRA 0x22DC
315:                           }else{
316:                               toggle_underscore();
0022DA  07FE44     RCALL toggle_underscore
317:                           }
318:                           flags &= ~CUR_VIS;
0022DC  A11008     BCLR W8, #1
0022DE  88FD68     MOV W8, flags
319:                       }
320:                       flags &= ~CUR_SHOW;
0022E0  A91FAC     BCLR flags, #0
321:                   }
322:               
323:               }// show_cursor()
0022E2  78044F     MOV [--W15], W8
0022E4  060000     RETURN
324:               
325:               void set_cursor(cursor_t shape){
0022E6  781F88     MOV W8, [W15++]
0022E8  780400     MOV W0, W8
326:                   if (flags & CUR_VIS){
0022EA  AB3FAC     BTST flags, #1
0022EC  320006     BRA Z, 0x22FA
327:                       show_cursor(FALSE);
0022EE  EB0000     CLR W0
0022F0  07FFDE     RCALL show_cursor
328:                       cur_shape=shape;
0022F2  88FD78     MOV W8, cur_shape
329:                       show_cursor(TRUE);
0022F4  200010     MOV #0x1, W0
0022F6  07FFDB     RCALL show_cursor
0022F8  370001     BRA 0x22FC
330:                   }else{
331:                       cur_shape=shape;
0022FA  88FD78     MOV W8, cur_shape
332:                   }
333:               }// set_cursor()
0022FC  78044F     MOV [--W15], W8
0022FE  060000     RETURN
334:               
335:               
336:               void invert_video(){
337:                   flags |= INV_VID;
002300  A85FAC     BSET flags, #2
338:               }//invert_video()
002302  060000     RETURN
339:               
340:               void normal_video(){
341:                   flags &= ~INV_VID;
002304  A95FAC     BCLR flags, #2
342:               }//normal_video()
002306  060000     RETURN
343:               
344:               void print_msg(const msg_t msg){
002308  BE9F88     MOV.D W8, [W15++]
00230A  BE0400     MOV.D W0, W8
345:                   set_curpos(msg.x,msg.y);
00230C  DE00C8     LSR W0, #8, W1
00230E  FB8008     ZE W8, W0
002310  07FFA2     RCALL set_curpos
346:                   print(msg.text);
002312  780009     MOV W9, W0
002314  07FF23     RCALL print
347:               }//f()
002316  BE044F     MOV.D [--W15], W8
002318  060000     RETURN
348:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/system/timers.c  --------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 *  NAME: timers.c
21:                 *  DATE CREATED: 2014-02-21
22:                 *  AUTHOR: Jacques Deschênes
23:                 *  DESCRIPTION: create timers with callback. TIMER1 is used as a system timer that
24:                 *               ticks at regular interval. The ISR of TIMER1 manage created timers.
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "timers.h"
29:                
30:                #define F_TMR_USED 1
31:                #define F_TMR_HALTED 2
32:                #define F_TMR_REPEAT 4
33:                #define TMR_RUNNING 1
34:                
35:                
36:                typedef struct timer_type{
37:                    unsigned status;    // slot used,  timer halted
38:                    unsigned delay;    // timer interval
39:                    unsigned countdown;
40:                    timer_handler_t *handler; // timer callback handler
41:                }timer_t;
42:                
43:                volatile static timer_t timers[MAX_TIMERS];
44:                volatile static unsigned long ticks;
45:                
46:                void timers_init(unsigned ticks_per_second){
00231A  BE9F88     MOV.D W8, [W15++]
00231C  781F8A     MOV W10, [W15++]
00231E  780500     MOV W0, W10
47:                    unsigned long quotient;
48:                    unsigned prescale;
49:                    int i;
50:                    for (i=0;i<MAX_TIMERS;i++){
002320  EB0200     CLR W4
002332  E80204     INC W4, W4
002334  520FE8     SUB W4, #0x8, [W15]
002336  3AFFF8     BRA NZ, 0x2328
51:                        timers[i].status=0;
002322  21F5C1     MOV #0x1F5C, W1
002324  EB0300     CLR W6
002328  DD22C3     SL W4, #3, W5
00232A  408385     ADD W1, W5, W7
00232C  780B86     MOV W6, [W7]
52:                        timers[i].handler=NULL;
002326  408066     ADD W1, #0x6, W0
00232E  400285     ADD W0, W5, W5
002330  780A86     MOV W6, [W5]
53:                    }//for
54:                    ticks=0;
002338  EF3F58     CLR ticks
00233A  EF3F5A     CLR 0x1F5A
55:                
56:                    SYSTICKTMR.TON=0;  // disable systick timer
00233C  A9E105     BCLR 0x105, #7
57:                    SYSTICKTMR.TCS=0;  // use internal Tcy
00233E  A92104     BCLR T1CON, #1
58:                    quotient = FCY/ticks_per_second;
002340  B85461     MUL.UU W10, #1, W8
002342  BE0108     MOV.D W8, W2
002344  224000     MOV #0x2400, W0
002346  200F41     MOV #0xF4, W1
002348  07F0BF     RCALL 0x4C8
59:                    prescale=1;
002350  200014     MOV #0x1, W4
60:                    while (quotient>65535){
00234A  400FE1     ADD W0, #0x1, [W15]
00234C  588FE0     SUBB W1, #0x0, [W15]
00234E  36000B     BRA LEU, 0x2366
002352  2FFFF6     MOV #0xFFFF, W6
002354  200007     MOV #0x0, W7
00235C  500F86     SUB W0, W6, [W15]
00235E  588F87     SUBB W1, W7, [W15]
002360  3EFFFA     BRA GTU, 0x2356
61:                        quotient >>= 1;
002356  D10081     LSR W1, W1
002358  D38000     RRC W0, W0
62:                        prescale <<= 1;
00235A  420204     ADD W4, W4, W4
63:                    }
64:                    if (prescale==1){
002362  520FE1     SUB W4, #0x1, [W15]
002364  3A0006     BRA NZ, 0x2372
65:                        SYSTICKTMR.TCKPS=0;
002366  800824     MOV T1CON, W4
002368  A14004     BCLR W4, #4
00236A  A15004     BCLR W4, #5
00236C  880824     MOV W4, T1CON
66:                        SYSTICKPR=quotient;
00236E  880810     MOV W0, PR1
002370  370020     BRA 0x23B2
67:                    }else if (prescale<=8){
002372  520FE8     SUB W4, #0x8, [W15]
002374  3E000A     BRA GTU, 0x238A
68:                        SYSTICKTMR.TCKPS=1;
002376  800824     MOV T1CON, W4
002378  A04004     BSET W4, #4
00237A  A15004     BCLR W4, #5
00237C  880824     MOV W4, T1CON
69:                        SYSTICKPR= FCY/8/ticks_per_second;
00237E  BE0108     MOV.D W8, W2
002380  284800     MOV #0x8480, W0
002382  2001E1     MOV #0x1E, W1
002384  07F0A1     RCALL 0x4C8
002386  880810     MOV W0, PR1
002388  370014     BRA 0x23B2
70:                    }else if (prescale<=64){
00238A  200405     MOV #0x40, W5
00238C  520F85     SUB W4, W5, [W15]
00238E  3E000A     BRA GTU, 0x23A4
71:                        SYSTICKTMR.TCKPS=2;
002390  800824     MOV T1CON, W4
002392  A14004     BCLR W4, #4
002394  A05004     BSET W4, #5
002396  880824     MOV W4, T1CON
72:                        SYSTICKPR= FCY/64/ticks_per_second;
002398  BE0108     MOV.D W8, W2
00239A  2D0900     MOV #0xD090, W0
00239C  200031     MOV #0x3, W1
00239E  07F094     RCALL 0x4C8
0023A0  880810     MOV W0, PR1
0023A2  370007     BRA 0x23B2
73:                    }else{
74:                        SYSTICKTMR.TCKPS=3;
0023A4  200300     MOV #0x30, W0
0023A6  B72104     IOR T1CON
75:                        SYSTICKPR = FCY/256/ticks_per_second;
0023A8  2F4244     MOV #0xF424, W4
0023AA  090011     REPEAT #0x11
0023AC  D8820A     DIV.UW W4, W10
0023AE  780200     MOV W0, W4
0023B0  880814     MOV W4, PR1
76:                    }//if
77:                    SYSTICKIF=0; // reset interrupt flag
0023B2  A96084     BCLR IFS0, #3
78:                    SYSTICKIE=1; // enable interrupt on systick timer
0023B4  A86094     BSET IEC0, #3
79:                    SYSTICKTMR.TON = 1; // enable systick timer
0023B6  A8E105     BSET 0x105, #7
80:                }//f()
0023B8  78054F     MOV [--W15], W10
0023BA  BE044F     MOV.D [--W15], W8
0023BC  060000     RETURN
81:                
82:                int create_timer(unsigned delay, unsigned repeat, timer_handler_t *handler){
83:                    int i;
84:                    if (!handler) return -1;
0023BE  EB8200     SETM W4
0023C0  510FE0     SUB W2, #0x0, [W15]
0023C2  320020     BRA Z, 0x2404
85:                    for (i=0;i<MAX_TIMERS;i++){
0023C8  200014     MOV #0x1, W4
0023FC  E80204     INC W4, W4
0023FE  520FE8     SUB W4, #0x8, [W15]
002400  3AFFE4     BRA NZ, 0x23CA
86:                        if (!(timers[i].status & F_TMR_USED)){
0023C4  AB1F5C     BTST timers, #0
0023C6  320007     BRA Z, 0x23D6
0023CA  DD22C3     SL W4, #3, W5
0023CC  21F5C6     MOV #0x1F5C, W6
0023CE  7A82E6     MOV [W6+W5], W5
0023D0  6282E1     AND W5, #0x1, W5
0023D2  3A0014     BRA NZ, 0x23FC
0023D4  370001     BRA 0x23D8
0023D6  EB0200     CLR W4
87:                            timers[i].status = F_TMR_USED|F_TMR_HALTED;
0023D8  DD22C3     SL W4, #3, W5
0023DA  200037     MOV #0x3, W7
0023DC  21F5C6     MOV #0x1F5C, W6
0023DE  7AB307     MOV W7, [W6+W5]
88:                            if (repeat==TIMER_REPEAT) {timers[i].status |= F_TMR_REPEAT;}
0023E0  508FE1     SUB W1, #0x1, [W15]
0023E2  3A0004     BRA NZ, 0x23EC
0023E4  7A83E6     MOV [W6+W5], W7
0023E6  430285     ADD W6, W5, W5
0023E8  A02007     BSET W7, #2
0023EA  780A87     MOV W7, [W5]
89:                            timers[i].delay=delay;
0023EC  DD22C3     SL W4, #3, W5
0023EE  21F5E6     MOV #0x1F5E, W6
0023F0  7AB300     MOV W0, [W6+W5]
90:                            timers[i].countdown=delay;
0023F2  E88306     INC2 W6, W6
0023F4  7AB300     MOV W0, [W6+W5]
91:                            timers[i].handler=handler;
0023F6  E88306     INC2 W6, W6
0023F8  7AB302     MOV W2, [W6+W5]
92:                            return i;
0023FA  370004     BRA 0x2404
93:                        }//if
94:                    }//for
95:                    return -1;
002402  EB8200     SETM W4
96:                }//f()
002404  780004     MOV W4, W0
002406  060000     RETURN
97:                
98:                void stop_timer(int timer_id){
99:                    if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
002408  500FE7     SUB W0, #0x7, [W15]
00240A  3E000B     BRA GTU, 0x2422
002412  620261     AND W4, #0x1, W4
002414  320006     BRA Z, 0x2422
100:                        (timers[timer_id].status & F_TMR_USED)){
00240C  DD0243     SL W0, #3, W4
00240E  21F5C5     MOV #0x1F5C, W5
002410  7A0265     MOV [W5+W4], W4
101:                       timers[timer_id].status |= F_TMR_HALTED;
002416  DD0043     SL W0, #3, W0
002418  780205     MOV W5, W4
00241A  7802E4     MOV [W4+W0], W5
00241C  420000     ADD W4, W0, W0
00241E  A01005     BSET W5, #1
002420  780805     MOV W5, [W0]
102:                   }//if
103:               }//f()
002422  060000     RETURN
104:               
105:               void start_timer(int timer_id){
106:                   if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
002424  500FE7     SUB W0, #0x7, [W15]
002426  3E000F     BRA GTU, 0x2446
00242E  620261     AND W4, #0x1, W4
002430  32000A     BRA Z, 0x2446
107:                       (timers[timer_id].status & F_TMR_USED)){
002428  DD0243     SL W0, #3, W4
00242A  21F5C5     MOV #0x1F5C, W5
00242C  7A0265     MOV [W5+W4], W4
108:                           timers[timer_id].countdown=timers[timer_id].delay;
002432  DD0043     SL W0, #3, W0
002434  E88300     INC2 W0, W6
002436  780205     MOV W5, W4
002438  4282E4     ADD W5, #0x4, W5
00243A  7B0364     MOV [W4+W6], W6
00243C  783286     MOV W6, [W5+W0]
109:                           timers[timer_id].status &= ~F_TMR_HALTED;
00243E  7802E4     MOV [W4+W0], W5
002440  420000     ADD W4, W0, W0
002442  A11005     BCLR W5, #1
002444  780805     MOV W5, [W0]
110:                   }//if
111:               }//f()
002446  060000     RETURN
112:               
113:               void update_timer(int timer_id, unsigned new_delay){
114:                   if ((timer_id>=0)&&(timer_id<=MAX_TIMERS)&&timers[timer_id].status){
002448  500FE8     SUB W0, #0x8, [W15]
00244A  3E0008     BRA GTU, 0x245C
00244C  DD0243     SL W0, #3, W4
00244E  21F5C5     MOV #0x1F5C, W5
002450  7A0265     MOV [W5+W4], W4
002452  520FE0     SUB W4, #0x0, [W15]
002454  320003     BRA Z, 0x245C
115:                       timers[timer_id].delay=new_delay;
002456  DD0043     SL W0, #3, W0
002458  E88205     INC2 W5, W4
00245A  783201     MOV W1, [W4+W0]
116:                   }
117:               }//f()
00245C  060000     RETURN
118:               
119:               void destroy_timer(int timer_id){
120:                   if ((timer_id<0)||(timer_id>=MAX_TIMERS)) return;
00245E  500FE7     SUB W0, #0x7, [W15]
002460  3E0008     BRA GTU, 0x2472
121:                   timers[timer_id].status=0;
002462  DD0043     SL W0, #3, W0
002464  21F5C5     MOV #0x1F5C, W5
002466  428280     ADD W5, W0, W5
002468  EB0200     CLR W4
00246A  780A84     MOV W4, [W5]
122:                   timers[timer_id].handler=NULL;
00246C  21F625     MOV #0x1F62, W5
00246E  428000     ADD W5, W0, W0
002470  780804     MOV W4, [W0]
123:               }//f()
002472  060000     RETURN
124:               
125:               unsigned long sys_ticks(){
126:                   return ticks;
002474  80FAC0     MOV ticks, W0
002476  80FAD1     MOV 0x1F5A, W1
127:               }//f()
002478  060000     RETURN
128:               
129:               void __attribute__((interrupt,no_auto_psv)) _SYSTICK_ISR(void){
00247A  F80036     PUSH RCOUNT
00247C  BE9F80     MOV.D W0, [W15++]
00247E  BE9F82     MOV.D W2, [W15++]
002480  BE9F84     MOV.D W4, [W15++]
002482  BE9F86     MOV.D W6, [W15++]
002484  BE9F88     MOV.D W8, [W15++]
002486  BE9F8A     MOV.D W10, [W15++]
130:                   int i;
131:                   ticks++;
002488  80FAC4     MOV ticks, W4
00248A  80FAD5     MOV 0x1F5A, W5
00248C  420261     ADD W4, #0x1, W4
00248E  4A82E0     ADDC W5, #0x0, W5
002490  88FAC4     MOV W4, ticks
002492  88FAD5     MOV W5, 0x1F5A
132:                   for (i=0;i<MAX_TIMERS;i++){
002494  EB0400     CLR W8
0024DC  E80408     INC W8, W8
0024DE  540FE8     SUB W8, #0x8, [W15]
0024E0  3AFFDB     BRA NZ, 0x2498
133:                       if (((timers[i].status&(F_TMR_USED|F_TMR_HALTED))==TMR_RUNNING)){
002498  DD4243     SL W8, #3, W4
00249A  21F5C5     MOV #0x1F5C, W5
00249C  7A0265     MOV [W5+W4], W4
00249E  620263     AND W4, #0x3, W4
0024A0  520FE1     SUB W4, #0x1, [W15]
0024A2  3A001C     BRA NZ, 0x24DC
134:                           if (--timers[i].countdown==0){
002496  21F609     MOV #0x1F60, W9
0024A4  DD4343     SL W8, #3, W6
0024A6  430264     ADD W6, #0x4, W4
0024A8  7A03E5     MOV [W5+W4], W7
0024AA  448306     ADD W9, W6, W6
0024AC  E90B07     DEC W7, [W6]
0024AE  7A0265     MOV [W5+W4], W4
0024B0  520FE0     SUB W4, #0x0, [W15]
0024B2  3A0014     BRA NZ, 0x24DC
135:                               timers[i].handler();
0024B4  DD45C3     SL W8, #3, W11
0024B6  458266     ADD W11, #0x6, W4
0024B8  780505     MOV W5, W10
0024BA  7A026A     MOV [W10+W4], W4
0024BC  010004     CALL W4
136:                               if (timers[i].status & F_TMR_REPEAT) {
0024BE  7D826A     MOV [W10+W11], W4
0024C0  620264     AND W4, #0x4, W4
0024C2  320006     BRA Z, 0x24D0
137:                                   timers[i].countdown=timers[i].delay;
0024C4  78020B     MOV W11, W4
0024C6  E88284     INC2 W4, W5
0024C8  78030A     MOV W10, W6
0024CA  7A8366     MOV [W6+W5], W6
0024CC  7A3486     MOV W6, [W9+W4]
0024CE  370006     BRA 0x24DC
138:                               }else{
139:                                   timers[i].status |= F_TMR_HALTED;
0024D0  DD4243     SL W8, #3, W4
0024D2  21F5C5     MOV #0x1F5C, W5
0024D4  7A0365     MOV [W5+W4], W6
0024D6  428204     ADD W5, W4, W4
0024D8  A01006     BSET W6, #1
0024DA  780A06     MOV W6, [W4]
140:                               }
141:                           }//if
142:                       }
143:                   }//for
144:                   SYSTICKIF=0;
0024E2  A96084     BCLR IFS0, #3
145:               }// _SYSTICK_ISR()
0024E4  BE054F     MOV.D [--W15], W10
0024E6  BE044F     MOV.D [--W15], W8
0024E8  BE034F     MOV.D [--W15], W6
0024EA  BE024F     MOV.D [--W15], W4
0024EC  BE014F     MOV.D [--W15], W2
0024EE  BE004F     MOV.D [--W15], W0
0024F0  F90036     POP RCOUNT
0024F2  064000     RETFIE
146:               
147:               
148:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/graphics/graphics.c  ----------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   graphics.h
21:                 * Author: jacques Deschênes
22:                 * Description: Draw geometrics figures.
23:                 *      coordinates origin is screen top,left, x increase to right, y increase to bottom
24:                 * Created on 28 février 2014, 13:07
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "graphics.h"
29:                
30:                // draw a dot
31:                
32:                void plot(int x, int y, int color){
33:                    int h,ofs;
34:                    unsigned char mask;
35:                    if ((y>=VPIXELS)||(x>=HPIXELS)) return; // bound check
001368  200D74     MOV #0xD7, W4
00136A  508F84     SUB W1, W4, [W15]
00136C  3C0022     BRA GT, 0x13B2
00136E  500F84     SUB W0, W4, [W15]
001370  3C0020     BRA GT, 0x13B2
36:                    h= x>>3;
001372  DE82C3     ASR W0, #3, W5
37:                    ofs = 7 - (x&7);
001374  EA8000     COM W0, W0
001376  600067     AND W0, #0x7, W0
38:                    mask = 1<<ofs;
001378  200014     MOV #0x1, W4
00137A  DD2000     SL W4, W0, W0
39:                    switch (color){
00137C  510F84     SUB W2, W4, [W15]
00137E  32000C     BRA Z, 0x1398
001380  510FE2     SUB W2, #0x2, [W15]
001382  320011     BRA Z, 0x13A6
001384  510FE0     SUB W2, #0x0, [W15]
001386  3A0015     BRA NZ, 0x13B2
40:                        case BLACK:
41:                            video_buffer[y][h]&= ~mask;
001388  208004     MOV #0x800, W4
00138A  B90B7B     MUL.SU W1, #27, W6
00138C  428086     ADD W5, W6, W1
00138E  420281     ADD W4, W1, W5
001390  EAC000     COM.B W0, W0
001392  78C264     MOV.B [W4+W1], W4
001394  604A84     AND.B W0, W4, [W5]
42:                            break;
001396  37000D     BRA 0x13B2
43:                        case WHITE:
44:                            video_buffer[y][h]|= mask;
001398  208004     MOV #0x800, W4
00139A  B90B7B     MUL.SU W1, #27, W6
00139C  428086     ADD W5, W6, W1
00139E  420281     ADD W4, W1, W5
0013A0  78C264     MOV.B [W4+W1], W4
0013A2  704A84     IOR.B W0, W4, [W5]
45:                            break;
0013A4  370006     BRA 0x13B2
46:                        case INVERT:
47:                            video_buffer[y][h] ^= mask;
0013A6  208004     MOV #0x800, W4
0013A8  B90B7B     MUL.SU W1, #27, W6
0013AA  428086     ADD W5, W6, W1
0013AC  420281     ADD W4, W1, W5
0013AE  78C264     MOV.B [W4+W1], W4
0013B0  684A84     XOR.B W0, W4, [W5]
48:                            break;
49:                    }
50:                } // plot()
0013B2  060000     RETURN
51:                
52:                // dessine une droite en utilisant l'algorithme de Bresenham
53:                void line(int x1, int y1, int x2, int y2, int color){
0013B4  4787EA     ADD W15, #0xA, W15
0013B6  BE9F88     MOV.D W8, [W15++]
0013B8  BE9F8A     MOV.D W10, [W15++]
0013BA  BE9F8C     MOV.D W12, [W15++]
0013BC  781F8E     MOV W14, [W15++]
0013BE  780400     MOV W0, W8
0013C0  780501     MOV W1, W10
0013C2  780582     MOV W2, W11
0013C4  9FB7F3     MOV W3, [W15-18]
0013C6  780604     MOV W4, W12
0013DC  448408     ADD W9, W8, W8
0013DE  370004     BRA 0x13E8
0013F2  540209     SUB W8, W9, W4
001408  44850A     ADD W9, W10, W10
001414  550209     SUB W10, W9, W4
54:                    int deltax,deltay;
55:                    plot(x1,y1,color);
0013C8  78010C     MOV W12, W2
0013CA  78008A     MOV W10, W1
0013CC  780008     MOV W8, W0
0013CE  07FFCC     RCALL plot
56:                    if (y1==y2){// cas particulier ligne horizontale
0013D0  97B27F     MOV [W15-18], W4
0013D2  550F84     SUB W10, W4, [W15]
0013D4  3A0012     BRA NZ, 0x13FA
57:                        deltax= x1<x2?1:-1;
0013D6  540F8B     SUB W8, W11, [W15]
0013D8  3D0003     BRA GE, 0x13E0
0013DA  200019     MOV #0x1, W9
0013E0  EB8480     SETM W9
58:                        while (x1!=x2){
0013E2  540F8B     SUB W8, W11, [W15]
0013E4  3AFFFB     BRA NZ, 0x13DC
0013E6  37004B     BRA 0x147E
0013F4  558F84     SUB W11, W4, [W15]
0013F6  3AFFF8     BRA NZ, 0x13E8
0013F8  370042     BRA 0x147E
59:                            x1 += deltax;
60:                            plot(x1,y1,color);
0013E8  78010C     MOV W12, W2
0013EA  78008A     MOV W10, W1
0013EC  780008     MOV W8, W0
0013EE  07FFBC     RCALL plot
0013F0  440409     ADD W8, W9, W8
61:                        }
62:                    }else if (x1==x2){ // cas particulier ligne verticale
0013FA  540F8B     SUB W8, W11, [W15]
0013FC  3A0010     BRA NZ, 0x141E
63:                        deltay= y1<y2?1:-1;
0013FE  EB8480     SETM W9
001400  97B2FF     MOV [W15-18], W5
001402  550F85     SUB W10, W5, [W15]
001404  3D0001     BRA GE, 0x1408
001406  200019     MOV #0x1, W9
64:                        while (y1!=y2){
001416  97B2FF     MOV [W15-18], W5
001418  528F84     SUB W5, W4, [W15]
00141A  3AFFF7     BRA NZ, 0x140A
00141C  370030     BRA 0x147E
65:                            y1+=deltay;
66:                            plot(x1,y1,color);
00140A  78010C     MOV W12, W2
00140C  78008A     MOV W10, W1
00140E  780008     MOV W8, W0
001410  07FFAB     RCALL plot
001412  450509     ADD W10, W9, W10
67:                        }
68:                    }else{
69:                        int sx,sy,err,e2;
70:                        deltax=abs(x2-x1);
00141E  558708     SUB W11, W8, W14
001420  A7F00E     BTSC W14, #15
001422  EA070E     NEG W14, W14
71:                        deltay=abs(y2-y1);
001424  97B2FF     MOV [W15-18], W5
001426  52820A     SUB W5, W10, W4
001428  A7F004     BTSC W4, #15
00142A  EA0204     NEG W4, W4
00142C  9FBF84     MOV W4, [W15-16]
72:                        sx = x1<x2?1:-1;
00142E  EB8200     SETM W4
001430  9FB7E4     MOV W4, [W15-20]
001432  540F8B     SUB W8, W11, [W15]
001434  3D0002     BRA GE, 0x143A
001436  200015     MOV #0x1, W5
001438  9FB7E5     MOV W5, [W15-20]
73:                        sy = y1<y2?1:-1;
00143A  EB8200     SETM W4
00143C  9FB7D4     MOV W4, [W15-22]
00143E  97B2FF     MOV [W15-18], W5
001440  550F85     SUB W10, W5, [W15]
001442  3D0002     BRA GE, 0x1448
001444  200014     MOV #0x1, W4
001446  9FB7D4     MOV W4, [W15-22]
74:                        err=deltax-deltay;
001448  97BA8F     MOV [W15-16], W5
00144A  570485     SUB W14, W5, W9
75:                        while (!((x1==x2) && (y1==y2))){
001450  78040B     MOV W11, W8
001474  540F8B     SUB W8, W11, [W15]
001476  3AFFED     BRA NZ, 0x1452
001478  97B2FF     MOV [W15-18], W5
00147A  550F85     SUB W10, W5, [W15]
00147C  3AFFE9     BRA NZ, 0x1450
76:                            e2=err<<1;
001452  448209     ADD W9, W9, W4
77:                            if (e2>-deltay){
00144C  EA0685     NEG W5, W13
00144E  370001     BRA 0x1452
001454  520F8D     SUB W4, W13, [W15]
001456  340005     BRA LE, 0x1462
78:                               err -= deltay;
001458  97BA0F     MOV [W15-16], W4
00145A  548484     SUB W9, W4, W9
79:                               x1 += sx;
00145C  97B2EF     MOV [W15-20], W5
00145E  440405     ADD W8, W5, W8
001460  370005     BRA 0x146C
80:                            }else if (e2<deltax){
001462  570F84     SUB W14, W4, [W15]
001464  340003     BRA LE, 0x146C
81:                                err +=deltax;
001466  44848E     ADD W9, W14, W9
82:                                y1 += sy;
001468  97B25F     MOV [W15-22], W4
00146A  450504     ADD W10, W4, W10
83:                            }
84:                            plot(x1,y1,color);
00146C  78010C     MOV W12, W2
00146E  78008A     MOV W10, W1
001470  780008     MOV W8, W0
001472  07FF7A     RCALL plot
85:                        }
86:                    }
87:                } // line()
00147E  78074F     MOV [--W15], W14
001480  BE064F     MOV.D [--W15], W12
001482  BE054F     MOV.D [--W15], W10
001484  BE044F     MOV.D [--W15], W8
001486  B100AF     SUB #0xA, W15
001488  060000     RETURN
88:                
89:                void rectangle(int x1, int y1, int x2, int y2, int color){
00148A  BE9F88     MOV.D W8, [W15++]
00148C  BE9F8A     MOV.D W10, [W15++]
00148E  781F8C     MOV W12, [W15++]
001490  780480     MOV W0, W9
001492  780401     MOV W1, W8
001494  780502     MOV W2, W10
001496  780603     MOV W3, W12
001498  780584     MOV W4, W11
90:                    line(x1,y1,x1,y2,color);
00149A  780109     MOV W9, W2
00149C  780088     MOV W8, W1
00149E  780009     MOV W9, W0
0014A0  07FF89     RCALL line
91:                    line(x2,y1,x2,y2,color);
0014A2  78020B     MOV W11, W4
0014A4  78018C     MOV W12, W3
0014A6  78010A     MOV W10, W2
0014A8  780088     MOV W8, W1
0014AA  78000A     MOV W10, W0
0014AC  07FF83     RCALL line
92:                    line(x1,y1,x2,y1,color);
0014AE  78020B     MOV W11, W4
0014B0  780188     MOV W8, W3
0014B2  78010A     MOV W10, W2
0014B4  780088     MOV W8, W1
0014B6  780009     MOV W9, W0
0014B8  07FF7D     RCALL line
93:                    line(x1,y2,x2,y2,color);
0014BA  78020B     MOV W11, W4
0014BC  78018C     MOV W12, W3
0014BE  78010A     MOV W10, W2
0014C0  78008C     MOV W12, W1
0014C2  780009     MOV W9, W0
0014C4  07FF77     RCALL line
94:                }//rectangle()
0014C6  78064F     MOV [--W15], W12
0014C8  BE054F     MOV.D [--W15], W10
0014CA  BE044F     MOV.D [--W15], W8
0014CC  060000     RETURN
95:                
96:                /*  algorthme mid-point
97:                 * REF: http://www.hhhprogram.com/2013/05/draw-elipse-midpoint-elipse-algorithm.html
98:                 */
99:                void ellipse (int xc, int yc, long rx, long ry, int color){
0014CE  B0036F     ADD #0x36, W15
0014D0  BE9F88     MOV.D W8, [W15++]
0014D2  BE9F8A     MOV.D W10, [W15++]
0014D4  BE9F8C     MOV.D W12, [W15++]
0014D6  781F8E     MOV W14, [W15++]
0014D8  9FAF90     MOV W0, [W15-46]
0014DA  9FAFE1     MOV W1, [W15-36]
0014DC  BE0504     MOV.D W4, W10
0014DE  780706     MOV W6, W14
00155A  9FA7F2     MOV W2, [W15-50]
00155C  9FAF83     MOV W3, [W15-48]
001568  97AA9F     MOV [W15-46], W5
00156A  E90285     DEC W5, W5
00156C  9FA7C5     MOV W5, [W15-56]
00156E  97AB1F     MOV [W15-46], W6
001570  E80306     INC W6, W6
001572  9FA7B6     MOV W6, [W15-58]
001574  9F9FFA     MOV W10, [W15-66]
001576  9FA78B     MOV W11, [W15-64]
001580  97B47F     MOV [W15-18], W8
001582  97A0CF     MOV [W15-56], W1
001584  408088     ADD W1, W8, W1
001586  9FB791     MOV W1, [W15-30]
001594  97A1BF     MOV [W15-58], W3
001596  518408     SUB W3, W8, W8
0015C0  97A07F     MOV [W15-50], W0
0015C2  97A88F     MOV [W15-48], W1
0015C4  40030C     ADD W0, W12, W6
0015C6  48838D     ADDC W1, W13, W7
0015F6  97A47F     MOV [W15-50], W8
0015F8  97AC8F     MOV [W15-48], W9
0015FA  44030C     ADD W8, W12, W6
0015FC  4C838D     ADDC W9, W13, W7
00161A  97B37F     MOV [W15-18], W6
00161C  97BB8F     MOV [W15-16], W7
00161E  530061     SUB W6, #0x1, W0
001620  5B80E0     SUBB W7, #0x0, W1
0016CA  97AA4F     MOV [W15-40], W4
0016CC  97AADF     MOV [W15-38], W5
0016CE  120260     SUBR W4, #0x0, W4
0016D0  1A82E0     SUBBR W5, #0x0, W5
0016D2  9FB794     MOV W4, [W15-30]
0016D4  9FB7A5     MOV W5, [W15-28]
0016D6  97AADF     MOV [W15-38], W5
0016D8  97B47F     MOV [W15-18], W8
0016DA  B9AB08     MUL.SS W5, W8, W6
0016DC  97BC8F     MOV [W15-16], W9
0016DE  97A84F     MOV [W15-40], W0
0016E0  B9CA00     MUL.SS W9, W0, W4
0016E2  420206     ADD W4, W6, W4
0016E4  97A9CF     MOV [W15-40], W3
0016E6  97B15F     MOV [W15-22], W2
0016E8  B81902     MUL.UU W3, W2, W2
0016EA  9FB7B2     MOV W2, [W15-26]
0016EC  9FB7C3     MOV W3, [W15-24]
0016EE  420183     ADD W4, W3, W3
0016F0  9FB7C3     MOV W3, [W15-24]
0016F2  97B23F     MOV [W15-26], W4
0016F4  97B2CF     MOV [W15-24], W5
0016F6  9FB7D4     MOV W4, [W15-22]
0016F8  9FB7E5     MOV W5, [W15-20]
001702  97ABEF     MOV [W15-36], W7
001704  53858C     SUB W7, W12, W11
001712  97A8EF     MOV [W15-36], W1
001714  40848C     ADD W1, W12, W9
00173A  560261     SUB W12, #0x1, W4
00173C  5E82E0     SUBB W13, #0x0, W5
001758  560261     SUB W12, #0x1, W4
00175A  5E82E0     SUBB W13, #0x0, W5
100:                         long  x=0,y=ry;
101:                         long  p=(ry*ry)-(rx*rx*ry)+((rx*rx)/4);
0014E0  B99A02     MUL.SS W3, W2, W4
0014E2  420204     ADD W4, W4, W4
0014E4  B81002     MUL.UU W2, W2, W0
0014E6  9FAFA0     MOV W0, [W15-44]
0014E8  9FAFB1     MOV W1, [W15-42]
0014EA  420081     ADD W4, W1, W1
0014EC  9FAFB1     MOV W1, [W15-42]
0014EE  97A92F     MOV [W15-44], W2
0014F0  97A9BF     MOV [W15-42], W3
0014F2  550202     SUB W10, W2, W4
0014F4  5D8283     SUBB W11, W3, W5
0014F6  B9AB0A     MUL.SS W5, W10, W6
0014F8  B9D804     MUL.SS W11, W4, W0
0014FA  400306     ADD W0, W6, W6
0014FC  B8220A     MUL.UU W4, W10, W4
0014FE  430285     ADD W6, W5, W5
001500  BE0302     MOV.D W2, W6
001502  510FE0     SUB W2, #0x0, [W15]
001504  598FE0     SUBB W3, #0x0, [W15]
001506  3D0002     BRA GE, 0x150C
001508  410363     ADD W2, #0x3, W6
00150A  4983E0     ADDC W3, #0x0, W7
00150C  DD39CE     SL W7, #14, W3
00150E  DE3342     LSR W6, #2, W6
001510  718306     IOR W3, W6, W6
001512  DEBBC2     ASR W7, #2, W7
001514  430404     ADD W6, W4, W8
001516  4B8485     ADDC W7, W5, W9
001518  9FB7B8     MOV W8, [W15-26]
00151A  9FB7C9     MOV W9, [W15-24]
102:                         while((2*x*ry*ry)<(2*y*rx*rx)){
00151C  B9DA0A     MUL.SS W11, W10, W4
00151E  420204     ADD W4, W4, W4
001520  B8500A     MUL.UU W10, W10, W0
001522  9FA7D0     MOV W0, [W15-54]
001524  9FA7E1     MOV W1, [W15-52]
001526  420081     ADD W4, W1, W1
001528  9FA7E1     MOV W1, [W15-52]
00152A  97A15F     MOV [W15-54], W2
00152C  97A1EF     MOV [W15-52], W3
00152E  410102     ADD W2, W2, W2
001530  498183     ADDC W3, W3, W3
001532  9FA792     MOV W2, [W15-62]
001534  9FA7A3     MOV W3, [W15-60]
001536  97AA2F     MOV [W15-44], W4
001538  97AABF     MOV [W15-42], W5
00153A  420204     ADD W4, W4, W4
00153C  4A8285     ADDC W5, W5, W5
00153E  9FB7D4     MOV W4, [W15-22]
001540  9FB7E5     MOV W5, [W15-20]
00155E  200014     MOV #0x1, W4
001560  200005     MOV #0x0, W5
001562  9FB7F4     MOV W4, [W15-18]
001564  9FBF85     MOV W5, [W15-16]
001566  B86660     MUL.UU W12, #0, W12
001578  370050     BRA 0x161A
001622  97B3DF     MOV [W15-22], W7
001624  B9DA07     MUL.SS W11, W7, W4
001626  97B46F     MOV [W15-20], W8
001628  B9C30A     MUL.SS W8, W10, W6
00162A  430304     ADD W6, W4, W6
00162C  97B4DF     MOV [W15-22], W9
00162E  B85209     MUL.UU W10, W9, W4
001630  430285     ADD W6, W5, W5
001632  520F8C     SUB W4, W12, [W15]
001634  5A8F8D     SUBB W5, W13, [W15]
001636  3CFFA1     BRA GT, 0x157A
001638  BE010A     MOV.D W10, W2
00163A  9FB79A     MOV W10, [W15-30]
00163C  9FB7AB     MOV W11, [W15-28]
00163E  9FAFF0     MOV W0, [W15-34]
001640  9FB781     MOV W1, [W15-32]
001642  979D7F     MOV [W15-66], W10
001644  97A58F     MOV [W15-64], W11
001646  BE0600     MOV.D W0, W12
103:                              plot(xc+x,yc-y,color);
00157A  97A86F     MOV [W15-36], W0
00157C  50000A     SUB W0, W10, W0
00157E  9FAFF0     MOV W0, [W15-34]
001588  78010E     MOV W14, W2
00158A  780080     MOV W0, W1
00158C  97B01F     MOV [W15-30], W0
00158E  07FEEC     RCALL plot
104:                              plot(xc-x,yc+y,color);
001590  97A96F     MOV [W15-36], W2
001592  450482     ADD W10, W2, W9
001598  78010E     MOV W14, W2
00159A  BE0008     MOV.D W8, W0
00159C  07FEE5     RCALL plot
105:                              plot(xc+x,yc+y,color);
00159E  78010E     MOV W14, W2
0015A0  780089     MOV W9, W1
0015A2  97B01F     MOV [W15-30], W0
0015A4  07FEE1     RCALL plot
106:                              plot(xc-x,yc-y,color);
0015A6  78010E     MOV W14, W2
0015A8  97A8FF     MOV [W15-34], W1
0015AA  780008     MOV W8, W0
0015AC  07FEDD     RCALL plot
107:                              if(p<0){
0015AE  97B23F     MOV [W15-26], W4
0015B0  97B2CF     MOV [W15-24], W5
0015B2  520FE0     SUB W4, #0x0, [W15]
0015B4  5A8FE0     SUBB W5, #0x0, [W15]
0015B6  3D000D     BRA GE, 0x15D2
108:                                  x=x+1;
109:                                  p=p+(2*ry*ry*x)+(ry*ry);
0015B8  97A45F     MOV [W15-54], W8
0015BA  97A4EF     MOV [W15-52], W9
0015BC  440204     ADD W8, W4, W4
0015BE  4C8285     ADDC W9, W5, W5
0015C8  420106     ADD W4, W6, W2
0015CA  4A8187     ADDC W5, W7, W3
0015CC  9FB7B2     MOV W2, [W15-26]
0015CE  9FB7C3     MOV W3, [W15-24]
0015D0  37001A     BRA 0x1606
110:                              }else {
111:                                  x=x+1;
112:                                  y=y-1;
0015D2  550561     SUB W10, #0x1, W10
0015D4  5D85E0     SUBB W11, #0x0, W11
113:                                  p=p+(2*ry*ry*x+ry*ry)-(2*rx*rx*y);
001542  2FFFE4     MOV #0xFFFE, W4
001544  97AB3F     MOV [W15-42], W6
001546  B9B204     MUL.SS W6, W4, W4
001548  97ABAF     MOV [W15-44], W7
00154A  520207     SUB W4, W7, W4
00154C  2FFFE5     MOV #0xFFFE, W5
00154E  97ACAF     MOV [W15-44], W9
001550  B84C05     MUL.UU W9, W5, W8
001552  9FAFC8     MOV W8, [W15-40]
001554  9FAFD9     MOV W9, [W15-38]
001556  420489     ADD W4, W9, W9
001558  9FAFD9     MOV W9, [W15-38]
0015D6  97B23F     MOV [W15-26], W4
0015D8  97B2CF     MOV [W15-24], W5
0015DA  97A45F     MOV [W15-54], W8
0015DC  97A4EF     MOV [W15-52], W9
0015DE  440304     ADD W8, W4, W6
0015E0  4C8385     ADDC W9, W5, W7
0015E2  97ACCF     MOV [W15-40], W9
0015E4  B9DA09     MUL.SS W11, W9, W4
0015E6  97A95F     MOV [W15-38], W2
0015E8  B9900A     MUL.SS W2, W10, W0
0015EA  400004     ADD W0, W4, W0
0015EC  97A9CF     MOV [W15-40], W3
0015EE  B85203     MUL.UU W10, W3, W4
0015F0  400285     ADD W0, W5, W5
0015F2  420206     ADD W4, W6, W4
0015F4  4A8287     ADDC W5, W7, W5
0015FE  420006     ADD W4, W6, W0
001600  4A8087     ADDC W5, W7, W1
001602  9FB7B0     MOV W0, [W15-26]
001604  9FB7C1     MOV W1, [W15-24]
001606  97A17F     MOV [W15-50], W2
001608  97A98F     MOV [W15-48], W3
00160A  41060C     ADD W2, W12, W12
00160C  49868D     ADDC W3, W13, W13
00160E  97B27F     MOV [W15-18], W4
001610  97BA8F     MOV [W15-16], W5
001612  420261     ADD W4, #0x1, W4
001614  4A82E0     ADDC W5, #0x0, W5
001616  9FB7F4     MOV W4, [W15-18]
001618  9FBF85     MOV W5, [W15-16]
114:                              }
115:                         }
116:                         p=((float)x+0.5)*((float)x+0.5)*ry*ry+(y-1)*(y-1)*rx*rx-rx*rx*ry*ry;
00164E  BE000A     MOV.D W10, W0
001650  07F6B1     RCALL 0x3B4
001652  BE0400     MOV.D W0, W8
001654  97B31F     MOV [W15-30], W6
001656  97B3AF     MOV [W15-28], W7
001658  530361     SUB W6, #0x1, W6
00165A  5B83E0     SUBB W7, #0x0, W7
00165C  9FB7F6     MOV W6, [W15-18]
00165E  9FBF87     MOV W7, [W15-16]
001660  BE000C     MOV.D W12, W0
001662  07F6A8     RCALL 0x3B4
001664  200002     MOV #0x0, W2
001666  23F003     MOV #0x3F00, W3
001668  07F627     RCALL 0x2B8
00166A  BE0100     MOV.D W0, W2
00166C  07F6F9     RCALL 0x460
00166E  BE0108     MOV.D W8, W2
001670  07F6F7     RCALL 0x460
001672  BE0100     MOV.D W0, W2
001674  BE0008     MOV.D W8, W0
001676  07F6F4     RCALL 0x460
001678  BE0400     MOV.D W0, W8
00167A  97BB8F     MOV [W15-16], W7
00167C  97B07F     MOV [W15-18], W0
00167E  B9BA00     MUL.SS W7, W0, W4
001680  420204     ADD W4, W4, W4
001682  97B0FF     MOV [W15-18], W1
001684  9FB7D1     MOV W1, [W15-22]
001686  780101     MOV W1, W2
001688  B81002     MUL.UU W2, W2, W0
00168A  420081     ADD W4, W1, W1
00168C  97A9AF     MOV [W15-44], W3
00168E  B98B03     MUL.SS W1, W3, W6
001690  97A93F     MOV [W15-42], W2
001692  B99200     MUL.SS W2, W0, W4
001694  420206     ADD W4, W6, W4
001696  97AD2F     MOV [W15-44], W10
001698  B8000A     MUL.UU W0, W10, W0
00169A  420081     ADD W4, W1, W1
00169C  07F68B     RCALL 0x3B4
00169E  BE0100     MOV.D W0, W2
0016A0  BE0008     MOV.D W8, W0
0016A2  07F60A     RCALL 0x2B8
0016A4  BE0400     MOV.D W0, W8
0016A6  97A9BF     MOV [W15-42], W3
0016A8  97A25F     MOV [W15-54], W4
0016AA  B99B04     MUL.SS W3, W4, W6
0016AC  97A06F     MOV [W15-52], W0
0016AE  97A8AF     MOV [W15-44], W1
0016B0  B98201     MUL.SS W0, W1, W4
0016B2  420206     ADD W4, W6, W4
0016B4  97A15F     MOV [W15-54], W2
0016B6  B85002     MUL.UU W10, W2, W0
0016B8  420081     ADD W4, W1, W1
0016BA  07F67C     RCALL 0x3B4
0016BC  BE0100     MOV.D W0, W2
0016BE  BE0008     MOV.D W8, W0
0016C0  07F5FA     RCALL 0x2B6
0016C2  07F657     RCALL 0x372
0016C4  BE0500     MOV.D W0, W10
0016C6  97B61F     MOV [W15-30], W12
0016C8  97B6AF     MOV [W15-28], W13
117:                         while(y>=0){
001648  510FE0     SUB W2, #0x0, [W15]
00164A  598FE0     SUBB W3, #0x0, [W15]
00164C  3500B8     BRA LT, 0x17BE
0017B8  520FE0     SUB W4, #0x0, [W15]
0017BA  5A8FE0     SUBB W5, #0x0, [W15]
0017BC  3DFFA2     BRA GE, 0x1702
118:                              plot(xc+x,yc-y,color);
001706  97AC7F     MOV [W15-34], W8
001708  97A81F     MOV [W15-46], W0
00170A  440500     ADD W8, W0, W10
00170C  78010E     MOV W14, W2
00170E  BE000A     MOV.D W10, W0
001710  07FE2B     RCALL plot
119:                              plot(xc-x,yc+y,color);
001716  97A91F     MOV [W15-46], W2
001718  510408     SUB W2, W8, W8
00171A  78010E     MOV W14, W2
00171C  BE0008     MOV.D W8, W0
00171E  07FE24     RCALL plot
120:                              plot(xc+x,yc+y,color);
001720  78010E     MOV W14, W2
001722  780089     MOV W9, W1
001724  78000A     MOV W10, W0
001726  07FE20     RCALL plot
121:                              plot(xc-x,yc-y,color);
001728  78010E     MOV W14, W2
00172A  78008B     MOV W11, W1
00172C  780008     MOV W8, W0
00172E  07FE1C     RCALL plot
122:                              if(p>0){
001730  97B27F     MOV [W15-18], W4
001732  97BA8F     MOV [W15-16], W5
001734  520FE0     SUB W4, #0x0, [W15]
001736  5A8FE0     SUBB W5, #0x0, [W15]
001738  34000F     BRA LE, 0x1758
123:                                  y=y-1;
124:                                  p=p-(2*rx*rx*y)+(rx*rx);
00173E  97B47F     MOV [W15-18], W8
001740  97BC8F     MOV [W15-16], W9
001742  97A82F     MOV [W15-44], W0
001744  97A8BF     MOV [W15-42], W1
001746  400308     ADD W0, W8, W6
001748  488389     ADDC W1, W9, W7
00174A  97B15F     MOV [W15-22], W2
00174C  97B1EF     MOV [W15-20], W3
00174E  430102     ADD W6, W2, W2
001750  4B8183     ADDC W7, W3, W3
001752  9FB7F2     MOV W2, [W15-18]
001754  9FBF83     MOV W3, [W15-16]
001756  370020     BRA 0x1798
125:                              }else{
126:                                  y=y-1;
127:                                  x=x+1;
00175C  97AB7F     MOV [W15-34], W6
00175E  97B38F     MOV [W15-32], W7
001760  430361     ADD W6, #0x1, W6
001762  4B83E0     ADDC W7, #0x0, W7
001764  9FAFF6     MOV W6, [W15-34]
001766  9FB787     MOV W7, [W15-32]
128:                                  p=p+(2*ry*ry*x)-(2*rx*rx*y)-(rx*rx);
0016FA  97A29F     MOV [W15-62], W5
0016FC  9FAFC5     MOV W5, [W15-40]
0016FE  9FB7FA     MOV W10, [W15-18]
001700  9FBF8B     MOV W11, [W15-16]
001768  97B47F     MOV [W15-18], W8
00176A  97BC8F     MOV [W15-16], W9
00176C  97A82F     MOV [W15-44], W0
00176E  97A8BF     MOV [W15-42], W1
001770  540100     SUB W8, W0, W2
001772  5C8181     SUBB W9, W1, W3
001774  97A3AF     MOV [W15-60], W7
001776  B9B806     MUL.SS W7, W6, W0
001778  97B40F     MOV [W15-32], W8
00177A  97A49F     MOV [W15-62], W9
00177C  B9C309     MUL.SS W8, W9, W6
00177E  430000     ADD W6, W0, W0
001780  97A8CF     MOV [W15-40], W1
001782  97AC7F     MOV [W15-34], W8
001784  B80B08     MUL.UU W1, W8, W6
001786  400387     ADD W0, W7, W7
001788  430302     ADD W6, W2, W6
00178A  4B8383     ADDC W7, W3, W7
00178C  97B03F     MOV [W15-26], W0
00178E  97B0CF     MOV [W15-24], W1
001790  430000     ADD W6, W0, W0
001792  4B8081     ADDC W7, W1, W1
001794  9FB7F0     MOV W0, [W15-18]
001796  9FBF81     MOV W1, [W15-16]
001798  560661     SUB W12, #0x1, W12
00179A  5E86E0     SUBB W13, #0x0, W13
00179C  97B15F     MOV [W15-22], W2
00179E  97B1EF     MOV [W15-20], W3
0017A0  97B31F     MOV [W15-30], W6
0017A2  97B3AF     MOV [W15-28], W7
0017A4  430102     ADD W6, W2, W2
0017A6  4B8183     ADDC W7, W3, W3
0017A8  9FB7D2     MOV W2, [W15-22]
0017AA  9FB7E3     MOV W3, [W15-20]
0017AC  97B43F     MOV [W15-26], W8
0017AE  97B4CF     MOV [W15-24], W9
0017B0  430408     ADD W6, W8, W8
0017B2  4B8489     ADDC W7, W9, W9
0017B4  9FB7B8     MOV W8, [W15-26]
0017B6  9FB7C9     MOV W9, [W15-24]
129:                              }
130:                         }
131:               }//ellipse()
0017BE  78074F     MOV [--W15], W14
0017C0  BE064F     MOV.D [--W15], W12
0017C2  BE054F     MOV.D [--W15], W10
0017C4  BE044F     MOV.D [--W15], W8
0017C6  B1036F     SUB #0x36, W15
0017C8  060000     RETURN
132:               
133:               /*
134:                * points[]={x1,y1,x2,y2,x3,y3,...}
135:                * vertices est le nombre de points
136:                */
137:               void polygon(int points[], int vertices, int color){
0017CA  BE9F88     MOV.D W8, [W15++]
0017CC  BE9F8A     MOV.D W10, [W15++]
0017CE  781F8C     MOV W12, [W15++]
0017D0  780600     MOV W0, W12
0017D2  780582     MOV W2, W11
138:                   int i;
139:                   for(i=0;i<(2*vertices-2);i+=2){
0017D4  E90501     DEC W1, W10
0017D6  45050A     ADD W10, W10, W10
0017D8  EB0480     CLR W9
0017DA  550F89     SUB W10, W9, [W15]
0017DC  34000B     BRA LE, 0x17F4
0017DE  78040C     MOV W12, W8
0017EC  E88489     INC2 W9, W9
0017EE  440464     ADD W8, #0x4, W8
0017F0  550F89     SUB W10, W9, [W15]
0017F2  3CFFF6     BRA GT, 0x17E0
140:                       line(points[i],points[i+1],points[i+2],points[i+3],color);
0017E0  900128     MOV [W8+4], W2
0017E2  900098     MOV [W8+2], W1
0017E4  78020B     MOV W11, W4
0017E6  9001B8     MOV [W8+6], W3
0017E8  780018     MOV [W8], W0
0017EA  07FDE4     RCALL line
141:                   }
142:                   line(points[0],points[1],points[i],points[i+1],color);
0017F4  E80289     INC W9, W5
0017F6  428285     ADD W5, W5, W5
0017F8  448489     ADD W9, W9, W9
0017FA  90009C     MOV [W12+2], W1
0017FC  78020B     MOV W11, W4
0017FE  7A81EC     MOV [W12+W5], W3
001800  7C816C     MOV [W12+W9], W2
001802  78001C     MOV [W12], W0
001804  07FDD7     RCALL line
143:               }//polygon()
001806  78064F     MOV [--W15], W12
001808  BE054F     MOV.D [--W15], W10
00180A  BE044F     MOV.D [--W15], W8
00180C  060000     RETURN
144:               
145:               
146:               void box(int left, int top, int width, int height,int color){
00180E  4787E4     ADD W15, #0x4, W15
001810  BE9F88     MOV.D W8, [W15++]
001812  BE9F8A     MOV.D W10, [W15++]
001814  BE9F8C     MOV.D W12, [W15++]
001816  781F8E     MOV W14, [W15++]
001818  9FBF80     MOV W0, [W15-16]
001886  780302     MOV W2, W6
001888  97BB8F     MOV [W15-16], W7
147:                   unsigned char mask;
148:                   int y, x,idx,mwidth,countdown;
149:               //    for (y=top;y<top+height;y++)
150:               //        for (x=left;x<left+width;x++)
151:               //            plot(x,y,color);
152:                   if (!(width && height)) return;
00181A  510FE0     SUB W2, #0x0, [W15]
00181C  320039     BRA Z, 0x1890
00181E  518FE0     SUB W3, #0x0, [W15]
001820  320037     BRA Z, 0x1890
153:                   for (y=top;y<top+height;y++){
001822  418701     ADD W3, W1, W14
001824  508F8E     SUB W1, W14, [W15]
001826  35002A     BRA LT, 0x187C
001828  370033     BRA 0x1890
001874  E8068D     INC W13, W13
001876  568F8E     SUB W13, W14, [W15]
001878  350006     BRA LT, 0x1886
00187A  37000A     BRA 0x1890
00187C  780681     MOV W1, W13
154:                       x=left;
155:                       countdown=width;
156:                       while (countdown){
001872  3AFFDB     BRA NZ, 0x182A
157:                           idx=x>>3;
00182C  DEB9C3     ASR W7, #3, W3
158:                           if ((x&7)==0){
00182E  6380E7     AND W7, #0x7, W1
001834  320002     BRA Z, 0x183A
159:                               mask=0xff;
001832  784009     MOV.B W9, W0
001884  EBC480     SETM.B W9
160:                               mwidth=8;
001830  78028B     MOV W11, W5
00187E  20008B     MOV #0x8, W11
161:                           }else{
162:                               mask=0xff>>(x&7);
001836  DED001     ASR W10, W1, W0
001880  200FFA     MOV #0xFF, W10
163:                               mwidth=8-(x&7);
001838  1082E8     SUBR W1, #0x8, W5
164:                           }
165:                           if (countdown<mwidth){
00183A  528F86     SUB W5, W6, [W15]
00183C  340004     BRA LE, 0x1846
166:                               mask &= 0xff<<(mwidth-countdown);
00183E  528286     SUB W5, W6, W5
001840  DD5285     SL W10, W5, W5
001842  604005     AND.B W0, W5, W0
001844  780286     MOV W6, W5
167:                               mwidth=countdown;
168:                           }
169:                           switch(color){
001846  520FE1     SUB W4, #0x1, [W15]
001848  32000A     BRA Z, 0x185E
00184A  520FE2     SUB W4, #0x2, [W15]
00184C  32000D     BRA Z, 0x1868
00184E  520FE0     SUB W4, #0x0, [W15]
001850  3A000F     BRA NZ, 0x1870
170:                               case BLACK:
171:                                   video_buffer[y][idx] &= ~mask;
001852  460183     ADD W12, W3, W3
001854  440083     ADD W8, W3, W1
001856  EAC000     COM.B W0, W0
001858  79C1E8     MOV.B [W8+W3], W3
00185A  604883     AND.B W0, W3, [W1]
172:                                   break;
00185C  370009     BRA 0x1870
173:                               case WHITE:
174:                                   video_buffer[y][idx] |= mask;
00185E  460183     ADD W12, W3, W3
001860  440083     ADD W8, W3, W1
001862  79C1E8     MOV.B [W8+W3], W3
001864  704883     IOR.B W0, W3, [W1]
001882  208008     MOV #0x800, W8
00188A  B9687B     MUL.SU W13, #27, W0
00188C  780600     MOV W0, W12
00188E  37FFCE     BRA 0x182C
175:                                   break;
001866  370004     BRA 0x1870
176:                               case INVERT:
177:                                   video_buffer[y][idx] ^= mask;
001868  460183     ADD W12, W3, W3
00186A  440083     ADD W8, W3, W1
00186C  79C1E8     MOV.B [W8+W3], W3
00186E  684883     XOR.B W0, W3, [W1]
178:                                   break;
179:                           }//switch
180:                           x += mwidth;
00182A  438385     ADD W7, W5, W7
181:                           countdown -= mwidth;
001870  530305     SUB W6, W5, W6
182:                       }//while
183:                   }//for
184:               }//f()
001890  78074F     MOV [--W15], W14
001892  BE064F     MOV.D [--W15], W12
001894  BE054F     MOV.D [--W15], W10
001896  BE044F     MOV.D [--W15], W8
001898  B1004F     SUB #0x4, W15
00189A  060000     RETURN
185:               
186:               
187:               
188:               void bitmap(int left, int top, int width, int height, bmp_op_t op, const unsigned char* bmp){
00189C  4787EE     ADD W15, #0xE, W15
00189E  BE9F88     MOV.D W8, [W15++]
0018A0  BE9F8A     MOV.D W10, [W15++]
0018A2  BE9F8C     MOV.D W12, [W15++]
0018A4  781F8E     MOV W14, [W15++]
0018A6  9FB7B0     MOV W0, [W15-26]
0018A8  9FB7E2     MOV W2, [W15-20]
00196E  97B35F     MOV [W15-22], W6
001970  450506     ADD W10, W6, W10
001972  370005     BRA 0x197E
189:                   int x,y, xbmp,mwidth,idx, countdown,ybmp_inc;
190:                   unsigned char  mask, bmpbits;
191:                   const unsigned char *ybmp;
192:               
193:                   ybmp_inc=width>>3;
0018AA  DE9143     ASR W2, #3, W2
0018AC  9FB7D2     MOV W2, [W15-22]
194:                   if (width&7) ybmp_inc++;
0018AE  97B3EF     MOV [W15-20], W7
0018B0  638367     AND W7, #0x7, W6
0018B2  320002     BRA Z, 0x18B8
0018B4  E80102     INC W2, W2
0018B6  9FB7D2     MOV W2, [W15-22]
195:                   ybmp=bmp;
001974  780505     MOV W5, W10
196:                   //remainder=0;
197:                   for (y=top;y<top+height;y++){
0018B8  418181     ADD W3, W1, W3
0018BA  9FB7C3     MOV W3, [W15-24]
0018BC  508F83     SUB W1, W3, [W15]
0018BE  35005A     BRA LT, 0x1974
0018C0  370062     BRA 0x1986
001962  97B27F     MOV [W15-18], W4
001964  E80204     INC W4, W4
001966  9FB7F4     MOV W4, [W15-18]
001968  97B2CF     MOV [W15-24], W5
00196A  528F84     SUB W5, W4, [W15]
00196C  34000C     BRA LE, 0x1986
001976  9FB7F1     MOV W1, [W15-18]
198:                       x=left;
199:                       xbmp=0;
200:                       countdown=width;
201:                       while (countdown){
0018C8  97B2EF     MOV [W15-20], W5
0018CA  97B03F     MOV [W15-26], W0
0018CC  EB0380     CLR W7
001960  3AFFB0     BRA NZ, 0x18C2
00197E  97B3EF     MOV [W15-20], W7
001980  538FE0     SUB W7, #0x0, [W15]
001982  3AFFA2     BRA NZ, 0x18C8
001984  37FFEE     BRA 0x1962
202:                           idx=x>>3;
0018D6  DE84C3     ASR W0, #3, W9
203:                           if ((x&7)==0){
0018D8  600367     AND W0, #0x7, W6
0018DE  320003     BRA Z, 0x18E6
204:                               mask=0xff;
0018DA  78408E     MOV.B W14, W1
00197C  EBC700     SETM.B W14
205:                               mwidth=8;
0018DC  200084     MOV #0x8, W4
206:                           }else{
207:                               mask=0xff>>(x&7);
0018E0  200FF2     MOV #0xFF, W2
0018E2  DE9086     ASR W2, W6, W1
208:                               mwidth=8-(x&7);
0018E4  520206     SUB W4, W6, W4
209:                           }
210:                           if (countdown<mwidth){
0018E6  520F85     SUB W4, W5, [W15]
0018E8  340005     BRA LE, 0x18F4
211:                               mask &= 0xff<<(mwidth-countdown);
0018EA  520205     SUB W4, W5, W4
0018EC  200FF3     MOV #0xFF, W3
0018EE  DD1A04     SL W3, W4, W4
0018F0  60C084     AND.B W1, W4, W1
0018F2  780205     MOV W5, W4
212:                               mwidth=countdown;
213:                           }
214:                           bmpbits = (*(ybmp+(xbmp>>3)))<<(xbmp&7);
0018F4  DEBC43     ASR W7, #3, W8
0018F6  638167     AND W7, #0x7, W2
0018F8  7C41EA     MOV.B [W10+W8], W3
0018FA  FB8183     ZE W3, W3
0018FC  DD1982     SL W3, W2, W3
215:                           if (xbmp&7){
0018FE  510FE0     SUB W2, #0x0, [W15]
001900  320006     BRA Z, 0x190E
216:                               bmpbits |= (*(ybmp+(xbmp>>3)+1))>>(8-(xbmp&7));
001902  450408     ADD W10, W8, W8
001904  904418     MOV.B [W8+1], W8
001906  FB8408     ZE W8, W8
001908  110168     SUBR W2, #0x8, W2
00190A  DEC102     ASR W8, W2, W2
00190C  71C182     IOR.B W3, W2, W3
217:                           }
218:                           bmpbits >>= (x&7);
00190E  FB8183     ZE W3, W3
001910  DE9B06     ASR W3, W6, W6
219:                           bmpbits &= mask;
001912  634301     AND.B W6, W1, W6
220:                           switch(op){
001914  200032     MOV #0x3, W2
001916  200003     MOV #0x0, W3
001918  560F82     SUB W12, W2, [W15]
00191A  5E8F83     SUBB W13, W3, [W15]
00191C  3E0020     BRA GTU, 0x195E
00191E  01600C     BRA W12
001920  370003     BRA 0x1928
001922  37000A     BRA 0x1938
001924  37000F     BRA 0x1944
001926  370016     BRA 0x1954
001978  B82661     MUL.UU W4, #1, W12
221:                               case BMP_COPY:
222:                                   video_buffer[y][idx] &= ~mask;
00192E  EAC081     COM.B W1, W1
001930  7CC1EB     MOV.B [W11+W9], W3
001932  60C083     AND.B W1, W3, W1
223:                                   video_buffer[y][idx] |= bmpbits;
001928  97B98F     MOV [W15-16], W3
00192A  418489     ADD W3, W9, W9
00192C  458109     ADD W11, W9, W2
001934  734901     IOR.B W6, W1, [W2]
224:                                   break;
001936  370013     BRA 0x195E
225:                               case BMP_OR:
226:                                   video_buffer[y][idx] |= bmpbits;
001938  97B88F     MOV [W15-16], W1
00193A  408489     ADD W1, W9, W9
00193C  458089     ADD W11, W9, W1
00193E  7CC16B     MOV.B [W11+W9], W2
001940  734882     IOR.B W6, W2, [W1]
227:                                   break;
001942  37000D     BRA 0x195E
228:                               case BMP_AND:
229:                                   video_buffer[y][idx] &= (~mask) | bmpbits;
001944  97B90F     MOV [W15-16], W2
001946  410489     ADD W2, W9, W9
001948  458109     ADD W11, W9, W2
00194A  EAC081     COM.B W1, W1
00194C  734081     IOR.B W6, W1, W1
00194E  7CC36B     MOV.B [W11+W9], W6
001950  60C906     AND.B W1, W6, [W2]
230:                                   break;
001952  370005     BRA 0x195E
231:                               case BMP_XOR:
232:                                   video_buffer[y][idx] ^= bmpbits;
0018CE  97B0FF     MOV [W15-18], W1
0018D0  B9097B     MUL.SU W1, #27, W2
0018D2  780202     MOV W2, W4
0018D4  9FBF84     MOV W4, [W15-16]
001954  97B98F     MOV [W15-16], W3
001956  418489     ADD W3, W9, W9
001958  458089     ADD W11, W9, W1
00195A  7CC16B     MOV.B [W11+W9], W2
00195C  6B4882     XOR.B W6, W2, [W1]
00197A  20800B     MOV #0x800, W11
233:                                   break;
234:                           }//switch
235:                           x += mwidth;
0018C2  400004     ADD W0, W4, W0
236:                           xbmp += mwidth;
0018C4  438384     ADD W7, W4, W7
0018C6  370007     BRA 0x18D6
237:                           countdown -= mwidth;
00195E  528284     SUB W5, W4, W5
238:                       }//while
239:                       ybmp+=ybmp_inc;
240:                       
241:                   }//for
242:               }//f()
001986  78074F     MOV [--W15], W14
001988  BE064F     MOV.D [--W15], W12
00198A  BE054F     MOV.D [--W15], W10
00198C  BE044F     MOV.D [--W15], W8
00198E  B100EF     SUB #0xE, W15
001990  060000     RETURN
243:               
244:               void put_xbm(int left, int top, int width, int height, const unsigned char* xbm_bits){
001992  BE9F88     MOV.D W8, [W15++]
001994  BE9F8A     MOV.D W10, [W15++]
001996  BE9F8C     MOV.D W12, [W15++]
001998  781F8E     MOV W14, [W15++]
00199A  780680     MOV W0, W13
00199C  780601     MOV W1, W12
00199E  780582     MOV W2, W11
0019A0  780504     MOV W4, W10
245:                   int i;
246:                   int x,y;
247:                   unsigned char c;
248:                   for (i=0;i<width*height;i++){
0019A2  B99A0B     MUL.SS W3, W11, W4
0019A4  780484     MOV W4, W9
0019A6  548FE0     SUB W9, #0x0, [W15]
0019A8  340013     BRA LE, 0x19D0
0019AA  EB0400     CLR W8
0019CA  E80408     INC W8, W8
0019CC  540F89     SUB W8, W9, [W15]
0019CE  35FFEF     BRA LT, 0x19AE
249:                       x=left+i%width;
0019C4  40000D     ADD W0, W13, W0
250:                       y=top+i/width;
0019BC  090011     REPEAT #0x11
0019BE  D8040B     DIV.SW W8, W11
0019C0  FD0080     EXCH W0, W1
0019C2  40808C     ADD W1, W12, W1
251:                       c=*(xbm_bits+(i>>3));
0019AE  DEC243     ASR W8, #3, W4
252:                       if (!(c&(1<<(i&7)))) plot(x,y,WHITE);
0019AC  20001E     MOV #0x1, W14
0019B0  7A426A     MOV.B [W10+W4], W4
0019B2  FB8204     ZE W4, W4
0019B4  6402E7     AND W8, #0x7, W5
0019B6  DEA205     ASR W4, W5, W4
0019B8  620261     AND W4, #0x1, W4
0019BA  3A0007     BRA NZ, 0x19CA
0019C6  78010E     MOV W14, W2
0019C8  07FCCF     RCALL plot
253:                   }//for
254:               }//f()
0019D0  78074F     MOV [--W15], W14
0019D2  BE064F     MOV.D [--W15], W12
0019D4  BE054F     MOV.D [--W15], W10
0019D6  BE044F     MOV.D [--W15], W8
0019D8  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/games/snake/snake.c  ----------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snake.c
21:                 * Author: jacques Deschênes
22:                 * Description: snake game graphics mode
23:                 * Created on 24 mars 2014, 19:28
24:                 */
25:                
26:                #include <time.h>
27:                #include "../../PICvision.h"
28:                
29:                #include "snake.h"
30:                #include "resources/snake_head_down.xbm"
31:                #include "resources/snake_head_up.xbm"
32:                #include "resources/snake_head_left.xbm"
33:                #include "resources/snake_head_right.xbm"
34:                #include "resources/mouse.xbm"
35:                #include "resources/snake_segment.xbm"
36:                
37:                #define HEAD_NORTH  0
38:                #define HEAD_EAST   1
39:                #define HEAD_SOUTH  2
40:                #define HEAD_WEST   3
41:                #define SEGMENT     4
42:                #define MOUSE       5
43:                
44:                #define SPRITE_WIDTH  16
45:                #define SPRITE_HEIGHT 16
46:                
47:                const unsigned char * const sprites[7]={snake_head_up_bits,snake_head_right_bits,
48:                snake_head_down_bits,snake_head_left_bits,snake_segment_bits,mouse_bits};
49:                
50:                
51:                typedef struct symbol{
52:                    unsigned char x;  //{left,top corner coordinates}
53:                    unsigned char y;
54:                    union{
55:                    unsigned char heading;  // direction of displacement
56:                    unsigned char sprite;  // sprites array index
57:                    };
58:                    char spare; // alignement
59:                }symbol_t;
60:                
61:                #define SNAKE_MAX_LEN  32
62:                
63:                typedef struct snake_struct{
64:                    unsigned length;
65:                    unsigned calories;
66:                    unsigned lifespan;
67:                    unsigned speed;
68:                    symbol_t body[SNAKE_MAX_LEN];
69:                }snake_t;
70:                
71:                
72:                
73:                #define BASE_METABOLISM 2   // calories lost per seconde
74:                #define MOUSE_CALORIES  20  // calories gain by eating mouse
75:                
76:                snake_t snake;
77:                
78:                symbol_t mouse;
79:                
80:                int run; // game exit when run==0
81:                
82:                const msg_t msgCALORIES={0,0,"calories: "};
83:                const msg_t msgSECONDS={18,0,"lifespan: "};
84:                const msg_t msgGAME_OVER={6,13,"game over"};
85:                const msg_t msgSTART={8,20, "press START to begin"};
86:                const msg_t msgQUIT={8,21,"X to quit game."};
87:                const msg_t msgSTARVATION={6,14,"died of starvation"};
88:                const msg_t msgWALL_COLLIDE={6,14,"died of wall collision"};
89:                const msg_t msgTAIL_BITE={6,14,"died of tail bite."};
90:                
91:                //REF: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
92:                int isqrt(int num) {
93:                    int res = 0;
94:                    int bit = 1 << 14; // The second-to-top bit is set: 1 << 30 for 32 bits
001B9E  240004     MOV #0x4000, W4
95:                
96:                    // "bit" starts at the highest power of four <= the argument.
97:                    while (bit > num)
001BA0  23FFF5     MOV #0x3FFF, W5
001BA2  500F85     SUB W0, W5, [W15]
001BA4  340002     BRA LE, 0x1BAA
001BAC  500F84     SUB W0, W4, [W15]
001BAE  35FFFD     BRA LT, 0x1BAA
98:                        bit >>= 2;
001BA6  EB0280     CLR W5
001BA8  370007     BRA 0x1BB8
001BAA  DEA242     ASR W4, #2, W4
99:                
100:                   while (bit != 0) {
001BB0  EB0280     CLR W5
001BB2  520FE0     SUB W4, #0x0, [W15]
001BB4  3AFFF8     BRA NZ, 0x1BA6
001BB6  37000A     BRA 0x1BCC
001BCA  3AFFF6     BRA NZ, 0x1BB8
101:                       if (num >= res + bit) {
001BB8  420305     ADD W4, W5, W6
001BBA  530F80     SUB W6, W0, [W15]
001BBC  3C0004     BRA GT, 0x1BC6
102:                           num -= res + bit;
001BBE  500006     SUB W0, W6, W0
103:                           res = (res >> 1) + bit;
001BC0  D18285     ASR W5, W5
001BC2  428284     ADD W5, W4, W5
001BC4  370001     BRA 0x1BC8
104:                       }
105:                       else
106:                           res >>= 1;
001BC6  D18285     ASR W5, W5
107:                       bit >>= 2;
001BC8  DEA242     ASR W4, #2, W4
108:                   }
109:                   return res;
110:               }//f()
001BCC  780005     MOV W5, W0
001BCE  060000     RETURN
111:               
112:               int distance(int x1, int y1, int x2, int y2){
113:                   int dx, dy;
114:                   dx = x1-x2;
001BD0  500002     SUB W0, W2, W0
115:                   dy = y1-y2;
001BD2  508083     SUB W1, W3, W1
116:                   return isqrt(dx*dx+dy*dy);
001BD4  B98A01     MUL.SS W1, W1, W4
001BD6  B98000     MUL.SS W0, W0, W0
001BD8  400004     ADD W0, W4, W0
001BDA  07FFE1     RCALL isqrt
117:               }//f()
001BDC  060000     RETURN
118:               
119:               static void hide_mouse(){
120:                   box((unsigned)mouse.x,(unsigned)mouse.y,SPRITE_WIDTH,SPRITE_HEIGHT,BLACK);
001AC8  21F511     MOV #0x1F51, W1
001ACA  784091     MOV.B [W1], W1
001ACC  FB8081     ZE W1, W1
001ACE  BFDF50     MOV.B mouse, WREG
001AD0  FB8000     ZE W0, W0
001AD2  EB0200     CLR W4
001AD4  200103     MOV #0x10, W3
001AD6  780103     MOV W3, W2
001AD8  07FE9A     RCALL box
121:               }// f()
001ADA  060000     RETURN
122:               
123:               static void new_mouse(){
001BDE  BE9F88     MOV.D W8, [W15++]
001BE0  BE9F8A     MOV.D W10, [W15++]
001BE2  BE9F8C     MOV.D W12, [W15++]
001BE4  781F8E     MOV W14, [W15++]
124:                   unsigned short i, collide,mouseX,mouseY;
125:                   collide=1;
126:                   while (collide){
127:                       mouseX=rand()%(HPIXELS-SPRITE_WIDTH-3)+2;
001BE6  07F4D7     RCALL 0x596
001BE8  200C54     MOV #0xC5, W4
001BEA  780601     MOV W1, W12
001BEC  090011     REPEAT #0x11
001BEE  D80004     DIV.SW W0, W4
001BF0  FD0601     EXCH W1, W12
001BF2  E8860C     INC2 W12, W12
001BF4  78070C     MOV W12, W14
128:                       mouseY=rand()%(HPIXELS-CHAR_HEIGHT-19)+CHAR_HEIGHT+2;
001BF6  07F4CF     RCALL 0x596
001BF8  200BD4     MOV #0xBD, W4
001BFA  780581     MOV W1, W11
001BFC  090011     REPEAT #0x11
001BFE  D80004     DIV.SW W0, W4
001C00  FD0581     EXCH W1, W11
001C02  4585EA     ADD W11, #0xA, W11
001C04  78068B     MOV W11, W13
129:                       for (i=0;i<snake.length;i++){
001C06  80F64A     MOV snake, W10
001C08  550FE0     SUB W10, #0x0, [W15]
001C0A  320011     BRA Z, 0x1C2E
001C0C  21ED18     MOV #0x1ED1, W8
001C0E  EB0480     CLR W9
001C22  E80489     INC W9, W9
001C24  440464     ADD W8, #0x4, W8
001C26  548F8A     SUB W9, W10, [W15]
001C28  39FFF3     BRA NC, 0x1C10
130:                           if (distance(mouseX,mouseY,snake.body[i].x,snake.body[i].y)<SPRITE_WIDTH) break;
001C10  97F978     MOV.B [W8-1], W2
001C12  FB8102     ZE W2, W2
001C14  784018     MOV.B [W8], W0
001C16  FB8180     ZE W0, W3
001C18  78008B     MOV W11, W1
001C1A  78000C     MOV W12, W0
001C1C  07FFD9     RCALL distance
001C1E  500FEF     SUB W0, #0xF, [W15]
001C20  340004     BRA LE, 0x1C2A
131:                       }
132:                       if (i==snake.length) collide=0;
001C2A  550F89     SUB W10, W9, [W15]
001C2C  3AFFDC     BRA NZ, 0x1BE6
133:                   }//while
134:                   mouse.x=mouseX;
001C2E  78000E     MOV W14, W0
001C30  B7FF50     MOV.B WREG, mouse
135:                   mouse.y=mouseY;
001C32  78000D     MOV W13, W0
001C34  B7FF51     MOV.B WREG, 0x1F51
136:                   put_xbm(mouse.x,mouse.y,SPRITE_WIDTH,SPRITE_HEIGHT,sprites[mouse.heading]);
001C36  21F524     MOV #0x1F52, W4
001C38  784214     MOV.B [W4], W4
001C3A  FB8204     ZE W4, W4
001C3C  420204     ADD W4, W4, W4
001C3E  FB808D     ZE W13, W1
001C40  FB800E     ZE W14, W0
001C42  292905     MOV #0x9290, W5
001C44  7A0265     MOV [W5+W4], W4
001C46  200103     MOV #0x10, W3
001C48  780103     MOV W3, W2
001C4A  07FEA3     RCALL put_xbm
137:               }//f()
001C4C  78074F     MOV [--W15], W14
001C4E  BE064F     MOV.D [--W15], W12
001C50  BE054F     MOV.D [--W15], W10
001C52  BE044F     MOV.D [--W15], W8
001C54  060000     RETURN
138:               
139:               static void hide_snake(){
001A90  BE9F88     MOV.D W8, [W15++]
001A92  BE9F8A     MOV.D W10, [W15++]
140:                   unsigned i;
141:                   set_curpos(0,2);
001A94  200021     MOV #0x2, W1
001A96  EB0000     CLR W0
001A98  0703DE     RCALL set_curpos
142:                   for (i=0;i<snake.length;i++){
001A9A  80F644     MOV snake, W4
001A9C  520FE0     SUB W4, #0x0, [W15]
001A9E  320011     BRA Z, 0x1AC2
001AA0  21ED18     MOV #0x1ED1, W8
001AA2  EB0480     CLR W9
001AB8  E80489     INC W9, W9
001ABA  440464     ADD W8, #0x4, W8
001ABC  80F644     MOV snake, W4
001ABE  520F89     SUB W4, W9, [W15]
001AC0  3EFFF3     BRA GTU, 0x1AA8
143:                       box(snake.body[i].x,snake.body[i].y,SPRITE_WIDTH,SPRITE_HEIGHT,BLACK);
001AA4  EB0500     CLR W10
001AA6  20010B     MOV #0x10, W11
001AA8  784218     MOV.B [W8], W4
001AAA  FB8084     ZE W4, W1
001AAC  97F878     MOV.B [W8-1], W0
001AAE  FB8000     ZE W0, W0
001AB0  78020A     MOV W10, W4
001AB2  78018B     MOV W11, W3
001AB4  78010B     MOV W11, W2
001AB6  07FEAB     RCALL box
144:                   }
145:               }//f()
001AC2  BE054F     MOV.D [--W15], W10
001AC4  BE044F     MOV.D [--W15], W8
001AC6  060000     RETURN
146:               
147:               static void show_snake(){
001A42  BE9F88     MOV.D W8, [W15++]
001A44  BE9F8A     MOV.D W10, [W15++]
148:                   unsigned i;
149:                   put_xbm(snake.body[0].x,snake.body[0].y,SPRITE_WIDTH,SPRITE_HEIGHT,
001A46  21ED24     MOV #0x1ED2, W4
001A48  784214     MOV.B [W4], W4
001A4A  FB8204     ZE W4, W4
001A4C  420204     ADD W4, W4, W4
001A4E  21ED11     MOV #0x1ED1, W1
001A50  784091     MOV.B [W1], W1
001A52  FB8081     ZE W1, W1
001A54  BFDED0     MOV.B 0x1ED0, WREG
001A56  FB8000     ZE W0, W0
001A58  292905     MOV #0x9290, W5
001A5A  7A0265     MOV [W5+W4], W4
001A5C  200103     MOV #0x10, W3
001A5E  780103     MOV W3, W2
001A60  07FF98     RCALL put_xbm
150:                           sprites[snake.body[0].heading]);
151:                   for (i=1;i<snake.length;i++){
001A62  80F644     MOV snake, W4
001A64  520FE1     SUB W4, #0x1, [W15]
001A66  360011     BRA LEU, 0x1A8A
001A68  21ED58     MOV #0x1ED5, W8
001A6A  200019     MOV #0x1, W9
001A80  E80489     INC W9, W9
001A82  440464     ADD W8, #0x4, W8
001A84  80F644     MOV snake, W4
001A86  520F89     SUB W4, W9, [W15]
001A88  3EFFF3     BRA GTU, 0x1A70
152:                       put_xbm(snake.body[i].x,snake.body[i].y,SPRITE_WIDTH,SPRITE_HEIGHT,
001A6C  2926FA     MOV #0x926F, W10
001A6E  20010B     MOV #0x10, W11
001A70  784218     MOV.B [W8], W4
001A72  FB8084     ZE W4, W1
001A74  97F878     MOV.B [W8-1], W0
001A76  FB8000     ZE W0, W0
001A78  78020A     MOV W10, W4
001A7A  78018B     MOV W11, W3
001A7C  78010B     MOV W11, W2
001A7E  07FF89     RCALL put_xbm
153:                           sprites[SEGMENT]);
154:                   }//for
155:               }//f()
001A8A  BE054F     MOV.D [--W15], W10
001A8C  BE044F     MOV.D [--W15], W8
001A8E  060000     RETURN
156:               
157:               
158:               static int wait_start_signal(){
0019DA  BE9F88     MOV.D W8, [W15++]
159:                   unsigned p;
160:                   p=0;
161:                   print_msg(msgSTART);
0019DC  849710     MOV 0x92E2, W0
0019DE  849721     MOV 0x92E4, W1
0019E0  070493     RCALL print_msg
162:                   print_msg(msgQUIT);
0019E2  8497B0     MOV 0x92F6, W0
0019E4  8497C1     MOV 0x92F8, W1
0019E6  070490     RCALL print_msg
163:                   while (1){
164:                     p=read_paddle(PADDLE1);
0019E8  200018     MOV #0x1, W8
0019EC  780008     MOV W8, W0
0019EE  0707B3     RCALL read_paddle
165:                     if ((p&SNES_START)==SNES_START){
0019F0  600268     AND W0, #0x8, W4
0019F2  3A0004     BRA NZ, 0x19FC
166:                         return 1;
0019FC  200010     MOV #0x1, W0
167:                     }else if ((p&SNES_X)==SNES_X){
0019EA  202009     MOV #0x200, W9
0019F4  600009     AND W0, W9, W0
0019F6  32FFFA     BRA Z, 0x19EC
168:                         return 0;
0019F8  EB0000     CLR W0
0019FA  370001     BRA 0x19FE
169:                     }
170:                   }
171:               }//f()
0019FE  BE044F     MOV.D [--W15], W8
001A00  060000     RETURN
172:               
173:               static void animate_death(){
001ADC  BE9F88     MOV.D W8, [W15++]
001ADE  BE9F8A     MOV.D W10, [W15++]
001AE0  781F8C     MOV W12, [W15++]
001AEE  E80404     INC W4, W8
001AF0  DD4442     SL W8, #2, W8
001AF2  21EC94     MOV #0x1EC9, W4
001AF4  440404     ADD W8, W4, W8
174:                   int i,freq;
175:                   show_snake();
001AE2  07FFAF     RCALL show_snake
176:                   freq=snake.length*200;
001AE4  80F644     MOV snake, W4
001AEA  200C8A     MOV #0xC8, W10
001AEC  B9A50A     MUL.SS W4, W10, W10
177:                   for (i=snake.length-1;i>=0;i--){
001AE6  E90484     DEC W4, W9
001AE8  33001B     BRA N, 0x1B20
001B18  E90489     DEC W9, W9
001B1A  540464     SUB W8, #0x4, W8
001B1C  548FE0     SUB W9, #0x0, [W15]
001B1E  3DFFED     BRA GE, 0x1AFA
178:                       box(snake.body[i].x,snake.body[i].y,SPRITE_WIDTH,SPRITE_HEIGHT,BLACK);
001AF6  EB0580     CLR W11
001AFA  784218     MOV.B [W8], W4
001AFC  FB8084     ZE W4, W1
001AFE  97F878     MOV.B [W8-1], W0
001B00  FB8000     ZE W0, W0
001B02  78020B     MOV W11, W4
001B04  200103     MOV #0x10, W3
001B06  780103     MOV W3, W2
001B08  07FE82     RCALL box
179:                       tone(freq,250);
001AF8  200FAC     MOV #0xFA, W12
001B0A  78008C     MOV W12, W1
001B0C  78000A     MOV W10, W0
001B0E  0705DD     RCALL tone
180:                       wait_n_frame(frames_per_second/4);
001B10  80FCF0     MOV frames_per_second, W0
001B12  DE0042     LSR W0, #2, W0
001B14  07052D     RCALL wait_n_frame
181:                       freq -= 100;
001B16  B1064A     SUB #0x64, W10
182:                   }//for
183:               }//f()
001B20  78064F     MOV [--W15], W12
001B22  BE054F     MOV.D [--W15], W10
001B24  BE044F     MOV.D [--W15], W8
001B26  060000     RETURN
184:               
185:               // dead cause
186:               typedef enum DEATH {STARVATION,WALL_COLLISION,TAIL_BITE} death_t;
187:               
188:               static unsigned char reset=0;
189:               static void game_over(death_t cause){
001B28  781F88     MOV W8, [W15++]
001B2A  780400     MOV W0, W8
190:                   animate_death();
001B2C  07FFD7     RCALL animate_death
191:                   print_msg(msgGAME_OVER);
001B2E  849640     MOV 0x92C8, W0
001B30  849651     MOV 0x92CA, W1
001B32  0703EA     RCALL print_msg
192:                   switch (cause){
001B34  540FE1     SUB W8, #0x1, [W15]
001B36  320008     BRA Z, 0x1B48
001B38  390003     BRA NC, 0x1B40
001B3A  540FE2     SUB W8, #0x2, [W15]
001B3C  3A000C     BRA NZ, 0x1B56
001B3E  370008     BRA 0x1B50
193:                       case STARVATION:
194:                           print_msg(msgSTARVATION);
001B40  849870     MOV 0x930E, W0
001B42  849881     MOV 0x9310, W1
001B44  0703E1     RCALL print_msg
195:                           break;
001B46  370007     BRA 0x1B56
196:                       case WALL_COLLISION:
197:                           print_msg(msgWALL_COLLIDE);
001B48  849950     MOV 0x932A, W0
001B4A  849961     MOV 0x932C, W1
001B4C  0703DD     RCALL print_msg
198:                           break;
001B4E  370003     BRA 0x1B56
199:                       case TAIL_BITE:
200:                           print_msg(msgTAIL_BITE);
001B50  849A10     MOV 0x9342, W0
001B52  849A21     MOV 0x9344, W1
001B54  0703D9     RCALL print_msg
201:                           break;
202:                   }//switch
203:                   reset=1;
001B56  B3C014     MOV #0x1, W4
001B58  FD0200     EXCH W0, W4
001B5A  B7FF56     MOV.B WREG, reset
001B5C  FD0200     EXCH W0, W4
204:                   if (!wait_start_signal()) run=0;
001B5E  07FF3D     RCALL wait_start_signal
001B60  500FE0     SUB W0, #0x0, [W15]
001B62  3A0001     BRA NZ, 0x1B66
001B64  EF3F54     CLR run
205:               }//f()
001B66  78044F     MOV [--W15], W8
001B68  060000     RETURN
206:               
207:               static void add_calories(unsigned short gain){
208:                   snake.calories+=gain;
001A32  B43ECA     ADD 0x1ECA
209:                   print_msg(msgCALORIES);
001A34  849550     MOV 0x92AA, W0
001A36  849561     MOV 0x92AC, W1
001A38  070467     RCALL print_msg
210:                   print_int(snake.calories,1);
001A3A  200011     MOV #0x1, W1
001A3C  80F650     MOV 0x1ECA, W0
001A3E  0703B3     RCALL print_int
211:               }//f()
001A40  060000     RETURN
212:               
213:               
214:               static void burn_calories(unsigned short lost){
215:                   if (lost < BASE_METABOLISM) lost=BASE_METABOLISM;
001B6A  500FE1     SUB W0, #0x1, [W15]
001B6C  3E0001     BRA GTU, 0x1B70
001B6E  200020     MOV #0x2, W0
216:                   snake.calories -= lost;
001B70  B53ECA     SUB 0x1ECA
217:                   if (snake.calories<0) snake.calories=0;
218:                   print_msg(msgCALORIES);
001B72  849550     MOV 0x92AA, W0
001B74  849561     MOV 0x92AC, W1
001B76  0703C8     RCALL print_msg
219:                   clear_eol();
001B78  07034D     RCALL clear_eol
220:                   print_int(snake.calories,1);
001B7A  200011     MOV #0x1, W1
001B7C  80F650     MOV 0x1ECA, W0
001B7E  070313     RCALL print_int
221:                   print_msg(msgSECONDS);
001B80  8495D0     MOV 0x92BA, W0
001B82  8495E1     MOV 0x92BC, W1
001B84  0703C1     RCALL print_msg
222:                   print_int(snake.lifespan,1);
001B86  200011     MOV #0x1, W1
001B88  80F660     MOV 0x1ECC, W0
001B8A  07030D     RCALL print_int
223:                   hide_snake();
001B8C  07FF81     RCALL hide_snake
224:                   if (snake.calories){
001B8E  80F654     MOV 0x1ECA, W4
001B90  520FE0     SUB W4, #0x0, [W15]
001B92  320002     BRA Z, 0x1B98
225:                       show_snake();
001B94  07FF56     RCALL show_snake
001B96  370002     BRA 0x1B9C
226:                   } else{
227:                       game_over(STARVATION);
001B98  EB0000     CLR W0
001B9A  07FFC6     RCALL game_over
228:                   }
229:               }//f()
001B9C  060000     RETURN
230:               
231:               static void check_if_got_mouse(){
232:                   if (distance(mouse.x,mouse.y,snake.body[0].x,snake.body[0].y)<SPRITE_WIDTH){
001D5C  21ED02     MOV #0x1ED0, W2
001D5E  784112     MOV.B [W2], W2
001D60  FB8102     ZE W2, W2
001D62  21F511     MOV #0x1F51, W1
001D64  784091     MOV.B [W1], W1
001D66  FB8081     ZE W1, W1
001D68  BFDF50     MOV.B mouse, WREG
001D6A  FB8000     ZE W0, W0
001D6C  21ED13     MOV #0x1ED1, W3
001D6E  784193     MOV.B [W3], W3
001D70  FB8183     ZE W3, W3
001D72  07FF2E     RCALL distance
001D74  500FEF     SUB W0, #0xF, [W15]
001D76  3C001E     BRA GT, 0x1DB4
233:                       hide_mouse();
001D78  07FEA7     RCALL hide_mouse
234:                       tone(100,100);
001D7A  200641     MOV #0x64, W1
001D7C  780001     MOV W1, W0
001D7E  0704A5     RCALL tone
235:                       add_calories(MOUSE_CALORIES);
001D80  200140     MOV #0x14, W0
001D82  07FE57     RCALL add_calories
236:                       if (snake.length<SNAKE_MAX_LEN){
001D84  80F644     MOV snake, W4
001D86  520FFF     SUB W4, #0x1F, [W15]
001D88  3E0010     BRA GTU, 0x1DAA
237:                           snake.length++;
001D8A  E80304     INC W4, W6
001D8C  88F646     MOV W6, snake
238:                           snake.body[snake.length-1].heading=snake.body[snake.length-2].heading;
001D8E  DD23C2     SL W4, #2, W7
001D90  4380E6     ADD W7, #0x6, W1
001D92  21EC85     MOV #0x1EC8, W5
001D94  42806A     ADD W5, #0xA, W0
001D96  78C0E5     MOV.B [W5+W1], W1
001D98  7BF001     MOV.B W1, [W0+W7]
239:                           snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001D9A  E88204     INC2 W4, W4
001D9C  DD2242     SL W4, #2, W4
001D9E  428204     ADD W5, W4, W4
001DA0  DD3342     SL W6, #2, W6
001DA2  7B4A65     MOV.B [W5+W6], [W4]
240:                           snake.body[snake.length-1].y=snake.body[snake.length-2].y;
001DA4  428286     ADD W5, W6, W5
001DA6  904295     MOV.B [W5+1], W5
001DA8  984215     MOV.B W5, [W4+1]
241:                       }
242:                       while_sound();
001DAA  0704E3     RCALL while_sound
243:                       tone(64,100);
001DAC  200641     MOV #0x64, W1
001DAE  200400     MOV #0x40, W0
001DB0  07048C     RCALL tone
244:                       new_mouse();
001DB2  07FF15     RCALL new_mouse
245:                   }//if
246:               }//f()
001DB4  060000     RETURN
247:               
248:               static int bit_himself(){
001D16  BE9F88     MOV.D W8, [W15++]
001D18  BE9F8A     MOV.D W10, [W15++]
001D1A  781F8C     MOV W12, [W15++]
249:                   int i;
250:                   for (i=3;i<snake.length;i++){
001D1C  80F64A     MOV snake, W10
001D20  550FE3     SUB W10, #0x3, [W15]
001D22  360018     BRA LEU, 0x1D54
001D32  200039     MOV #0x3, W9
001D46  E80489     INC W9, W9
001D48  440464     ADD W8, #0x4, W8
001D4A  550F89     SUB W10, W9, [W15]
001D4C  3EFFF3     BRA GTU, 0x1D34
251:                       if (distance(snake.body[0].x,snake.body[0].y,snake.body[i].x,snake.body[i].y)<SPRITE_WIDTH){
001D24  21ED1B     MOV #0x1ED1, W11
001D26  78459B     MOV.B [W11], W11
001D28  FB858B     ZE W11, W11
001D2A  21ED0C     MOV #0x1ED0, W12
001D2C  78461C     MOV.B [W12], W12
001D2E  FB860C     ZE W12, W12
001D30  21EDD8     MOV #0x1EDD, W8
001D34  97F978     MOV.B [W8-1], W2
001D36  FB8102     ZE W2, W2
001D38  784218     MOV.B [W8], W4
001D3A  FB8184     ZE W4, W3
001D3C  78008B     MOV W11, W1
001D3E  78000C     MOV W12, W0
001D40  07FF47     RCALL distance
001D42  500FEF     SUB W0, #0xF, [W15]
001D44  340006     BRA LE, 0x1D52
252:                           return 1;
001D52  200010     MOV #0x1, W0
253:                       }
254:                   }
255:                   return 0;
001D1E  EB0000     CLR W0
001D4E  EB0000     CLR W0
001D50  370001     BRA 0x1D54
256:               }//f()
001D54  78064F     MOV [--W15], W12
001D56  BE054F     MOV.D [--W15], W10
001D58  BE044F     MOV.D [--W15], W8
001D5A  060000     RETURN
257:               
258:               static void move_snake(){
001DBE  DD2242     SL W4, #2, W4
001DC0  21EC85     MOV #0x1EC8, W5
001DC2  420205     ADD W4, W5, W4
001DC4  4282E4     ADD W5, #0x4, W5
259:                   unsigned i;
260:               
261:                   hide_snake();
001DB6  07FE6C     RCALL hide_snake
262:                   for (i=snake.length-1;i;i--){
001DB8  80F644     MOV snake, W4
001DBA  520FE1     SUB W4, #0x1, [W15]
001DBC  32000D     BRA Z, 0x1DD8
001DD4  520F85     SUB W4, W5, [W15]
001DD6  3AFFF7     BRA NZ, 0x1DC6
263:                       snake.body[i].x = snake.body[i-1].x;
001DC6  784314     MOV.B [W4], W6
001DC8  984246     MOV.B W6, [W4+4]
264:                       snake.body[i].y = snake.body[i-1].y;
001DCA  904314     MOV.B [W4+1], W6
001DCC  984256     MOV.B W6, [W4+5]
265:                       snake.body[i].heading = snake.body[i-1].heading;
001DCE  904324     MOV.B [W4+2], W6
001DD0  984266     MOV.B W6, [W4+6]
001DD2  520264     SUB W4, #0x4, W4
266:                   }
267:                   switch (snake.body[0].heading){
001DD8  21ED24     MOV #0x1ED2, W4
001DDA  784214     MOV.B [W4], W4
001DDC  FB8204     ZE W4, W4
001DDE  200005     MOV #0x0, W5
001DE0  520FE3     SUB W4, #0x3, [W15]
001DE2  5A8FE0     SUBB W5, #0x0, [W15]
001DE4  3E0047     BRA GTU, 0x1E74
001DE6  016004     BRA W4
001DE8  370003     BRA 0x1DF0
001DEA  370013     BRA 0x1E12
001DEC  370024     BRA 0x1E36
001DEE  370035     BRA 0x1E5A
268:                       case HEAD_NORTH:
269:                           if (snake.body[0].y>=snake.speed+CHAR_HEIGHT)
001DF0  21ED15     MOV #0x1ED1, W5
001DF2  784295     MOV.B [W5], W5
001DF4  80F674     MOV 0x1ECE, W4
001DF6  FB8385     ZE W5, W7
001DF8  420368     ADD W4, #0x8, W6
001DFA  538F86     SUB W7, W6, [W15]
001DFC  390005     BRA NC, 0x1E08
270:                               snake.body[0].y -= snake.speed;
001DFE  52C204     SUB.B W5, W4, W4
001E00  FD0200     EXCH W0, W4
001E02  B7FED1     MOV.B WREG, 0x1ED1
001E04  FD0200     EXCH W0, W4
001E06  370036     BRA 0x1E74
271:                           else
272:                               snake.body[0].y=CHAR_HEIGHT;
001E08  B3C084     MOV #0x8, W4
001E0A  FD0200     EXCH W0, W4
001E0C  B7FED1     MOV.B WREG, 0x1ED1
001E0E  FD0200     EXCH W0, W4
001E10  370031     BRA 0x1E74
273:                           break;
274:                       case HEAD_EAST:
275:                           if (snake.body[0].x<HPIXELS-SPRITE_WIDTH-snake.speed)
001E12  21ED05     MOV #0x1ED0, W5
001E14  784295     MOV.B [W5], W5
001E16  80F674     MOV 0x1ECE, W4
001E18  FB8385     ZE W5, W7
001E1A  200C86     MOV #0xC8, W6
001E1C  530304     SUB W6, W4, W6
001E1E  538F86     SUB W7, W6, [W15]
001E20  310005     BRA C, 0x1E2C
276:                               snake.body[0].x += snake.speed;
001E22  42C204     ADD.B W5, W4, W4
001E24  FD0200     EXCH W0, W4
001E26  B7FED0     MOV.B WREG, 0x1ED0
001E28  FD0200     EXCH W0, W4
001E2A  370024     BRA 0x1E74
277:                           else
278:                               snake.body[0].x=HPIXELS-SPRITE_WIDTH;
001E2C  B3CC84     MOV #0xC8, W4
001E2E  FD0200     EXCH W0, W4
001E30  B7FED0     MOV.B WREG, 0x1ED0
001E32  FD0200     EXCH W0, W4
001E34  37002A     BRA 0x1E8A
279:                           break;
280:                       case HEAD_SOUTH:
281:                           if (snake.body[0].y<VPIXELS-SPRITE_HEIGHT-snake.speed)
001E36  21ED15     MOV #0x1ED1, W5
001E38  784295     MOV.B [W5], W5
001E3A  80F674     MOV 0x1ECE, W4
001E3C  FB8385     ZE W5, W7
001E3E  200C86     MOV #0xC8, W6
001E40  530304     SUB W6, W4, W6
001E42  538F86     SUB W7, W6, [W15]
001E44  310005     BRA C, 0x1E50
282:                               snake.body[0].y += snake.speed;
001E46  42C204     ADD.B W5, W4, W4
001E48  FD0200     EXCH W0, W4
001E4A  B7FED1     MOV.B WREG, 0x1ED1
001E4C  FD0200     EXCH W0, W4
001E4E  370012     BRA 0x1E74
283:                           else
284:                               snake.body[0].y=VPIXELS-SPRITE_HEIGHT;
001E50  B3CC84     MOV #0xC8, W4
001E52  FD0200     EXCH W0, W4
001E54  B7FED1     MOV.B WREG, 0x1ED1
001E56  FD0200     EXCH W0, W4
001E58  37000D     BRA 0x1E74
285:                           break;
286:                       case HEAD_WEST:
287:                           if (snake.body[0].x>=snake.speed)
001E5A  21ED05     MOV #0x1ED0, W5
001E5C  784295     MOV.B [W5], W5
001E5E  80F674     MOV 0x1ECE, W4
001E60  FB8305     ZE W5, W6
001E62  530F84     SUB W6, W4, [W15]
001E64  390005     BRA NC, 0x1E70
288:                               snake.body[0].x -= snake.speed;
001E66  52C204     SUB.B W5, W4, W4
001E68  FD0200     EXCH W0, W4
001E6A  B7FED0     MOV.B WREG, 0x1ED0
001E6C  FD0200     EXCH W0, W4
001E6E  370002     BRA 0x1E74
289:                           else
290:                               snake.body[0].x=0;
001E70  EF7ED0     CLR.B 0x1ED0
001E72  37000B     BRA 0x1E8A
291:                           break;
292:                   }//switch
293:                   if ((snake.body[0].x<1)||(snake.body[0].x>=(HPIXELS-SPRITE_WIDTH)) ||
001E74  ED5ED0     DEC.B 0x1ED0, WREG
001E76  B3CC64     MOV #0xC6, W4
001E78  504F84     SUB.B W0, W4, [W15]
001E7A  3E0007     BRA GTU, 0x1E8A
001E80  524FE9     SUB.B W4, #0x9, [W15]
001E82  360003     BRA LEU, 0x1E8A
294:                       (snake.body[0].y<CHAR_HEIGHT+2) || (snake.body[0].y>=VPIXELS-SPRITE_HEIGHT)){
001E7C  21ED14     MOV #0x1ED1, W4
001E7E  784214     MOV.B [W4], W4
001E84  B3CC75     MOV #0xC7, W5
001E86  524F85     SUB.B W4, W5, [W15]
001E88  360003     BRA LEU, 0x1E90
295:                       game_over(WALL_COLLISION);
001E8A  200010     MOV #0x1, W0
001E8C  07FE4D     RCALL game_over
001E8E  370008     BRA 0x1EA0
296:                   }else if (bit_himself()){
001E90  07FF42     RCALL bit_himself
001E92  500FE0     SUB W0, #0x0, [W15]
001E94  320003     BRA Z, 0x1E9C
297:                       game_over(TAIL_BITE);
001E96  200020     MOV #0x2, W0
001E98  07FE47     RCALL game_over
001E9A  370002     BRA 0x1EA0
298:                   }else{
299:                       check_if_got_mouse();
001E9C  07FF5F     RCALL check_if_got_mouse
300:                       show_snake();
001E9E  07FDD1     RCALL show_snake
301:                   }//if
302:               }//f()
001EA0  060000     RETURN
303:               
304:               static void game_info(){
305:                   clear_screen();
001A02  0703A5     RCALL clear_screen
306:                   print("**************\r");
001A04  290BA0     MOV #0x90BA, W0
001A06  0703AA     RCALL print
307:                   print("* SNAKE GAME *\r");
001A08  290CA0     MOV #0x90CA, W0
001A0A  0703A8     RCALL print
308:                   print("**************\r\r");
001A0C  290DA0     MOV #0x90DA, W0
001A0E  0703A6     RCALL print
309:                   print("Eating a mouse increase snake length.\r");
001A10  290EB0     MOV #0x90EB, W0
001A12  0703A4     RCALL print
310:                   print("Snake burn 10% of is calaries/sec.\r");
001A14  291120     MOV #0x9112, W0
001A16  0703A2     RCALL print
311:                   print("Die of starvation when calories=0.\r");
001A18  291360     MOV #0x9136, W0
001A1A  0703A0     RCALL print
312:                   print("Eating a mouse give 20 calories.\r");
001A1C  2915A0     MOV #0x915A, W0
001A1E  07039E     RCALL print
313:                   print("Die when hitting wall.\r");
001A20  2917C0     MOV #0x917C, W0
001A22  07039C     RCALL print
314:                   print("Die when bitting his tail.\r\r");
001A24  291940     MOV #0x9194, W0
001A26  07039A     RCALL print
315:                   print("Use ARROWS to control snake.\r");
001A28  291B10     MOV #0x91B1, W0
001A2A  070398     RCALL print
316:                   run=wait_start_signal();
001A2C  07FFD6     RCALL wait_start_signal
001A2E  88FAA0     MOV W0, run
317:               }//f()
001A30  060000     RETURN
318:               
319:               static void game_init(){
320:                   reset=0;
001C56  EF7F56     CLR.B reset
321:                   srand(time(0));
001C58  EB0000     CLR W0
001C5A  07F320     RCALL 0x29C
001C5C  07F495     RCALL 0x588
322:                   //snake initialisation
323:                   snake.length=2;
001C5E  200024     MOV #0x2, W4
001C60  88F644     MOV W4, snake
324:                   snake.calories=MOUSE_CALORIES;
001C62  200144     MOV #0x14, W4
001C64  88F654     MOV W4, 0x1ECA
325:                   snake.lifespan=0;
001C66  EF3ECC     CLR 0x1ECC
326:                   snake.speed=16;
001C68  200104     MOV #0x10, W4
001C6A  88F674     MOV W4, 0x1ECE
327:                   snake.body[0].x=100;
001C6C  B3C644     MOV #0x64, W4
001C6E  FD0200     EXCH W0, W4
001C70  B7FED0     MOV.B WREG, 0x1ED0
001C72  B7FED1     MOV.B WREG, 0x1ED1
001C74  FD0200     EXCH W0, W4
328:                   snake.body[0].y=100;
329:                   snake.body[0].heading=rand()%4;
001C76  07F48F     RCALL 0x596
001C78  200044     MOV #0x4, W4
001C7A  781F81     MOV W1, [W15++]
001C7C  090011     REPEAT #0x11
001C7E  D80004     DIV.SW W0, W4
001C80  780201     MOV W1, W4
001C82  7800CF     MOV [--W15], W1
001C84  FD0200     EXCH W0, W4
001C86  B7FED2     MOV.B WREG, 0x1ED2
001C88  B7FED6     MOV.B WREG, 0x1ED6
001C8A  FD0200     EXCH W0, W4
330:                   snake.body[1].heading=snake.body[0].heading;
331:                   switch(snake.body[0].heading){
001C8C  FB8204     ZE W4, W4
001C8E  200005     MOV #0x0, W5
001C90  520FE3     SUB W4, #0x3, [W15]
001C92  5A8FE0     SUBB W5, #0x0, [W15]
001C94  3E0026     BRA GTU, 0x1CE2
001C96  016004     BRA W4
001C98  370003     BRA 0x1CA0
001C9A  37000B     BRA 0x1CB2
001C9C  370012     BRA 0x1CC2
001C9E  37001A     BRA 0x1CD4
332:                       case HEAD_NORTH:
333:                           snake.body[1].x=snake.body[0].x;
001CA0  BFDED0     MOV.B 0x1ED0, WREG
001CA2  B7FED4     MOV.B WREG, 0x1ED4
334:                           snake.body[1].y=snake.body[0].y+SPRITE_HEIGHT;
001CA4  21ED14     MOV #0x1ED1, W4
001CA6  784214     MOV.B [W4], W4
001CA8  424270     ADD.B W4, #0x10, W4
001CAA  FD0200     EXCH W0, W4
001CAC  B7FED5     MOV.B WREG, 0x1ED5
001CAE  FD0200     EXCH W0, W4
335:                           break;
001CB0  370018     BRA 0x1CE2
336:                       case HEAD_EAST:
337:                           snake.body[1].x=snake.body[0].x-SPRITE_WIDTH;
001CB2  21ED04     MOV #0x1ED0, W4
001CB4  784214     MOV.B [W4], W4
001CB6  524270     SUB.B W4, #0x10, W4
001CB8  780004     MOV W4, W0
001CBA  B7FED4     MOV.B WREG, 0x1ED4
338:                           snake.body[1].y=snake.body[0].y;
001CBC  BFDED1     MOV.B 0x1ED1, WREG
001CBE  B7FED5     MOV.B WREG, 0x1ED5
339:                           break;
001CC0  370010     BRA 0x1CE2
340:                       case HEAD_SOUTH:
341:                           snake.body[1].x=snake.body[0].x;
001CC2  BFDED0     MOV.B 0x1ED0, WREG
001CC4  B7FED4     MOV.B WREG, 0x1ED4
342:                           snake.body[1].y=snake.body[0].y-SPRITE_HEIGHT;
001CC6  21ED14     MOV #0x1ED1, W4
001CC8  784214     MOV.B [W4], W4
001CCA  524270     SUB.B W4, #0x10, W4
001CCC  FD0200     EXCH W0, W4
001CCE  B7FED5     MOV.B WREG, 0x1ED5
001CD0  FD0200     EXCH W0, W4
343:                           break;
001CD2  370007     BRA 0x1CE2
344:                       case HEAD_WEST:
345:                           snake.body[1].x=snake.body[0].x+SPRITE_WIDTH;
001CD4  21ED04     MOV #0x1ED0, W4
001CD6  784214     MOV.B [W4], W4
001CD8  424270     ADD.B W4, #0x10, W4
001CDA  780004     MOV W4, W0
001CDC  B7FED4     MOV.B WREG, 0x1ED4
346:                           snake.body[1].y=snake.body[0].y;
001CDE  BFDED1     MOV.B 0x1ED1, WREG
001CE0  B7FED5     MOV.B WREG, 0x1ED5
347:                           break;
348:                   }//switch
349:                   mouse.sprite=MOUSE;
001CE2  B3C054     MOV #0x5, W4
001CE4  FD0200     EXCH W0, W4
001CE6  B7FF52     MOV.B WREG, 0x1F52
001CE8  FD0200     EXCH W0, W4
350:                   clear_screen();
001CEA  070231     RCALL clear_screen
351:                   print_msg(msgCALORIES);
001CEC  849550     MOV 0x92AA, W0
001CEE  849561     MOV 0x92AC, W1
001CF0  07030B     RCALL print_msg
352:                   print_int(snake.calories,1);
001CF2  200011     MOV #0x1, W1
001CF4  80F650     MOV 0x1ECA, W0
001CF6  070257     RCALL print_int
353:                   print_msg(msgSECONDS);
001CF8  8495D0     MOV 0x92BA, W0
001CFA  8495E1     MOV 0x92BC, W1
001CFC  070305     RCALL print_msg
354:                   print_int(snake.lifespan,1);
001CFE  200011     MOV #0x1, W1
001D00  80F660     MOV 0x1ECC, W0
001D02  070251     RCALL print_int
355:                   //draw  borders
356:                   rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001D04  200014     MOV #0x1, W4
001D06  200D73     MOV #0xD7, W3
001D08  780103     MOV W3, W2
001D0A  200081     MOV #0x8, W1
001D0C  EB0000     CLR W0
001D0E  07FBBD     RCALL rectangle
357:                   new_mouse();
001D10  07FF66     RCALL new_mouse
358:                   show_snake();
001D12  07FE97     RCALL show_snake
359:               }//f()
001D14  060000     RETURN
360:               
361:               
362:               void snake_game(void) {
001EA2  BE9F88     MOV.D W8, [W15++]
001EA4  781F8A     MOV W10, [W15++]
363:                   unsigned p,frame_count;
364:                   game_info();
001EA6  07FDAD     RCALL game_info
365:                   reset=1;
001EA8  B3C014     MOV #0x1, W4
001EAA  FD0200     EXCH W0, W4
001EAC  B7FF56     MOV.B WREG, reset
001EAE  FD0200     EXCH W0, W4
366:                   frame_count=0;
001EB6  EB0400     CLR W8
367:                   while (run){
001EB0  80FAA4     MOV run, W4
001EB2  520FE0     SUB W4, #0x0, [W15]
001EB4  320053     BRA Z, 0x1F5C
001F56  80FAA4     MOV run, W4
001F58  520FE0     SUB W4, #0x0, [W15]
001F5A  3AFFB0     BRA NZ, 0x1EBC
368:                       if (reset) game_init();
001EBC  21F564     MOV #0x1F56, W4
001EBE  784214     MOV.B [W4], W4
001EC0  524FE0     SUB.B W4, #0x0, [W15]
001EC2  320001     BRA Z, 0x1EC6
001EC4  07FEC8     RCALL game_init
369:                       wait_n_frame(10);
001EC6  2000A0     MOV #0xA, W0
001EC8  070353     RCALL wait_n_frame
370:                       frame_count += 10;
001ECA  44046A     ADD W8, #0xA, W8
371:                       if (frame_count%frames_per_second==0){
001ECC  80FCF4     MOV frames_per_second, W4
001ECE  BE9F80     MOV.D W0, [W15++]
001ED0  090011     REPEAT #0x11
001ED2  D88404     DIV.UW W8, W4
001ED4  780201     MOV W1, W4
001ED6  BE004F     MOV.D [--W15], W0
001ED8  520FE0     SUB W4, #0x0, [W15]
001EDA  3A000E     BRA NZ, 0x1EF8
372:                           snake.lifespan +=1;
001EDC  EC3ECC     INC 0x1ECC
373:                           burn_calories(snake.calories / 10);
001EDE  80F650     MOV 0x1ECA, W0
001EE0  2000A4     MOV #0xA, W4
001EE2  781F81     MOV W1, [W15++]
001EE4  090011     REPEAT #0x11
001EE6  D88004     DIV.UW W0, W4
001EE8  7800CF     MOV [--W15], W1
001EEA  07FE3F     RCALL burn_calories
374:                           rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001EEC  200014     MOV #0x1, W4
001EEE  200D73     MOV #0xD7, W3
001EF0  780103     MOV W3, W2
001EF2  200081     MOV #0x8, W1
001EF4  EB0000     CLR W0
001EF6  07FAC9     RCALL rectangle
375:                       }
376:                       p=read_paddle(PADDLE1);
001EF8  200010     MOV #0x1, W0
001EFA  07052D     RCALL read_paddle
377:                       switch (p){
001EB8  200209     MOV #0x20, W9
001EBA  20040A     MOV #0x40, W10
001EFC  500F89     SUB W0, W9, [W15]
001EFE  320022     BRA Z, 0x1F44
001F00  3E0003     BRA GTU, 0x1F08
001F02  500FF0     SUB W0, #0x10, [W15]
001F04  3A0027     BRA NZ, 0x1F54
001F06  370018     BRA 0x1F38
001F08  500F8A     SUB W0, W10, [W15]
001F0A  320004     BRA Z, 0x1F14
001F0C  200804     MOV #0x80, W4
001F0E  500F84     SUB W0, W4, [W15]
001F10  3A0021     BRA NZ, 0x1F54
001F12  370009     BRA 0x1F26
378:                           case SNES_LEFT:
379:                               if (snake.body[0].heading==HEAD_EAST){
001F14  21ED24     MOV #0x1ED2, W4
001F16  784214     MOV.B [W4], W4
001F18  524FE1     SUB.B W4, #0x1, [W15]
001F1A  32001C     BRA Z, 0x1F54
380:                                   break;
381:                               }
382:                               snake.body[0].heading =HEAD_WEST;
001F1C  B3C034     MOV #0x3, W4
001F1E  FD0200     EXCH W0, W4
001F20  B7FED2     MOV.B WREG, 0x1ED2
001F22  FD0200     EXCH W0, W4
383:                               break;
001F24  370017     BRA 0x1F54
384:                           case SNES_RIGHT:
385:                               if (snake.body[0].heading==HEAD_WEST){
001F26  21ED24     MOV #0x1ED2, W4
001F28  784214     MOV.B [W4], W4
001F2A  524FE3     SUB.B W4, #0x3, [W15]
001F2C  320013     BRA Z, 0x1F54
386:                                   break;
387:                               }
388:                               snake.body[0].heading=HEAD_EAST;
001F2E  B3C014     MOV #0x1, W4
001F30  FD0200     EXCH W0, W4
001F32  B7FED2     MOV.B WREG, 0x1ED2
001F34  FD0200     EXCH W0, W4
389:                               break;
001F36  37000E     BRA 0x1F54
390:                           case SNES_UP:
391:                               if (snake.body[0].heading==HEAD_SOUTH){
001F38  21ED24     MOV #0x1ED2, W4
001F3A  784214     MOV.B [W4], W4
001F3C  524FE2     SUB.B W4, #0x2, [W15]
001F3E  32000A     BRA Z, 0x1F54
392:                                   break;
393:                               }
394:                               snake.body[0].heading=HEAD_NORTH;
001F40  EF7ED2     CLR.B 0x1ED2
395:                               break;
001F42  370008     BRA 0x1F54
396:                           case SNES_DOWN:
397:                               if (snake.body[0].heading==HEAD_NORTH){
001F44  21ED24     MOV #0x1ED2, W4
001F46  784214     MOV.B [W4], W4
001F48  524FE0     SUB.B W4, #0x0, [W15]
001F4A  320004     BRA Z, 0x1F54
398:                                   break;
399:                               }
400:                               snake.body[0].heading=HEAD_SOUTH;
001F4C  B3C024     MOV #0x2, W4
001F4E  FD0200     EXCH W0, W4
001F50  B7FED2     MOV.B WREG, 0x1ED2
001F52  FD0200     EXCH W0, W4
401:                               break;
402:                       }//switch
403:                       move_snake();
001F54  07FF30     RCALL move_snake
404:                   }//while
405:                   clear_screen();
001F5C  0700F8     RCALL clear_screen
406:               }//snake_game_gm()
001F5E  78054F     MOV [--W15], W10
001F60  BE044F     MOV.D [--W15], W8
001F62  060000     RETURN
407:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/audio/sound.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   sound.c
21:                 * Author: jacques Deschênes
22:                 * Description:  sound generation using PWM D.A.C.
23:                 * Created on 25 février 2014, 16:43
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include "sound.h"
28:                
29:                #define F_TONE  1  // tone playing flag
30:                #define F_TUNE  2  // flag tune playing
31:                #define F_WHITE 4  // white noise generation
32:                
33:                #define mTone_off() (AUDIOCON.OCM=0)
34:                #define mTone_on()  (AUDIOCON.OCM=5)
35:                
36:                
37:                static volatile unsigned char fSound=0; // boolean flags
38:                static volatile int tmrId;  // duratio timer identifier
39:                const unsigned  *  tones_list;  // list of tones and interval for playing tune
40:                static int tick_msec=10; // tick interval in milliseconds, default 10msec.
41:                
42:                void cb_tone(void){ // timer call back function
43:                    mTone_off();
002692  800C54     MOV OC2CON, W4
002694  A10004     BCLR W4, #0
002696  A11004     BCLR W4, #1
002698  A12004     BCLR W4, #2
00269A  880C54     MOV W4, OC2CON
44:                    fSound &= ~(F_TONE|F_WHITE);
00269C  21FB65     MOV #0x1FB6, W5
00269E  784295     MOV.B [W5], W5
0026A0  B3CFA4     MOV #0xFA, W4
0026A2  62C204     AND.B W5, W4, W4
0026A4  780004     MOV W4, W0
0026A6  B7FFB6     MOV.B WREG, fSound
45:                }// f()
0026A8  060000     RETURN
46:                
47:                void sound_init(int tick_time){
48:                    if (tick_time) tick_msec=tick_time;
0026AA  500FE0     SUB W0, #0x0, [W15]
0026AC  320001     BRA Z, 0x26B0
0026AE  88FDD0     MOV W0, tick_msec
49:                    tmrId=create_timer(1,TIMER_SINGLE,(timer_handler_t *)cb_tone);
0026B0  226922     MOV #0x2692, W2
0026B2  EB0080     CLR W1
0026B4  200010     MOV #0x1, W0
0026B6  07FE83     RCALL create_timer
0026B8  88FDC0     MOV W0, tmrId
50:                    AUDIOCON.OCTSEL=1; // select OCx timer
0026BA  A8618A     BSET OC2CON, #3
51:                    AUDIOR=0;
0026BC  EF2188     CLR OC2R
52:                    AUDIOTMR.TON=0;
0026BE  A9E113     BCLR 0x113, #7
53:                    AUDIOTMR.TCKPS=1; // 1:8  // timer clock prescale divisor
0026C0  800894     MOV T3CON, W4
0026C2  A04004     BSET W4, #4
0026C4  A15004     BCLR W4, #5
0026C6  880894     MOV W4, T3CON
54:                }//f()
0026C8  060000     RETURN
55:                
56:                // play tone in background
57:                void tone(unsigned freq, // frequency in hertz
58:                          unsigned msec){ // duration in  milliseconds
0026CA  BE9F88     MOV.D W8, [W15++]
0026CC  781F8A     MOV W10, [W15++]
0026CE  780501     MOV W1, W10
59:                    if (!(freq && msec))  return ;
0026D0  500FE0     SUB W0, #0x0, [W15]
0026D2  320025     BRA Z, 0x271E
0026D4  550FE0     SUB W10, #0x0, [W15]
0026D6  320023     BRA Z, 0x271E
60:                    mTone_off(); 
0026D8  800C54     MOV OC2CON, W4
0026DA  A10004     BCLR W4, #0
0026DC  A11004     BCLR W4, #1
0026DE  A12004     BCLR W4, #2
0026E0  880C54     MOV W4, OC2CON
61:                    AUDIORS=FCY/16/freq; // determine tone duty cycle
0026E2  B80461     MUL.UU W0, #1, W8
0026E4  BE0108     MOV.D W8, W2
0026E6  242400     MOV #0x4240, W0
0026E8  2000F1     MOV #0xF, W1
0026EA  07EEEE     RCALL 0x4C8
0026EC  880C30     MOV W0, OC2RS
62:                    AUDIOTMR.TON=0;
0026EE  A9E113     BCLR 0x113, #7
63:                    AUDIOPR=(FCY/8/freq)-1; // pwm period
0026F0  BE0108     MOV.D W8, W2
0026F2  284800     MOV #0x8480, W0
0026F4  2001E1     MOV #0x1E, W1
0026F6  07EEE8     RCALL 0x4C8
0026F8  E90000     DEC W0, W0
0026FA  880870     MOV W0, PR3
64:                    fSound |=F_TONE;
0026FC  A81FB6     BSET fSound, #0
65:                    mTone_on(); 
0026FE  800C54     MOV OC2CON, W4
002700  A00004     BSET W4, #0
002702  A11004     BCLR W4, #1
002704  A02004     BSET W4, #2
002706  880C54     MOV W4, OC2CON
66:                    AUDIOTMR.TON=1;
002708  A8E113     BSET 0x113, #7
67:                    update_timer(tmrId,msec/tick_msec);
00270A  80FDC0     MOV tmrId, W0
00270C  80FDD4     MOV tick_msec, W4
00270E  781F80     MOV W0, [W15++]
002710  090011     REPEAT #0x11
002712  D88504     DIV.UW W10, W4
002714  780080     MOV W0, W1
002716  78004F     MOV [--W15], W0
002718  07FE97     RCALL update_timer
68:                    start_timer(tmrId);
00271A  80FDC0     MOV tmrId, W0
00271C  07FE83     RCALL start_timer
69:                } //tone();
00271E  78054F     MOV [--W15], W10
002720  BE044F     MOV.D [--W15], W8
002722  060000     RETURN
70:                
71:                // play tune in background
72:                void tune(const unsigned *buffer){
73:                    tones_list=(unsigned *)buffer;
002724  88FDA0     MOV W0, tones_list
74:                    if (*tones_list && *(tones_list+1)){
002726  EB0200     CLR W4
002728  120F90     SUBR W4, [W0], [W15]
00272A  32000C     BRA Z, 0x2744
00272C  780200     MOV W0, W4
00272E  EB0280     CLR W5
002730  128FD4     SUBR W5, [++W4], [W15]
002732  320008     BRA Z, 0x2744
75:                        fSound |= F_TUNE;
002734  A83FB6     BSET fSound, #1
76:                        AUDIOIF=0;
002736  A90085     BCLR 0x85, #0
77:                        AUDIOIE=1;
002738  A80095     BSET 0x95, #0
78:                        tone(*tones_list++,*tones_list++);
00273A  780090     MOV [W0], W1
00273C  88FDA4     MOV W4, tones_list
00273E  780034     MOV [W4++], W0
002740  88FDA4     MOV W4, tones_list
002742  07FFC3     RCALL tone
79:                    }
80:                }//tune()
002744  060000     RETURN
81:                
82:                
83:                void white_noise(unsigned msec){
84:                    if (!fSound){
002746  21FB64     MOV #0x1FB6, W4
002748  784214     MOV.B [W4], W4
00274A  524FE0     SUB.B W4, #0x0, [W15]
00274C  3A0010     BRA NZ, 0x276E
85:                        AUDIOTMR.TON=0;
00274E  A9E113     BCLR 0x113, #7
86:                        AUDIOPR=(FCY/8/10000)-1; // pwm period
002750  200C74     MOV #0xC7, W4
002752  880874     MOV W4, PR3
87:                        AUDIOTMR.TON=0;
002754  A9E113     BCLR 0x113, #7
88:                        AUDIOIF=0;
002756  A90085     BCLR 0x85, #0
89:                        AUDIOIE=1;
002758  A80095     BSET 0x95, #0
90:                        AUDIOTMR.TON=1;
00275A  A8E113     BSET 0x113, #7
91:                        update_timer(tmrId,msec/tick_msec);
00275C  80FDC4     MOV tmrId, W4
00275E  80FDD5     MOV tick_msec, W5
002760  090011     REPEAT #0x11
002762  D88005     DIV.UW W0, W5
002764  FD0080     EXCH W0, W1
002766  780004     MOV W4, W0
002768  07FE6F     RCALL update_timer
92:                        start_timer(tmrId);
00276A  80FDC0     MOV tmrId, W0
00276C  07FE5B     RCALL start_timer
93:                    }
94:                    fSound |= F_WHITE;
00276E  A85FB6     BSET fSound, #2
95:                }// f()
002770  060000     RETURN
96:                
97:                void while_sound(){
98:                    while (fSound);
002772  21FB64     MOV #0x1FB6, W4
002774  784214     MOV.B [W4], W4
002776  524FE0     SUB.B W4, #0x0, [W15]
002778  3AFFFC     BRA NZ, while_sound
99:                }// f()
00277A  060000     RETURN
100:               
101:               // interrupt at end of tone cycle
102:               void __attribute__((interrupt, no_auto_psv))  _AUDIO_ISR(void){
00277C  F80036     PUSH RCOUNT
00277E  BE9F80     MOV.D W0, [W15++]
002780  BE9F82     MOV.D W2, [W15++]
002782  BE9F84     MOV.D W4, [W15++]
002784  BE9F86     MOV.D W6, [W15++]
103:                  unsigned int f,d;
104:                  if (fSound&F_WHITE){
002786  21FB64     MOV #0x1FB6, W4
002788  784214     MOV.B [W4], W4
00278A  620264     AND W4, #0x4, W4
00278C  320007     BRA Z, 0x279C
105:                      P_NOISE_OUT=rand()&1;
00278E  07EF03     RCALL 0x596
002790  6002E1     AND W0, #0x1, W5
002792  DD2ACA     SL W5, #10, W5
002794  801664     MOV LATB, W4
002796  A1A004     BCLR W4, #10
002798  720205     IOR W4, W5, W4
00279A  881664     MOV W4, LATB
106:                  }
107:                  if (!fSound) {
00279C  21FB64     MOV #0x1FB6, W4
00279E  784214     MOV.B [W4], W4
0027A0  524FE0     SUB.B W4, #0x0, [W15]
0027A2  3A0003     BRA NZ, 0x27AA
108:                      AUDIOIE=0;
0027A4  A90095     BCLR 0x95, #0
109:                      AUDIOTMR.TON=0;
0027A6  A9E113     BCLR 0x113, #7
0027A8  370027     BRA 0x27F8
110:                  }else if (fSound==(fSound & F_TUNE)){
0027AA  21FB65     MOV #0x1FB6, W5
0027AC  784295     MOV.B [W5], W5
0027AE  21FB64     MOV #0x1FB6, W4
0027B0  784214     MOV.B [W4], W4
0027B2  FB8285     ZE W5, W5
0027B4  620262     AND W4, #0x2, W4
0027B6  528F84     SUB W5, W4, [W15]
0027B8  3A001F     BRA NZ, 0x27F8
111:                      f=*tones_list++;
0027BA  80FDA4     MOV tones_list, W4
0027BC  780034     MOV [W4++], W0
0027BE  88FDA4     MOV W4, tones_list
112:                      d=*tones_list++;
0027C0  7800B4     MOV [W4++], W1
0027C2  88FDA4     MOV W4, tones_list
113:                      if (d){
0027C4  508FE0     SUB W1, #0x0, [W15]
0027C6  320015     BRA Z, 0x27F2
114:                           if (f){
0027C8  500FE0     SUB W0, #0x0, [W15]
0027CA  320002     BRA Z, 0x27D0
115:                               tone(f,d);
0027CC  07FF7E     RCALL tone
0027CE  370014     BRA 0x27F8
116:                           }else{
117:                               update_timer(tmrId,d/tick_msec);
0027D0  80FDC0     MOV tmrId, W0
0027D2  80FDD4     MOV tick_msec, W4
0027D4  781F80     MOV W0, [W15++]
0027D6  090011     REPEAT #0x11
0027D8  D88084     DIV.UW W1, W4
0027DA  780080     MOV W0, W1
0027DC  78004F     MOV [--W15], W0
0027DE  07FE34     RCALL update_timer
118:                               start_timer(tmrId);
0027E0  80FDC0     MOV tmrId, W0
0027E2  07FE20     RCALL start_timer
119:                               fSound |= F_TONE;
0027E4  A81FB6     BSET fSound, #0
120:                               mTone_on();
0027E6  800C54     MOV OC2CON, W4
0027E8  A00004     BSET W4, #0
0027EA  A11004     BCLR W4, #1
0027EC  A02004     BSET W4, #2
0027EE  880C54     MOV W4, OC2CON
0027F0  370003     BRA 0x27F8
121:                           }
122:                      }else{
123:                          fSound=0;
0027F2  EF7FB6     CLR.B fSound
124:                          AUDIOIE=0;
0027F4  A90095     BCLR 0x95, #0
125:                          AUDIOTMR.TON=0;
0027F6  A9E113     BCLR 0x113, #7
126:                      } // if
127:                  }
128:                  AUDIOIF=0;
0027F8  A90085     BCLR 0x85, #0
129:               }// _AUDIO_ISR
0027FA  BE034F     MOV.D [--W15], W6
0027FC  BE024F     MOV.D [--W15], W4
0027FE  BE014F     MOV.D [--W15], W2
002800  BE004F     MOV.D [--W15], W0
002802  F90036     POP RCOUNT
002804  064000     RETFIE
130:               
131:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout/TVout.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NTSC_FRAMES_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE+40)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAMES_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE+45)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8  // flag screen in retrace phase
60:                #define F_BLANK 16   // flag keep screen blank
61:                
62:                unsigned frames_per_second;
63:                static unsigned int frame_line_cntr=0; // count line in video frame
64:                volatile static unsigned long frame_cntr=0; // number of frame since reset
65:                volatile static unsigned int flags;
66:                
67:                
68:                unsigned char __attribute__((aligned(2))) video_buffer[VPIXELS][BYTES_PER_LINE];
69:                int vsync, hsync, video_mode;
70:                
71:                void ntsc_init(){
72:                    VIDPR = NTSC_LINE_PERIOD;  // video timer PRx SFR
0024F4  203F85     MOV #0x3F8, W5
0024F6  880865     MOV W5, PR2
73:                    VSYNCR= NTSC_HPULSE;       // video OCxR  SFR
0024F8  2004B4     MOV #0x4B, W4
0024FA  880C14     MOV W4, OC1R
74:                    VSYNCRS=NTSC_LINE_PERIOD;  // video OCxRS SFR
0024FC  880C05     MOV W5, OC1RS
75:                    VDLYR=NTSC_VIDEO_DELAY;     // video delay OCxR SFR
0024FE  200BE5     MOV #0xBE, W5
002500  880CA5     MOV W5, OC4R
76:                    VDLYRS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;  // video delay OCxRS SFR
002502  203E05     MOV #0x3E0, W5
002504  880C95     MOV W5, OC4RS
77:                    hsync=NTSC_HPULSE;
002506  88FD14     MOV W4, hsync
78:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
002508  203AC4     MOV #0x3AC, W4
00250A  88FD04     MOV W4, vsync
79:                    video_mode=NTSC_MODE;
00250C  EF3F9C     CLR video_mode
80:                    frames_per_second=NTSC_FRAMES_PER_SECOND;
00250E  2003C4     MOV #0x3C, W4
002510  88FCF4     MOV W4, frames_per_second
81:                }//f()
002512  060000     RETURN
82:                
83:                void pal_init(){
84:                    VIDPR = PAL_LINE_PERIOD;
002514  204005     MOV #0x400, W5
002516  880865     MOV W5, PR2
85:                    VSYNCR= PAL_HPULSE;
002518  2004B4     MOV #0x4B, W4
00251A  880C14     MOV W4, OC1R
86:                    VSYNCRS=PAL_LINE_PERIOD;
00251C  880C05     MOV W5, OC1RS
87:                    VDLYR=PAL_VIDEO_DELAY;
00251E  200C35     MOV #0xC3, W5
002520  880CA5     MOV W5, OC4R
88:                    VDLYRS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
002522  203E65     MOV #0x3E6, W5
002524  880C95     MOV W5, OC4RS
89:                    hsync=PAL_HPULSE;
002526  88FD14     MOV W4, hsync
90:                    vsync=PAL_LINE_PERIOD-PAL_HPULSE;
002528  203B44     MOV #0x3B4, W4
00252A  88FD04     MOV W4, vsync
91:                    video_mode=PAL_MODE;
00252C  200014     MOV #0x1, W4
00252E  88FCE4     MOV W4, video_mode
92:                    frames_per_second=PAL_FRAMES_PER_SECOND;
002530  200324     MOV #0x32, W4
002532  88FCF4     MOV W4, frames_per_second
93:                }//f()
002534  060000     RETURN
94:                
95:                void  video_init(){ // initialisation sorties NTSC
96:                    VIDTMR.TON=0; // désactivation TIMER2
002536  A9E111     BCLR 0x111, #7
97:                    if (P_VIDEO_MODE){
002538  801655     MOV PORTB, W5
00253A  210004     MOV #0x1000, W4
00253C  628204     AND W5, W4, W4
00253E  320002     BRA Z, 0x2544
98:                        ntsc_init();
002540  07FFD9     RCALL ntsc_init
002542  370001     BRA 0x2546
99:                    }else{
100:                       pal_init();
002544  07FFE7     RCALL pal_init
101:                   }
102:                   //  video sync OC mode
103:                   VSYNCCON.OCM=5; // mode 5, timer 2
002546  800C24     MOV OC1CON, W4
002548  A00004     BSET W4, #0
00254A  A11004     BCLR W4, #1
00254C  A02004     BSET W4, #2
00254E  880C24     MOV W4, OC1CON
104:                   //video delay change notification interrupt enable on that pin.
105:                   PIXIE=1;
002550  A8A062     BSET CNEN2, #5
106:                   // video sync interrupt enabling
107:                   VSYNCIF=0;
002552  A9E084     BCLR IFS0, #7
108:                   VSYNCIE=1;
002554  A8E094     BSET IEC0, #7
109:                   // SPIx configuration (pixels output)
110:                   PIXCON1.DISSCK=1;
002556  A88243     BSET 0x243, #4
111:                   PIXCON1.MSTEN=1;
002558  A8A242     BSET SPI1CON1, #5
112:                   PIXCON1.SPRE=5;
00255A  801214     MOV SPI1CON1, W4
00255C  A02004     BSET W4, #2
00255E  A13004     BCLR W4, #3
002560  A04004     BSET W4, #4
002562  881214     MOV W4, SPI1CON1
113:                   PIXCON1.PPRE=3;
002564  200030     MOV #0x3, W0
002566  B72242     IOR SPI1CON1
114:                   PIXCON2.SPIBEN=1;  // enhanced buffer mode
002568  A80244     BSET SPI1CON2, #0
115:                   PIXSTAT.SPIEN=1;
00256A  A8E241     BSET 0x241, #7
116:                   VIDTMR.TON=1;
00256C  A8E111     BSET 0x111, #7
117:               }//horz_sync_init()
00256E  060000     RETURN
118:               
119:               void  wait_n_frame(unsigned n){
120:               unsigned long f0;
121:                   f0=frame_cntr+n;
002570  80FD44     MOV frame_cntr, W4
002572  80FD55     MOV 0x1FAA, W5
002574  420000     ADD W4, W0, W0
002576  4A80E0     ADDC W5, #0x0, W1
122:                   while (frame_cntr<f0);
002578  80FD44     MOV frame_cntr, W4
00257A  80FD55     MOV 0x1FAA, W5
00257C  500F84     SUB W0, W4, [W15]
00257E  588F85     SUBB W1, W5, [W15]
002580  3EFFFB     BRA GTU, 0x2578
123:               }//f()
002582  060000     RETURN
124:               
125:               void  blank_out(unsigned state){
126:                   if (!state){
002584  500FE0     SUB W0, #0x0, [W15]
002586  3A0002     BRA NZ, 0x258C
127:                       flags &= ~F_BLANK;
002588  A99FA6     BCLR flags, #4
00258A  370001     BRA 0x258E
128:                   }else{
129:                       flags |=F_BLANK;
00258C  A89FA6     BSET flags, #4
130:                   }
131:               }//f()
00258E  060000     RETURN
132:               
133:               
134:               // video sync signal generation
135:               void __attribute__((interrupt,no_auto_psv,shadow)) _VSYNC_ISR(void){
002590  FEA000     PUSH.S
002592  BE9F84     MOV.D W4, [W15++]
136:                   frame_line_cntr++;
002594  80FD24     MOV frame_line_cntr, W4
002596  E80204     INC W4, W4
002598  88FD24     MOV W4, frame_line_cntr
137:                   switch (frame_line_cntr){
00259A  200375     MOV #0x37, W5
00259C  520F85     SUB W4, W5, [W15]
00259E  320030     BRA Z, 0x2600
0025A0  3E0007     BRA GTU, 0x25B0
0025A2  520FE4     SUB W4, #0x4, [W15]
0025A4  320019     BRA Z, 0x25D8
0025A6  520FFE     SUB W4, #0x1E, [W15]
0025A8  32001C     BRA Z, 0x25E2
0025AA  520FE1     SUB W4, #0x1, [W15]
0025AC  3A004D     BRA NZ, 0x2648
0025AE  37000F     BRA 0x25CE
0025B0  201075     MOV #0x107, W5
0025B2  520F85     SUB W4, W5, [W15]
0025B4  320034     BRA Z, 0x261E
0025B6  3E0004     BRA GTU, 0x25C0
0025B8  5282F1     SUB W5, #0x11, W5
0025BA  520F85     SUB W4, W5, [W15]
0025BC  3A0045     BRA NZ, 0x2648
0025BE  37001A     BRA 0x25F4
0025C0  2010F5     MOV #0x10F, W5
0025C2  520F85     SUB W4, W5, [W15]
0025C4  320026     BRA Z, 0x2612
0025C6  201395     MOV #0x139, W5
0025C8  520F85     SUB W4, W5, [W15]
0025CA  3A003E     BRA NZ, 0x2648
0025CC  370033     BRA 0x2634
138:                       case 1:
139:                           VSYNCR=vsync;
0025CE  F81FA0     PUSH vsync
0025D0  F90182     POP OC1R
140:                           VDLYCONR &=0xF8;
0025D2  200F80     MOV #0xF8, W0
0025D4  B62196     AND OC4CON
141:                           break;
0025D6  370038     BRA 0x2648
142:                       case 4:
143:                           VDLYCONR |=5;
0025D8  200050     MOV #0x5, W0
0025DA  B72196     IOR OC4CON
144:                           VSYNCR=hsync;
0025DC  F81FA2     PUSH hsync
0025DE  F90182     POP OC1R
145:                           break;
0025E0  370033     BRA 0x2648
146:                       case NTSC_FIRST_VISIBLE:
147:                           if (video_mode==NTSC_MODE && !(flags&F_BLANK)){
0025E2  80FCE4     MOV video_mode, W4
0025E4  520FE0     SUB W4, #0x0, [W15]
0025E6  3A0030     BRA NZ, 0x2648
0025E8  AB9FA6     BTST flags, #4
0025EA  3A002E     BRA NZ, 0x2648
148:                               VDLYIF=0;
0025EC  A96086     BCLR IFS1, #3
149:                               VDLYIE=1;
0025EE  A86096     BSET IEC1, #3
150:                               flags &= ~F_RETRACE;
0025F0  A97FA6     BCLR flags, #3
0025F2  37002A     BRA 0x2648
151:                           }
152:                           break;
153:                       case NTSC_LAST_VISIBLE:
154:                           if (video_mode==NTSC_MODE){
0025F4  80FCE4     MOV video_mode, W4
0025F6  520FE0     SUB W4, #0x0, [W15]
0025F8  3A0027     BRA NZ, 0x2648
155:                               VDLYIE=0;
0025FA  A96096     BCLR IEC1, #3
156:                               flags |= F_RETRACE;
0025FC  A87FA6     BSET flags, #3
0025FE  370024     BRA 0x2648
157:                           }
158:                           break;
159:                       case PAL_FIRST_VISIBLE:
160:                           if (video_mode==PAL_MODE && !(flags&F_BLANK)){
002600  80FCE4     MOV video_mode, W4
002602  520FE1     SUB W4, #0x1, [W15]
002604  3A0021     BRA NZ, 0x2648
002606  AB9FA6     BTST flags, #4
002608  3A001F     BRA NZ, 0x2648
161:                               VDLYIF=0;
00260A  A96086     BCLR IFS1, #3
162:                               VDLYIE=1;
00260C  A86096     BSET IEC1, #3
163:                               flags &= ~F_RETRACE;
00260E  A97FA6     BCLR flags, #3
002610  37001B     BRA 0x2648
164:                           }
165:                           break;
166:                       case PAL_LAST_VISIBLE:
167:                           if (video_mode==PAL_MODE){
002612  80FCE4     MOV video_mode, W4
002614  520FE1     SUB W4, #0x1, [W15]
002616  3A0018     BRA NZ, 0x2648
168:                               VDLYIE=0;
002618  A96096     BCLR IEC1, #3
169:                               flags |= F_RETRACE;
00261A  A87FA6     BSET flags, #3
00261C  370015     BRA 0x2648
170:                           }
171:                           break;
172:                       case NTSC_LINES_PER_FRAME+1:
173:                           if (video_mode==NTSC_MODE){
00261E  80FCE4     MOV video_mode, W4
002620  520FE0     SUB W4, #0x0, [W15]
002622  3A0012     BRA NZ, 0x2648
174:                               frame_line_cntr=0;
002624  EF3FA4     CLR frame_line_cntr
175:                               frame_cntr++;
002626  80FD44     MOV frame_cntr, W4
002628  80FD55     MOV 0x1FAA, W5
00262A  420261     ADD W4, #0x1, W4
00262C  4A82E0     ADDC W5, #0x0, W5
00262E  88FD44     MOV W4, frame_cntr
002630  88FD55     MOV W5, 0x1FAA
002632  37000A     BRA 0x2648
176:                           }
177:                           break;
178:                       case PAL_LINES_PER_FRAME+1:
179:                           if (video_mode==PAL_MODE){
002634  80FCE4     MOV video_mode, W4
002636  520FE1     SUB W4, #0x1, [W15]
002638  3A0007     BRA NZ, 0x2648
180:                               frame_line_cntr=0;
00263A  EF3FA4     CLR frame_line_cntr
181:                               frame_cntr++;
00263C  80FD44     MOV frame_cntr, W4
00263E  80FD55     MOV 0x1FAA, W5
002640  420261     ADD W4, #0x1, W4
002642  4A82E0     ADDC W5, #0x0, W5
002644  88FD44     MOV W4, frame_cntr
002646  88FD55     MOV W5, 0x1FAA
182:                           }
183:                           break;
184:                   }//switch
185:                   VSYNCIF=0;
002648  A9E084     BCLR IFS0, #7
186:               }// _VSYNC_ISR()
00264A  BE024F     MOV.D [--W15], W4
00264C  FE8000     POP.S
00264E  064000     RETFIE
187:               
188:               void __attribute__((interrupt,no_auto_psv,shadow)) _VIDEO_OUT_ISR(void){
002650  FEA000     PUSH.S
002652  BE9F84     MOV.D W4, [W15++]
002654  BE9F86     MOV.D W6, [W15++]
00266A  B9337B     MUL.SU W6, #27, W6
00266C  207FF4     MOV #0x7FF, W4
00266E  430304     ADD W6, W4, W6
189:                   int y,x;
190:                   if (PIXDLY_INP){
002656  AB22CB     BTST 0x2CB, #1
002658  320017     BRA Z, 0x2688
191:                       if (video_mode==NTSC_MODE){
00265A  80FCE4     MOV video_mode, W4
00265C  520FE0     SUB W4, #0x0, [W15]
00265E  3A0003     BRA NZ, 0x2666
192:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE);
002660  80FD26     MOV frame_line_cntr, W6
002662  53037E     SUB W6, #0x1E, W6
002664  370002     BRA 0x266A
193:                       }else{
194:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE);
002666  80FD26     MOV frame_line_cntr, W6
002668  B10376     SUB #0x37, W6
195:                       }
196:                       for (x=0;x<BYTES_PER_LINE;x++){
002670  EB0280     CLR W5
00267C  E80285     INC W5, W5
00267E  528FFB     SUB W5, #0x1B, [W15]
002680  3AFFF8     BRA NZ, 0x2672
197:                           while (PIXSTAT.SPITBF);
002672  AB2240     BTST SPI1STAT, #1
002674  3AFFFE     BRA NZ, 0x2672
198:                           PIXBUF=video_buffer[y][x];
002676  7843D6     MOV.B [++W6], W7
002678  FB8207     ZE W7, W4
00267A  881244     MOV W4, SPI1BUF
199:                       }//for
200:                       while (PIXSTAT.SPITBF);
002682  AB2240     BTST SPI1STAT, #1
002684  3AFFFE     BRA NZ, 0x2682
201:                       PIXBUF=0;
002686  EF2248     CLR SPI1BUF
202:                   }
203:                   VDLYIF=0;
002688  A96086     BCLR IFS1, #3
204:               }// _VIDEO_OUT_ISR
00268A  BE034F     MOV.D [--W15], W6
00268C  BE024F     MOV.D [--W15], W4
00268E  FE8000     POP.S
002690  064000     RETFIE
205:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  216x216 pixels
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include "PICvision.h"
34:                #include "PICvision_banner.h"
35:                #include "games/snake/snake.h"
36:                
37:                // PIC24FJ64GA002 Configuration Bit Settings
38:                // CONFIG2
39:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
40:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
41:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
42:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
43:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
44:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
45:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
46:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
47:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
48:                
49:                // CONFIG1
50:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
51:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
52:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
53:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
54:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
55:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
56:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
57:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
58:                
59:                
60:                void splash_screen(){
002806  4787E6     ADD W15, #0x6, W15
002808  BE9F88     MOV.D W8, [W15++]
00280A  BE9F8A     MOV.D W10, [W15++]
00280C  BE9F8C     MOV.D W12, [W15++]
00280E  781F8E     MOV W14, [W15++]
002814  285CA8     MOV #0x85CA, W8
002816  207FEE     MOV #0x7FE, W14
00281A  78000A     MOV W10, W0
00281C  2004F4     MOV #0x4F, W4
00281E  52020A     SUB W4, W10, W4
00282E  2004F7     MOV #0x4F, W7
002830  538103     SUB W7, W3, W2
002832  208001     MOV #0x800, W1
002834  370008     BRA 0x2846
002846  B93A78     MUL.SU W7, #24, W4
002848  E90204     DEC W4, W4
00284A  420208     ADD W4, W8, W4
00284C  B9067B     MUL.SU W0, #27, W12
00284E  9FB7FC     MOV W12, [W15-18]
002850  9FBF8D     MOV W13, [W15-16]
002852  E8028C     INC W12, W5
002854  428281     ADD W5, W1, W5
002856  37FFEF     BRA 0x2836
002860  E90303     DEC W3, W6
002862  B9337B     MUL.SU W6, #27, W6
002864  208014     MOV #0x801, W4
002866  430204     ADD W6, W4, W4
002868  B91B7B     MUL.SU W3, #27, W6
00286A  470286     ADD W14, W6, W5
61:                    int i,k,first,last,left;
62:                    left=(HPIXELS-PIX_WIDTH)/16+1;
63:                    last=0;
002810  EB0500     CLR W10
64:                    while (last<(VPIXELS-PIX_HEIGHT)/2+PIX_HEIGHT){
002878  200944     MOV #0x94, W4
00287A  550F84     SUB W10, W4, [W15]
00287C  3AFFCE     BRA NZ, 0x281A
65:                        first=max(0,PIX_HEIGHT-last-1);
002820  3B0001     BRA NN, 0x2824
002822  EB0200     CLR W4
66:                        for (i=0;i<PIX_HEIGHT-first;i++){
002812  28D49B     MOV #0x8D49, W11
002824  200503     MOV #0x50, W3
002826  518184     SUB W3, W4, W3
002828  A94042     BCLR SR, #2
00282A  340016     BRA LE, 0x2858
00282C  78030B     MOV W11, W6
002842  538F82     SUB W7, W2, [W15]
002844  32000A     BRA Z, 0x285A
002858  EB0180     CLR W3
67:                            for (k=0;k<ARRAY_WIDTH;k++){
002838  520F86     SUB W4, W6, [W15]
00283A  3AFFFD     BRA NZ, 0x2836
00283C  E90387     DEC W7, W7
00283E  E90000     DEC W0, W0
002840  530378     SUB W6, #0x18, W6
68:                                video_buffer[last-i][left+k]=PICVISION_BANNER[PIX_HEIGHT-1-i][k];
002836  786AD4     MOV.B [++W4], [++W5]
69:                            }//for
70:                        }//for
71:                        if (last-i>0){
00285A  550183     SUB W10, W3, W3
00285C  A94042     BCLR SR, #2
00285E  340009     BRA LE, 0x2872
72:                            for (k=0;k<ARRAY_WIDTH;k++){
00286E  520F85     SUB W4, W5, [W15]
002870  3AFFFD     BRA NZ, 0x286C
73:                                video_buffer[last-i-1][left+k]=0;
002818  EB4480     CLR.B W9
00286C  786A09     MOV.B W9, [++W4]
74:                            }//for
75:                        }//if
76:                        wait_n_frame(1);
002872  200010     MOV #0x1, W0
002874  07FE7D     RCALL wait_n_frame
77:                        last++;
002876  E8050A     INC W10, W10
78:                    }//while
79:                    set_curpos(left,last/8+2);
00287E  200141     MOV #0x14, W1
002880  200020     MOV #0x2, W0
002882  07FCE9     RCALL set_curpos
80:                    print("Copyright 2014, Jacques Deschenes");
002884  293460     MOV #0x9346, W0
002886  07FC6A     RCALL print
81:                    wait_n_frame(120);
002888  200780     MOV #0x78, W0
00288A  07FE72     RCALL wait_n_frame
82:                }//f()
00288C  78074F     MOV [--W15], W14
00288E  BE064F     MOV.D [--W15], W12
002890  BE054F     MOV.D [--W15], W10
002892  BE044F     MOV.D [--W15], W8
002894  B1006F     SUB #0x6, W15
002896  060000     RETURN
83:                
84:                
85:                void PICvision_init(void) {
86:                    HardwareConfig();
002898  07000B     RCALL HardwareConfig
87:                    timers_init(TICK_FREQ);
00289A  200640     MOV #0x64, W0
00289C  07FD3E     RCALL timers_init
88:                    video_init();
00289E  07FE4B     RCALL video_init
89:                    sound_init(1000/TICK_FREQ);
0028A0  2000A0     MOV #0xA, W0
0028A2  07FF03     RCALL sound_init
90:                    splash_screen();
0028A4  07FFB0     RCALL splash_screen
91:                }//f()
0028A6  060000     RETURN
92:                
93:                
94:                int main(void){
95:                //   menu_t *games_list;
96:                   int selected;
97:                   PICvision_init();
0028A8  07FFF7     RCALL PICvision_init
98:                //   games_list=create_menu("SELECT GAME");
99:                //   add_menu_item("snake",1,games_list);
100:               //   add_menu_item("game 2",2,games_list);
101:               //   add_menu_item("game 3",3,games_list);
102:               //   add_menu_item("etc...",4,games_list);
103:                  while(1){
104:                      clear_screen();
0028AA  07FC51     RCALL clear_screen
105:                 //     selected=run_menu(games_list,10,(27-5)/2,PADDLE1);
106:                      selected=1;
107:                      switch(selected){
108:                          case 1:
109:                              snake_game();
0028AC  07FAFA     RCALL snake_game
0028AE  37FFFD     BRA 0x28AA
110:                              break;
111:                          case 2:
112:                              set_curpos(0,0);
113:                              print("game 2");
114:                              wait_n_frame(60);
115:                              break;
116:                          case 3:
117:                              set_curpos(0,0);
118:                              print("game 3");
119:                              wait_n_frame(60);
120:                              break;
121:                          case 4:
122:                              set_curpos(0,0);
123:                              print("autre jeux");
124:                              wait_n_frame(60);
125:                              break;
126:                      }//switch
127:                  }//while
128:                  return 0;
129:               }//main()
130:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/Hardware/hardwareProfile.c  ---------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   hardwareProfile.h
21:                 * Author: jacques Deschênes
22:                 * Description:  try to centralize  hardware specific.
23:                 * Created on 1 march 2014
24:                 */
25:                
26:                #include "hardwareProfile.h"
27:                
28:                void HardwareConfig(){
29:                    // peripheral to pin association.
30:                    PPSUnLock;
0028B0  803A16     MOV OSCCON, W6
0028B2  B20BF6     AND #0xBF, W6
0028B4  200464     MOV #0x46, W4
0028B6  200575     MOV #0x57, W5
0028B8  207427     MOV #0x742, W7
0028BA  784B84     MOV.B W4, [W7]
0028BC  784B85     MOV.B W5, [W7]
0028BE  784B86     MOV.B W6, [W7]
31:                    PPSOutput(PPS_RP5,PPS_SDO1);   // video pixels output
0028C0  803626     MOV RPOR2, W6
0028C2  2E0FF7     MOV #0xE0FF, W7
0028C4  630307     AND W6, W7, W6
0028C6  207000     MOV #0x700, W0
0028C8  730300     IOR W6, W0, W6
0028CA  883626     MOV W6, RPOR2
32:                    PPSOutput(PPS_RP6,PPS_OC4);  // video delay output
0028CC  803630     MOV RPOR3, W0
0028CE  2FFE06     MOV #0xFFE0, W6
0028D0  600006     AND W0, W6, W0
0028D2  B30150     IOR #0x15, W0
0028D4  883630     MOV W0, RPOR3
33:                    PPSOutput(PPS_RP7,PPS_OC1);  // video sync output
0028D6  803630     MOV RPOR3, W0
0028D8  600387     AND W0, W7, W7
0028DA  212000     MOV #0x1200, W0
0028DC  738380     IOR W7, W0, W7
0028DE  883637     MOV W7, RPOR3
34:                    PPSOutput(PPS_RP8,PPS_OC2);  // audio output
0028E0  803647     MOV RPOR4, W7
0028E2  638306     AND W7, W6, W6
0028E4  B30136     IOR #0x13, W6
0028E6  883646     MOV W6, RPOR4
35:                    PPSLock;
0028E8  803A16     MOV OSCCON, W6
0028EA  A06006     BSET W6, #6
0028EC  207427     MOV #0x742, W7
0028EE  784B84     MOV.B W4, [W7]
0028F0  784B85     MOV.B W5, [W7]
0028F2  784B86     MOV.B W6, [W7]
36:                    // pins data direction
37:                    P_PIXEL_OUT_TRIS=0;     // video pixels output
0028F4  A9A2C8     BCLR TRISB, #5
38:                    P_VDLY_OUT_TRIS=0;     // video delay output
0028F6  A9C2C8     BCLR TRISB, #6
39:                    P_VSYNC_OUT_TRIS=0;     // video sync output
0028F8  A9E2C8     BCLR TRISB, #7
40:                    P_AUDIO_OUT_TRIS=0;     // audio output
0028FA  A902C9     BCLR 0x2C9, #0
41:                    P_NOISE_OUT_TRIS=0;     /// white noise output
0028FC  A942C9     BCLR 0x2C9, #2
42:                    P_PIXDLY_IN_TRIS=1;     //input video pixels delay
0028FE  A822C9     BSET 0x2C9, #1
43:                    P_VIDEO_MODE_TRIS=1;    //input NTSC/PAL select input
002900  A882C9     BSET 0x2C9, #4
44:                    VIDMODE_ANDIS=1;   // disable ADC  on NTSC/PAL select input.
002902  A8832D     BSET 0x32D, #4
45:                    // paddles interface I/O setting
46:                    P_PDL1_DAT_TRIS=1;      // paddle 1 data as input
002904  A802C0     BSET TRISA, #0
47:                    P_PDL2_DAT_TRIS=1;      // paddle 2 data as input
002906  A822C0     BSET TRISA, #1
48:                    P_PDL_CLK_TRIS=0;       // paddles clock signal as output
002908  A902C8     BCLR TRISB, #0
49:                    P_PDL_LATCH_TRIS=0;     // paddles latch signal as output
00290A  A922C8     BCLR TRISB, #1
50:                    P_PDL1_ANDIS=1;         // disable analog input
00290C  A8032C     BSET AD1PCFG, #0
51:                    P_PDL2_ANDIS=1;         // disable analog input
00290E  A8232C     BSET AD1PCFG, #1
52:                    // interrupts priorities
53:                    VSYNCIP=7;  // timer interrupt used for video output must have highest priority
002910  270000     MOV #0x7000, W0
002912  B720A6     IOR IPC1
54:                    PIXIP=7;  // change notification interrupt used for video pixels must have highest priority
002914  B720AC     IOR IPC4
55:                    AUDIOIP=3; // audio output timer interrupt priority
002916  800544     MOV IPC2, W4
002918  B30034     IOR #0x3, W4
00291A  A12004     BCLR W4, #2
00291C  880544     MOV W4, IPC2
56:                    SYSTICKIP=2; // system ticks timer interrupt priority
00291E  800524     MOV IPC0, W4
002920  A1C004     BCLR W4, #12
002922  A0D004     BSET W4, #13
002924  A1E004     BCLR W4, #14
002926  880524     MOV W4, IPC0
57:                }//f()
002928  060000     RETURN
58:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/Hardware/controllers/SNES/snes_paddle.c  --------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snes_paddle.c
21:                 * Author: jacques Deschênes
22:                 * Description:  SNES gemepad interface
23:                 *              1) a pulse on paddle latch input store last switches state in shift register
24:                 *              2) each rising edge of clock signal shift one bit out, bit 0 first.
25:                 *                 bit 0 is at output after latch so there is only 15 shift to do.
26:                 * Created on 25 février 2014, 16:41
27:                 */
28:                
29:                #include <stdlib.h>
30:                #include "snes_paddle.h"
31:                //#include "TVout.h"
32:                
33:                
34:                
35:                // the loop execute in 4 Tcy
36:                #define mDelay(usec) asm("MOV #%0, W0\n NOP\n DEC W0,W0\n BRA NZ, .-4\n"::"i"(usec*CYCLES_PER_USEC/4):"w0")
37:                
38:                inline void latch(){
39:                    P_PDL_LATCH=1;
00292A  A822CC     BSET LATB, #1
40:                    mDelay(1);
00292C  200040     MOV #0x4, W0
00292E  000000     NOP
002930  E90000     DEC W0, W0
002932  3AFFFD     BRA NZ, 0x292E
41:                    P_PDL_LATCH=0;
002934  A922CC     BCLR LATB, #1
42:                    mDelay(1);
002936  200040     MOV #0x4, W0
002938  000000     NOP
00293A  E90000     DEC W0, W0
00293C  3AFFFD     BRA NZ, 0x2938
43:                }//f()
00293E  060000     RETURN
44:                
45:                inline void bit_shift(){
46:                    P_PDL_CLK=1;
002940  A802CC     BSET LATB, #0
47:                    mDelay(1);
002942  200040     MOV #0x4, W0
002944  000000     NOP
002946  E90000     DEC W0, W0
002948  3AFFFD     BRA NZ, 0x2944
48:                    P_PDL_CLK=0;
00294A  A902CC     BCLR LATB, #0
49:                    mDelay(1);
00294C  200040     MOV #0x4, W0
00294E  000000     NOP
002950  E90000     DEC W0, W0
002952  3AFFFD     BRA NZ, 0x294E
50:                }// f()
002954  060000     RETURN
51:                
52:                unsigned read_paddle(int paddleId) {
002956  BE9F88     MOV.D W8, [W15++]
002958  BE9F8A     MOV.D W10, [W15++]
00295A  BE9F8C     MOV.D W12, [W15++]
00295C  780680     MOV W0, W13
53:                    unsigned i,pdata, p1,p2;
54:                    p1=0;
002962  780509     MOV W9, W10
55:                    p2=0;
002960  EB0480     CLR W9
56:                    latch(); // latch data in paddles shift register
00295E  07FFE5     RCALL latch
57:                    // shift out is least significant bit first.
58:                    for (i=0;i<15;i++){ // SNES paddle have 16 bits shift register
002964  780409     MOV W9, W8
00297E  E80408     INC W8, W8
002980  540FEF     SUB W8, #0xF, [W15]
002982  3AFFF3     BRA NZ, 0x296A
59:                        pdata=PADDLES_DATA_PORT;
00296A  801614     MOV PORTA, W4
60:                        p1 |= (pdata&PADDLE1)<<i;
00296C  6202E1     AND W4, #0x1, W5
00296E  DD2A88     SL W5, W8, W5
002970  750505     IOR W10, W5, W10
61:                        p2 |= (pdata&PADDLE2)?1<<i:0;
002966  EB0580     CLR W11
002968  20001C     MOV #0x1, W12
002972  620262     AND W4, #0x2, W4
002974  78028B     MOV W11, W5
002976  320001     BRA Z, 0x297A
002978  DD6288     SL W12, W8, W5
00297A  748485     IOR W9, W5, W9
62:                        bit_shift();
00297C  07FFE1     RCALL bit_shift
63:                    }
64:                    return paddleId==1?(~p1)&0xfff:(~p2)&0xfff;
002984  568FE1     SUB W13, #0x1, [W15]
002986  3A0004     BRA NZ, 0x2990
002988  EA800A     COM W10, W0
00298A  20FFF4     MOV #0xFFF, W4
00298C  600004     AND W0, W4, W0
00298E  370003     BRA 0x2996
002990  EA8009     COM W9, W0
002992  20FFF4     MOV #0xFFF, W4
002994  600004     AND W0, W4, W0
65:                }//f()
002996  BE064F     MOV.D [--W15], W12
002998  BE054F     MOV.D [--W15], W10
00299A  BE044F     MOV.D [--W15], W8
00299C  060000     RETURN
66:                
