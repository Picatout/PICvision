Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-03-14 22:34:14

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/timers.c  ---------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 *  NAME: timers.c
21:                 *  DATE CREATED: 2014-02-21
22:                 *  AUTHOR: Jacques Deschênes
23:                 *  DESCRIPTION: create timers with callback. TIMER1 is used as a system timer that
24:                 *               ticks at regular interval. The ISR of TIMER1 manage created timers.
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "timers.h"
29:                
30:                #define F_TMR_USED 1
31:                #define F_TMR_HALTED 2
32:                #define F_TMR_REPEAT 4
33:                #define TMR_RUNNING 1
34:                
35:                
36:                typedef struct timer_type{
37:                    unsigned status;    // slot used,  timer halted
38:                    unsigned delay;    // timer interval
39:                    unsigned countdown;
40:                    timer_handler_t *handler; // timer callback handler
41:                }timer_t;
42:                
43:                volatile static timer_t timers[MAX_TIMERS];
44:                volatile static unsigned long ticks;
45:                
46:                void timers_init(unsigned ticks_per_second){
001F68  BE9F88     MOV.D W8, [W15++]
001F6A  781F8A     MOV W10, [W15++]
001F6C  780500     MOV W0, W10
47:                    unsigned long quotient;
48:                    unsigned prescale;
49:                    int i;
50:                    for (i=0;i<MAX_TIMERS;i++){
001F6E  EB0200     CLR W4
001F80  E80204     INC W4, W4
001F82  520FE8     SUB W4, #0x8, [W15]
001F84  3AFFF8     BRA NZ, 0x1F76
51:                        timers[i].status=0;
001F70  21FAA1     MOV #0x1FAA, W1
001F72  EB0300     CLR W6
001F76  DD22C3     SL W4, #3, W5
001F78  408385     ADD W1, W5, W7
001F7A  780B86     MOV W6, [W7]
52:                        timers[i].handler=NULL;
001F74  408066     ADD W1, #0x6, W0
001F7C  400285     ADD W0, W5, W5
001F7E  780A86     MOV W6, [W5]
53:                    }//for
54:                    ticks=0;
001F86  EF3FA6     CLR ticks
001F88  EF3FA8     CLR 0x1FA8
55:                
56:                    SYSTICKTMR.TON=0;  // disable systick timer
001F8A  A9E105     BCLR 0x105, #7
57:                    SYSTICKTMR.TCS=0;  // use internal Tcy
001F8C  A92104     BCLR T1CON, #1
58:                    quotient = FCY/ticks_per_second;
001F8E  B85461     MUL.UU W10, #1, W8
001F90  BE0108     MOV.D W8, W2
001F92  224000     MOV #0x2400, W0
001F94  200F41     MOV #0xF4, W1
001F96  07F298     RCALL 0x4C8
59:                    prescale=1;
001F9E  200014     MOV #0x1, W4
60:                    while (quotient>65535){
001F98  400FE1     ADD W0, #0x1, [W15]
001F9A  588FE0     SUBB W1, #0x0, [W15]
001F9C  36000B     BRA LEU, 0x1FB4
001FA0  2FFFF6     MOV #0xFFFF, W6
001FA2  200007     MOV #0x0, W7
001FAA  500F86     SUB W0, W6, [W15]
001FAC  588F87     SUBB W1, W7, [W15]
001FAE  3EFFFA     BRA GTU, 0x1FA4
61:                        quotient >>= 1;
001FA4  D10081     LSR W1, W1
001FA6  D38000     RRC W0, W0
62:                        prescale <<= 1;
001FA8  420204     ADD W4, W4, W4
63:                    }
64:                    if (prescale==1){
001FB0  520FE1     SUB W4, #0x1, [W15]
001FB2  3A0006     BRA NZ, 0x1FC0
65:                        SYSTICKTMR.TCKPS=0;
001FB4  800824     MOV T1CON, W4
001FB6  A14004     BCLR W4, #4
001FB8  A15004     BCLR W4, #5
001FBA  880824     MOV W4, T1CON
66:                        SYSTICKPR=quotient;
001FBC  880810     MOV W0, PR1
001FBE  370020     BRA 0x2000
67:                    }else if (prescale<=8){
001FC0  520FE8     SUB W4, #0x8, [W15]
001FC2  3E000A     BRA GTU, 0x1FD8
68:                        SYSTICKTMR.TCKPS=1;
001FC4  800824     MOV T1CON, W4
001FC6  A04004     BSET W4, #4
001FC8  A15004     BCLR W4, #5
001FCA  880824     MOV W4, T1CON
69:                        SYSTICKPR= FCY/8/ticks_per_second;
001FCC  BE0108     MOV.D W8, W2
001FCE  284800     MOV #0x8480, W0
001FD0  2001E1     MOV #0x1E, W1
001FD2  07F27A     RCALL 0x4C8
001FD4  880810     MOV W0, PR1
001FD6  370014     BRA 0x2000
70:                    }else if (prescale<=64){
001FD8  200405     MOV #0x40, W5
001FDA  520F85     SUB W4, W5, [W15]
001FDC  3E000A     BRA GTU, 0x1FF2
71:                        SYSTICKTMR.TCKPS=2;
001FDE  800824     MOV T1CON, W4
001FE0  A14004     BCLR W4, #4
001FE2  A05004     BSET W4, #5
001FE4  880824     MOV W4, T1CON
72:                        SYSTICKPR= FCY/64/ticks_per_second;
001FE6  BE0108     MOV.D W8, W2
001FE8  2D0900     MOV #0xD090, W0
001FEA  200031     MOV #0x3, W1
001FEC  07F26D     RCALL 0x4C8
001FEE  880810     MOV W0, PR1
001FF0  370007     BRA 0x2000
73:                    }else{
74:                        SYSTICKTMR.TCKPS=3;
001FF2  200300     MOV #0x30, W0
001FF4  B72104     IOR T1CON
75:                        SYSTICKPR = FCY/256/ticks_per_second;
001FF6  2F4244     MOV #0xF424, W4
001FF8  090011     REPEAT #0x11
001FFA  D8820A     DIV.UW W4, W10
001FFC  780200     MOV W0, W4
001FFE  880814     MOV W4, PR1
76:                    }//if
77:                    SYSTICKIF=0; // reset interrupt flag
002000  A96084     BCLR IFS0, #3
78:                    SYSTICKIE=1; // enable interrupt on systick timer
002002  A86094     BSET IEC0, #3
79:                    SYSTICKTMR.TON = 1; // enable systick timer
002004  A8E105     BSET 0x105, #7
80:                }//f()
002006  78054F     MOV [--W15], W10
002008  BE044F     MOV.D [--W15], W8
00200A  060000     RETURN
81:                
82:                int create_timer(unsigned delay, unsigned repeat, timer_handler_t *handler){
83:                    int i;
84:                    if (!handler) return -1;
00200C  EB8200     SETM W4
00200E  510FE0     SUB W2, #0x0, [W15]
002010  320020     BRA Z, 0x2052
85:                    for (i=0;i<MAX_TIMERS;i++){
002016  200014     MOV #0x1, W4
00204A  E80204     INC W4, W4
00204C  520FE8     SUB W4, #0x8, [W15]
00204E  3AFFE4     BRA NZ, 0x2018
86:                        if (!(timers[i].status & F_TMR_USED)){
002012  AB1FAA     BTST timers, #0
002014  320007     BRA Z, 0x2024
002018  DD22C3     SL W4, #3, W5
00201A  21FAA6     MOV #0x1FAA, W6
00201C  7A82E6     MOV [W6+W5], W5
00201E  6282E1     AND W5, #0x1, W5
002020  3A0014     BRA NZ, 0x204A
002022  370001     BRA 0x2026
002024  EB0200     CLR W4
87:                            timers[i].status = F_TMR_USED|F_TMR_HALTED;
002026  DD22C3     SL W4, #3, W5
002028  200037     MOV #0x3, W7
00202A  21FAA6     MOV #0x1FAA, W6
00202C  7AB307     MOV W7, [W6+W5]
88:                            if (repeat==TIMER_REPEAT) {timers[i].status |= F_TMR_REPEAT;}
00202E  508FE1     SUB W1, #0x1, [W15]
002030  3A0004     BRA NZ, 0x203A
002032  7A83E6     MOV [W6+W5], W7
002034  430285     ADD W6, W5, W5
002036  A02007     BSET W7, #2
002038  780A87     MOV W7, [W5]
89:                            timers[i].delay=delay;
00203A  DD22C3     SL W4, #3, W5
00203C  21FAC6     MOV #0x1FAC, W6
00203E  7AB300     MOV W0, [W6+W5]
90:                            timers[i].countdown=delay;
002040  E88306     INC2 W6, W6
002042  7AB300     MOV W0, [W6+W5]
91:                            timers[i].handler=handler;
002044  E88306     INC2 W6, W6
002046  7AB302     MOV W2, [W6+W5]
92:                            return i;
002048  370004     BRA 0x2052
93:                        }//if
94:                    }//for
95:                    return -1;
002050  EB8200     SETM W4
96:                }//f()
002052  780004     MOV W4, W0
002054  060000     RETURN
97:                
98:                void stop_timer(int timer_id){
99:                    if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
002056  500FE7     SUB W0, #0x7, [W15]
002058  3E000B     BRA GTU, 0x2070
002060  620261     AND W4, #0x1, W4
002062  320006     BRA Z, 0x2070
100:                        (timers[timer_id].status & F_TMR_USED)){
00205A  DD0243     SL W0, #3, W4
00205C  21FAA5     MOV #0x1FAA, W5
00205E  7A0265     MOV [W5+W4], W4
101:                       timers[timer_id].status |= F_TMR_HALTED;
002064  DD0043     SL W0, #3, W0
002066  780205     MOV W5, W4
002068  7802E4     MOV [W4+W0], W5
00206A  420000     ADD W4, W0, W0
00206C  A01005     BSET W5, #1
00206E  780805     MOV W5, [W0]
102:                   }//if
103:               }//f()
002070  060000     RETURN
104:               
105:               void start_timer(int timer_id){
106:                   if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
002072  500FE7     SUB W0, #0x7, [W15]
002074  3E000F     BRA GTU, 0x2094
00207C  620261     AND W4, #0x1, W4
00207E  32000A     BRA Z, 0x2094
107:                       (timers[timer_id].status & F_TMR_USED)){
002076  DD0243     SL W0, #3, W4
002078  21FAA5     MOV #0x1FAA, W5
00207A  7A0265     MOV [W5+W4], W4
108:                           timers[timer_id].countdown=timers[timer_id].delay;
002080  DD0043     SL W0, #3, W0
002082  E88300     INC2 W0, W6
002084  780205     MOV W5, W4
002086  4282E4     ADD W5, #0x4, W5
002088  7B0364     MOV [W4+W6], W6
00208A  783286     MOV W6, [W5+W0]
109:                           timers[timer_id].status &= ~F_TMR_HALTED;
00208C  7802E4     MOV [W4+W0], W5
00208E  420000     ADD W4, W0, W0
002090  A11005     BCLR W5, #1
002092  780805     MOV W5, [W0]
110:                   }//if
111:               }//f()
002094  060000     RETURN
112:               
113:               void update_timer(int timer_id, unsigned new_delay){
114:                   if ((timer_id>=0)&&(timer_id<=MAX_TIMERS)&&timers[timer_id].status){
002096  500FE8     SUB W0, #0x8, [W15]
002098  3E0008     BRA GTU, 0x20AA
00209A  DD0243     SL W0, #3, W4
00209C  21FAA5     MOV #0x1FAA, W5
00209E  7A0265     MOV [W5+W4], W4
0020A0  520FE0     SUB W4, #0x0, [W15]
0020A2  320003     BRA Z, 0x20AA
115:                       timers[timer_id].delay=new_delay;
0020A4  DD0043     SL W0, #3, W0
0020A6  E88205     INC2 W5, W4
0020A8  783201     MOV W1, [W4+W0]
116:                   }
117:               }//f()
0020AA  060000     RETURN
118:               
119:               void destroy_timer(int timer_id){
120:                   if ((timer_id<0)||(timer_id>=MAX_TIMERS)) return;
0020AC  500FE7     SUB W0, #0x7, [W15]
0020AE  3E0008     BRA GTU, 0x20C0
121:                   timers[timer_id].status=0;
0020B0  DD0043     SL W0, #3, W0
0020B2  21FAA5     MOV #0x1FAA, W5
0020B4  428280     ADD W5, W0, W5
0020B6  EB0200     CLR W4
0020B8  780A84     MOV W4, [W5]
122:                   timers[timer_id].handler=NULL;
0020BA  21FB05     MOV #0x1FB0, W5
0020BC  428000     ADD W5, W0, W0
0020BE  780804     MOV W4, [W0]
123:               }//f()
0020C0  060000     RETURN
124:               
125:               unsigned long sys_ticks(){
126:                   return ticks;
0020C2  80FD30     MOV ticks, W0
0020C4  80FD41     MOV 0x1FA8, W1
127:               }//f()
0020C6  060000     RETURN
128:               
129:               void __attribute__((interrupt,no_auto_psv)) _SYSTICK_ISR(void){
0020C8  F80036     PUSH RCOUNT
0020CA  BE9F80     MOV.D W0, [W15++]
0020CC  BE9F82     MOV.D W2, [W15++]
0020CE  BE9F84     MOV.D W4, [W15++]
0020D0  BE9F86     MOV.D W6, [W15++]
0020D2  BE9F88     MOV.D W8, [W15++]
0020D4  BE9F8A     MOV.D W10, [W15++]
130:                   int i;
131:                   ticks++;
0020D6  80FD34     MOV ticks, W4
0020D8  80FD45     MOV 0x1FA8, W5
0020DA  420261     ADD W4, #0x1, W4
0020DC  4A82E0     ADDC W5, #0x0, W5
0020DE  88FD34     MOV W4, ticks
0020E0  88FD45     MOV W5, 0x1FA8
132:                   for (i=0;i<MAX_TIMERS;i++){
0020E2  EB0400     CLR W8
00212A  E80408     INC W8, W8
00212C  540FE8     SUB W8, #0x8, [W15]
00212E  3AFFDB     BRA NZ, 0x20E6
133:                       if (((timers[i].status&(F_TMR_USED|F_TMR_HALTED))==TMR_RUNNING)){
0020E6  DD4243     SL W8, #3, W4
0020E8  21FAA5     MOV #0x1FAA, W5
0020EA  7A0265     MOV [W5+W4], W4
0020EC  620263     AND W4, #0x3, W4
0020EE  520FE1     SUB W4, #0x1, [W15]
0020F0  3A001C     BRA NZ, 0x212A
134:                           if (--timers[i].countdown==0){
0020E4  21FAE9     MOV #0x1FAE, W9
0020F2  DD4343     SL W8, #3, W6
0020F4  430264     ADD W6, #0x4, W4
0020F6  7A03E5     MOV [W5+W4], W7
0020F8  448306     ADD W9, W6, W6
0020FA  E90B07     DEC W7, [W6]
0020FC  7A0265     MOV [W5+W4], W4
0020FE  520FE0     SUB W4, #0x0, [W15]
002100  3A0014     BRA NZ, 0x212A
135:                               timers[i].handler();
002102  DD45C3     SL W8, #3, W11
002104  458266     ADD W11, #0x6, W4
002106  780505     MOV W5, W10
002108  7A026A     MOV [W10+W4], W4
00210A  010004     CALL W4
136:                               if (timers[i].status & F_TMR_REPEAT) {
00210C  7D826A     MOV [W10+W11], W4
00210E  620264     AND W4, #0x4, W4
002110  320006     BRA Z, 0x211E
137:                                   timers[i].countdown=timers[i].delay;
002112  78020B     MOV W11, W4
002114  E88284     INC2 W4, W5
002116  78030A     MOV W10, W6
002118  7A8366     MOV [W6+W5], W6
00211A  7A3486     MOV W6, [W9+W4]
00211C  370006     BRA 0x212A
138:                               }else{
139:                                   timers[i].status |= F_TMR_HALTED;
00211E  DD4243     SL W8, #3, W4
002120  21FAA5     MOV #0x1FAA, W5
002122  7A0365     MOV [W5+W4], W6
002124  428204     ADD W5, W4, W4
002126  A01006     BSET W6, #1
002128  780A06     MOV W6, [W4]
140:                               }
141:                           }//if
142:                       }
143:                   }//for
144:                   SYSTICKIF=0;
002130  A96084     BCLR IFS0, #3
145:               }// _SYSTICK_ISR()
002132  BE054F     MOV.D [--W15], W10
002134  BE044F     MOV.D [--W15], W8
002136  BE034F     MOV.D [--W15], W6
002138  BE024F     MOV.D [--W15], W4
00213A  BE014F     MOV.D [--W15], W2
00213C  BE004F     MOV.D [--W15], W0
00213E  F90036     POP RCOUNT
002140  064000     RETFIE
146:               
147:               
148:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/text_console.c  ---------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   text_console.h
21:                 * Author: jacques Deschênes
22:                 * Description: manage text writing in video_buffer
23:                 * Created on 28 février 2014, 10:04
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                #include "text_console.h"
29:                
30:                //static text_coord_t cursor_pos;
31:                
32:                //#define X_OFS  ((HPIXELS-CHAR_PER_LINE*CHAR_WIDTH)/2)  // x offset to cursor from screen edge
33:                //#define Y_OFS  ((VPIXELS-LINE_PER_SCREEN*CHAR_HEIGHT)/2) // y offset to cursor from screen edge
34:                
35:                // boolean flags
36:                #define CUR_SHOW 1  // cursor active
37:                #define CUR_VIS  2  // cursor state visible
38:                #define INV_VID  4  // invert video
39:                
40:                
41:                static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
42:                static unsigned char tab_width=TAB_WIDTH;
43:                static cursor_t cur_shape=CR_UNDER;
44:                static unsigned short flags=0;
45:                
46:                
47:                
48:                void scroll_up(void){
49:                    char *src, *dst;
50:                    dst = (char*)video_buffer;
51:                    src = (char*)video_buffer + CHAR_HEIGHT*BYTES_PER_LINE;
52:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001C0C  215F02     MOV #0x15F0, W2
001C0E  208D81     MOV #0x8D8, W1
001C10  208000     MOV #0x800, W0
001C12  07F4A9     RCALL 0x566
53:                    dst= (char*)video_buffer+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*BYTES_PER_LINE;
54:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
001C14  21DF04     MOV #0x1DF0, W4
001C16  0900D7     REPEAT #0xD7
001C18  EB5A00     CLR.B [W4++]
55:                }//scroll_up();
001C1A  060000     RETURN
56:                
57:                void scroll_down(void){
58:                    char *src, *dst;
59:                    src = (char*)video_buffer;
60:                    dst = (char*)video_buffer+CHAR_HEIGHT*BYTES_PER_LINE;
61:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001C1C  215F02     MOV #0x15F0, W2
001C1E  208001     MOV #0x800, W1
001C20  200D80     MOV #0xD8, W0
001C22  400001     ADD W0, W1, W0
001C24  07F4A0     RCALL 0x566
62:                    dst=(char*)video_buffer;
63:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
001C26  208004     MOV #0x800, W4
001C28  0900D7     REPEAT #0xD7
001C2A  EB5A00     CLR.B [W4++]
64:                }//scroll_down()
001C2C  060000     RETURN
65:                
66:                
67:                void cursor_right(void){
68:                    cx += CHAR_WIDTH;
001C2E  80FF74     MOV cx, W4
001C30  420266     ADD W4, #0x6, W4
001C32  88FF74     MOV W4, cx
69:                    if (cx>(CHAR_PER_LINE*CHAR_WIDTH)){
001C34  200D25     MOV #0xD2, W5
001C36  520F85     SUB W4, W5, [W15]
001C38  36000A     BRA LEU, 0x1C4E
70:                        cx = 0;
001C3A  EF3FEE     CLR cx
71:                        cy += CHAR_HEIGHT;
001C3C  80FF84     MOV cy, W4
001C3E  420268     ADD W4, #0x8, W4
001C40  88FF84     MOV W4, cy
72:                        if (cy>(LINE_PER_SCREEN*CHAR_HEIGHT)){
001C42  4282E6     ADD W5, #0x6, W5
001C44  520F85     SUB W4, W5, [W15]
001C46  360003     BRA LEU, 0x1C4E
73:                            scroll_up();
001C48  07FFE1     RCALL scroll_up
74:                            cy -= CHAR_HEIGHT;
001C4A  2FFF80     MOV #0xFFF8, W0
001C4C  B43FF0     ADD cy
75:                        }
76:                    }
77:                } // cursor_right()
001C4E  060000     RETURN
78:                
79:                void cursor_left(void){
80:                    if (cx>=CHAR_WIDTH){
001C50  80FF74     MOV cx, W4
001C52  520FE5     SUB W4, #0x5, [W15]
001C54  360003     BRA LEU, 0x1C5C
81:                        cx -= CHAR_WIDTH;
001C56  520266     SUB W4, #0x6, W4
001C58  88FF74     MOV W4, cx
001C5A  370009     BRA 0x1C6E
82:                    }else{
83:                        cx = CHAR_WIDTH*(CHAR_PER_LINE-1);
001C5C  200CC4     MOV #0xCC, W4
001C5E  88FF74     MOV W4, cx
84:                        if (cy>=CHAR_HEIGHT){
001C60  80FF84     MOV cy, W4
001C62  520FE7     SUB W4, #0x7, [W15]
001C64  360003     BRA LEU, 0x1C6C
85:                            cy -= CHAR_HEIGHT;
001C66  520268     SUB W4, #0x8, W4
001C68  88FF84     MOV W4, cy
001C6A  370001     BRA 0x1C6E
86:                        }else{
87:                            scroll_down();
001C6C  07FFD7     RCALL scroll_down
88:                        }
89:                    }
90:                }// cursor_left()
001C6E  060000     RETURN
91:                
92:                void cursor_up(void){
93:                    if (cy>=CHAR_HEIGHT){
001C70  80FF84     MOV cy, W4
001C72  520FE7     SUB W4, #0x7, [W15]
001C74  360003     BRA LEU, 0x1C7C
94:                        cy -= CHAR_HEIGHT;
001C76  520268     SUB W4, #0x8, W4
001C78  88FF84     MOV W4, cy
001C7A  370001     BRA 0x1C7E
95:                    }else{
96:                        scroll_down();
001C7C  07FFCF     RCALL scroll_down
97:                    }
98:                }// cursor_up()
001C7E  060000     RETURN
99:                
100:               void cursor_down(void){
101:                   if (cy<=(CHAR_HEIGHT*(LINE_PER_SCREEN-2))){
001C80  80FF84     MOV cy, W4
001C82  200C85     MOV #0xC8, W5
001C84  520F85     SUB W4, W5, [W15]
001C86  3E0003     BRA GTU, 0x1C8E
102:                       cy += CHAR_HEIGHT;
001C88  420268     ADD W4, #0x8, W4
001C8A  88FF84     MOV W4, cy
001C8C  370001     BRA 0x1C90
103:                   }else{
104:                       scroll_up();
001C8E  07FFBE     RCALL scroll_up
105:                   }
106:               }//cursor_down()
001C90  060000     RETURN
107:               
108:               void crlf(void){
109:                   cx=0;
001C92  EF3FEE     CLR cx
110:                   if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
001C94  80FF84     MOV cy, W4
001C96  200D05     MOV #0xD0, W5
001C98  520F85     SUB W4, W5, [W15]
001C9A  3A0002     BRA NZ, 0x1CA0
111:                       scroll_up();
001C9C  07FFB7     RCALL scroll_up
001C9E  370002     BRA 0x1CA4
112:                   }else{
113:                       cy += CHAR_HEIGHT;
001CA0  420268     ADD W4, #0x8, W4
001CA2  88FF84     MOV W4, cy
114:                   }
115:               }//crlf()
001CA4  060000     RETURN
116:               
117:               void put_char(unsigned char c){
001CA6  4787E6     ADD W15, #0x6, W15
001CA8  BE9F88     MOV.D W8, [W15++]
001CAA  BE9F8A     MOV.D W10, [W15++]
001CAC  BE9F8C     MOV.D W12, [W15++]
001CAE  781F8E     MOV W14, [W15++]
001D26  E80389     INC W9, W7
001D28  B94A7B     MUL.SU W9, #27, W4
001D2A  780284     MOV W4, W5
001D2C  42820D     ADD W5, W13, W4
001D2E  208000     MOV #0x800, W0
001D30  420200     ADD W4, W0, W4
001D34  DD3743     SL W6, #3, W14
001D36  28D4A6     MOV #0x8D4A, W6
001D38  470306     ADD W14, W6, W6
001D3A  E8068D     INC W13, W13
001D3C  42828D     ADD W5, W13, W5
001D3E  428280     ADD W5, W0, W5
001D40  448069     ADD W9, #0x9, W0
118:                   register int i,l,r,b,x,y;
119:                   x=cx;
001CB0  80FF73     MOV cx, W3
120:                   y=cy;
001CB2  80FF89     MOV cy, W9
121:                   switch (c){
001CB4  504FE9     SUB.B W0, #0x9, [W15]
001CB6  320007     BRA Z, 0x1CC6
001CB8  504FED     SUB.B W0, #0xD, [W15]
001CBA  320003     BRA Z, 0x1CC2
001CBC  504FE8     SUB.B W0, #0x8, [W15]
001CBE  3A001B     BRA NZ, 0x1CF6
001CC0  370018     BRA 0x1CF2
122:                       case CR:
123:                           crlf();
001CC2  07FFE7     RCALL crlf
124:                           break;
001CC4  37006E     BRA 0x1DA2
125:                       case TAB:
126:                           cx += (cx%tab_width);
001CC6  21FFA4     MOV #0x1FFA, W4
001CC8  784214     MOV.B [W4], W4
001CCA  FB8204     ZE W4, W4
001CCC  BE9F80     MOV.D W0, [W15++]
001CCE  090011     REPEAT #0x11
001CD0  D88184     DIV.UW W3, W4
001CD2  780201     MOV W1, W4
001CD4  BE004F     MOV.D [--W15], W0
001CD6  420183     ADD W4, W3, W3
001CD8  88FF73     MOV W3, cx
127:                           if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
001CDA  200D14     MOV #0xD1, W4
001CDC  518F84     SUB W3, W4, [W15]
001CDE  360061     BRA LEU, 0x1DA2
128:                               cx = 0;
001CE0  EF3FEE     CLR cx
129:                               if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
001CE2  E90204     DEC W4, W4
001CE4  548F84     SUB W9, W4, [W15]
001CE6  3A0002     BRA NZ, 0x1CEC
130:                                   scroll_up();
001CE8  07FF91     RCALL scroll_up
001CEA  37005B     BRA 0x1DA2
131:                               }else{
132:                                   cy += CHAR_HEIGHT;
001CEC  4484E8     ADD W9, #0x8, W9
001CEE  88FF89     MOV W9, cy
001CF0  370058     BRA 0x1DA2
133:                               }
134:                           }
135:                           break;
136:                       case '\b':
137:                           cursor_left();
001CF2  07FFAE     RCALL cursor_left
138:                           break;
001CF4  370056     BRA 0x1DA2
139:                       default:
140:                           if ((c<32) || (c>=(FONT_SIZE+32))) break;
001CF6  B3CE06     MOV #0xE0, W6
001CF8  404306     ADD.B W0, W6, W6
001CFA  B3C6D4     MOV #0x6D, W4
001CFC  534F84     SUB.B W6, W4, [W15]
001CFE  3E0051     BRA GTU, 0x1DA2
141:                           c -=32;
142:                           b=x>>3; // character position in video_buffer
001D00  DE9EC3     ASR W3, #3, W13
143:                           r=0;
144:                           l=(8-CHAR_WIDTH)-(x&7); // shift inside this byte
001D02  6181E7     AND W3, #0x7, W3
001D04  1181E2     SUBR W3, #0x2, W3
145:                           if (l<0){
146:                               r=-l;
001D06  DE9A4F     ASR W3, #15, W4
001D08  EA0083     NEG W3, W1
001D0A  608084     AND W1, W4, W1
147:                           }
148:                           for (i=0;i<8;i++){
001D9C  538F80     SUB W7, W0, [W15]
001D9E  3AFFD1     BRA NZ, 0x1D42
149:                               if (r){
001D42  508FE0     SUB W1, #0x0, [W15]
001D44  320018     BRA Z, 0x1D76
150:                                   if (flags & INV_VID){
001D0C  80FF52     MOV flags, W2
001D0E  610164     AND W2, #0x4, W2
001D46  510FE0     SUB W2, #0x0, [W15]
001D48  32000B     BRA Z, 0x1D60
151:                                       video_buffer[y][b] |= (0x3f>>r);
001D10  2003FA     MOV #0x3F, W10
001D12  DED601     ASR W10, W1, W12
001D52  764694     IOR.B W12, [W4], W13
152:                                       video_buffer[y][b] &=~(font6x8[(int)c][i]>>r);
001D4A  784696     MOV.B [W6], W13
001D4C  FB848D     ZE W13, W9
001D4E  DECF01     ASR W9, W1, W14
001D50  EAC70E     COM.B W14, W14
001D54  674A0D     AND.B W14, W13, [W4]
153:                                       video_buffer[y][b+1] |= (0x3f<<(8-r));
001D14  108468     SUBR W1, #0x8, W8
001D16  DD5588     SL W10, W8, W11
001D5A  75C695     IOR.B W11, [W5], W13
154:                                       video_buffer[y][b+1] &= ~(font6x8[(int)c][i]<<(8-r));
001D56  DD4C88     SL W9, W8, W9
001D58  EAC489     COM.B W9, W9
001D5C  64CA8D     AND.B W9, W13, [W5]
001D5E  37001A     BRA 0x1D94
155:                                   }else{
156:                                       video_buffer[y][b] &= ~(0x3f>>r);
001D18  EAC20C     COM.B W12, W4
001D1A  9FF784     MOV.B W4, [W15-16]
001D64  97F68F     MOV.B [W15-16], W13
001D66  66C714     AND.B W13, [W4], W14
157:                                       video_buffer[y][b] |= font6x8[(int)c][i]>>r;
001D60  784716     MOV.B [W6], W14
001D62  FB848E     ZE W14, W9
001D68  DECE81     ASR W9, W1, W13
001D6A  774A0D     IOR.B W14, W13, [W4]
158:                                       video_buffer[y][b+1] &= ~(0x3f<<(8-r));
001D1C  EAC70B     COM.B W11, W14
001D1E  9FEFFE     MOV.B W14, [W15-17]
001D6C  97EF7F     MOV.B [W15-17], W14
001D6E  674695     AND.B W14, [W5], W13
159:                                       video_buffer[y][b+1] |= font6x8[(int)c][i]<<(8-r);
001D70  DD4C88     SL W9, W8, W9
001D72  76CA89     IOR.B W13, W9, [W5]
001D74  37000F     BRA 0x1D94
160:                                   }
161:                                   y++;
162:                               } else{
163:                                   if (flags & INV_VID){
001D76  510FE0     SUB W2, #0x0, [W15]
001D78  320007     BRA Z, 0x1D88
164:                                       video_buffer[y][b] |= (0x3f<<l);
001D20  DD5503     SL W10, W3, W10
001D82  754494     IOR.B W10, [W4], W9
165:                                       video_buffer[y++][b] &=~(font6x8[(int)c][i]<<l);
001D32  FB8306     ZE W6, W6
001D7A  784496     MOV.B [W6], W9
001D7C  FB8689     ZE W9, W13
001D7E  DD6E83     SL W13, W3, W13
001D80  EAC68D     COM.B W13, W13
001D84  66CA09     AND.B W13, W9, [W4]
001D86  370006     BRA 0x1D94
166:                                   }else{
167:                                       video_buffer[y][b] &= ~(0x3f<<l);
001D22  EAC20A     COM.B W10, W4
001D24  9FEFE4     MOV.B W4, [W15-18]
001D88  97EF6F     MOV.B [W15-18], W14
001D8A  674694     AND.B W14, [W4], W13
168:                                       video_buffer[y++][b] |= font6x8[(int)c][i]<<l;
001D8C  784716     MOV.B [W6], W14
001D8E  FB848E     ZE W14, W9
001D90  DD4C83     SL W9, W3, W9
001D92  76CA09     IOR.B W13, W9, [W4]
001D94  E80387     INC W7, W7
001D96  42027B     ADD W4, #0x1B, W4
001D98  E80306     INC W6, W6
001D9A  4282FB     ADD W5, #0x1B, W5
169:                                   }
170:                               }
171:                           }
172:                           cursor_right();
001DA0  07FF46     RCALL cursor_right
173:                   }//switch(c)
174:               }//put_char()
001DA2  78074F     MOV [--W15], W14
001DA4  BE064F     MOV.D [--W15], W12
001DA6  BE054F     MOV.D [--W15], W10
001DA8  BE044F     MOV.D [--W15], W8
001DAA  B1006F     SUB #0x6, W15
001DAC  060000     RETURN
175:               
176:               void clear_screen(){
177:                   memset(video_buffer,0,HPIXELS/8*VPIXELS);
001DAE  208004     MOV #0x800, W4
001DB0  0916C7     REPEAT #0x16C7
001DB2  EB5A00     CLR.B [W4++]
178:                   cx=0;
001DB4  EB0200     CLR W4
001DB6  88FF74     MOV W4, cx
179:                   cy=0;
001DB8  88FF84     MOV W4, cy
180:               } // clear_screen()
001DBA  060000     RETURN
181:               
182:               void print(const char *text){
001DBC  781F88     MOV W8, [W15++]
001DBE  780400     MOV W0, W8
183:                   while (*text){
001DC0  784018     MOV.B [W8], W0
001DC2  504FE0     SUB.B W0, #0x0, [W15]
001DC4  320004     BRA Z, 0x1DCE
001DC8  784058     MOV.B [++W8], W0
001DCA  504FE0     SUB.B W0, #0x0, [W15]
001DCC  3AFFFC     BRA NZ, 0x1DC6
184:                       put_char(*text++);
001DC6  07FF6F     RCALL put_char
185:                   }
186:               }// print()
001DCE  78044F     MOV [--W15], W8
001DD0  060000     RETURN
187:               
188:               void print_hex(unsigned int hex, unsigned char width){
001DD2  FA000C     LNK #0xC
189:                   char c[12], *d;
190:                   int i;
191:                   c[11]=0;
001DD4  EB4200     CLR.B W4
001DD6  9FFFF4     MOV.B W4, [W15-1]
192:                   d= &c[10];
001DDA  E9820F     DEC2 W15, W4
193:                   for(i=width;i>=0||hex;i--){
001DD8  FB8301     ZE W1, W6
001DDC  37000C     BRA 0x1DF6
001DF4  E90306     DEC W6, W6
001DF6  530FE0     SUB W6, #0x0, [W15]
001DF8  3DFFF2     BRA GE, 0x1DDE
001DFA  500FE0     SUB W0, #0x0, [W15]
001DFC  3AFFF0     BRA NZ, 0x1DDE
194:                       *d=(hex%16);
001DDE  6042EF     AND.B W0, #0xF, W5
001DE0  784A05     MOV.B W5, [W4]
195:                       if (*d<10)
001DE2  52CFE9     SUB.B W5, #0x9, [W15]
001DE4  3C0003     BRA GT, 0x1DEC
196:                           *d += '0';
001DE6  B3C307     MOV #0x30, W7
001DE8  42CA07     ADD.B W5, W7, [W4]
001DEA  370002     BRA 0x1DF0
197:                       else
198:                           *d += 'A'-10;
001DEC  B3C377     MOV #0x37, W7
001DEE  42CA07     ADD.B W5, W7, [W4]
199:                       hex /=16;
001DF0  DE0044     LSR W0, #4, W0
200:                       d--;
001DF2  E90204     DEC W4, W4
201:                   }
202:                   print(++d);
001DFE  E80004     INC W4, W0
001E00  07FFDD     RCALL print
203:               } // print_hex()
001E02  FA8000     ULNK
001E04  060000     RETURN
204:               
205:               void print_int(int number, unsigned short width){ // imprime entier,width inclus le signe
001E06  FA000E     LNK #0xE
001E4C  538005     SUB W7, W5, W0
001E4E  780207     MOV W7, W4
206:                   int sign=0, i;
001E12  EB0100     CLR W2
207:                   char str[14], *d;
208:                   str[13]=0;
001E08  EB4200     CLR.B W4
001E0A  9FFFF4     MOV.B W4, [W15-1]
001E0C  508FED     SUB W1, #0xD, [W15]
001E0E  360001     BRA LEU, 0x1E12
001E10  2000D1     MOV #0xD, W1
209:                   d=&str[12];
001E22  E9820F     DEC2 W15, W4
001E3C  E9838F     DEC2 W15, W7
210:                   if (width>13){width=13;}
211:                   if (number<0){
001E14  500F82     SUB W0, W2, [W15]
001E16  3D0002     BRA GE, 0x1E1C
212:                       sign=1;
001E1A  200012     MOV #0x1, W2
213:                       number = -number;
001E18  EA0000     NEG W0, W0
214:                   }
215:                   //for (i=--width;i>=0||number;i--){
216:                   i=width;
001E1C  780281     MOV W1, W5
217:                   while (number>0){
001E1E  500FE0     SUB W0, #0x0, [W15]
001E20  34000D     BRA LE, 0x1E3C
001E36  500FE0     SUB W0, #0x0, [W15]
001E38  3CFFF6     BRA GT, 0x1E26
001E3A  370001     BRA 0x1E3E
218:                      *d--=(number%10)+'0';
001E24  2000A6     MOV #0xA, W6
001E26  780381     MOV W1, W7
001E28  090011     REPEAT #0x11
001E2A  D80006     DIV.SW W0, W6
001E2C  FD0381     EXCH W1, W7
001E2E  B3C303     MOV #0x30, W3
001E30  43D203     ADD.B W7, W3, [W4--]
001E32  780384     MOV W4, W7
219:                       number /= 10;
220:                       i--;
001E34  E90285     DEC W5, W5
221:                   }
222:                   if (i==width){
001E3E  508F85     SUB W1, W5, [W15]
001E40  3A0003     BRA NZ, 0x1E48
223:                       *d--='0';
001E42  B3C304     MOV #0x30, W4
001E44  785384     MOV.B W4, [W7--]
224:                       i--;
001E46  E90285     DEC W5, W5
225:                   }
226:                   while (i>0){
001E48  528FE0     SUB W5, #0x0, [W15]
001E4A  340007     BRA LE, 0x1E5A
001E54  520F80     SUB W4, W0, [W15]
001E56  3AFFFD     BRA NZ, 0x1E52
001E58  538385     SUB W7, W5, W7
227:                       *d--=' ';
001E50  B3C206     MOV #0x20, W6
001E52  785206     MOV.B W6, [W4--]
228:                       i--;
229:                   }
230:                   if (sign){*d='-';}else{*d=' ';}
001E5A  510FE0     SUB W2, #0x0, [W15]
001E5C  320003     BRA Z, 0x1E64
001E5E  B3C2D4     MOV #0x2D, W4
001E60  784B84     MOV.B W4, [W7]
001E62  370002     BRA 0x1E68
001E64  B3C204     MOV #0x20, W4
001E66  784B84     MOV.B W4, [W7]
231:                   print(d);
001E68  780007     MOV W7, W0
001E6A  07FFA8     RCALL print
232:               }// print_int()
001E6C  FA8000     ULNK
001E6E  060000     RETURN
233:               
234:               void set_tab_width(unsigned char width){
235:                   tab_width=width;
001E70  B7FFFA     MOV.B WREG, tab_width
236:               }// set_tab_width()
001E72  060000     RETURN
237:               
238:               void clear_eol(void){
001E74  BE9F88     MOV.D W8, [W15++]
001E76  BE9F8A     MOV.D W10, [W15++]
239:                   int x,y;
240:                   x=cx;
001E78  80FF7A     MOV cx, W10
241:                   y=cy;
001E7A  80FF8B     MOV cy, W11
242:                   while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
001E7C  200C54     MOV #0xC5, W4
001E7E  550F84     SUB W10, W4, [W15]
001E80  3E0007     BRA GTU, 0x1E90
001E84  780484     MOV W4, W9
001E8A  80FF74     MOV cx, W4
001E8C  520F89     SUB W4, W9, [W15]
001E8E  36FFFB     BRA LEU, 0x1E86
243:                       put_char(32);
001E82  B3C208     MOV #0x20, W8
001E86  784008     MOV.B W8, W0
001E88  07FF0E     RCALL put_char
244:                   }
245:                   put_char(32);
001E90  B3C200     MOV #0x20, W0
001E92  07FF09     RCALL put_char
246:                   cx=x;
001E94  88FF7A     MOV W10, cx
247:                   cy=y;
001E96  88FF8B     MOV W11, cy
248:               }// clear_eol()
001E98  BE054F     MOV.D [--W15], W10
001E9A  BE044F     MOV.D [--W15], W8
001E9C  060000     RETURN
249:               
250:               text_coord_t get_curpos(){
251:                   text_coord_t cpos;
252:                   cpos.x = cx/CHAR_WIDTH;
001E9E  80FF75     MOV cx, W5
001EA0  200064     MOV #0x6, W4
001EA2  781F80     MOV W0, [W15++]
001EA4  090011     REPEAT #0x11
001EA6  D88284     DIV.UW W5, W4
001EA8  780200     MOV W0, W4
001EAA  78004F     MOV [--W15], W0
001EAC  780804     MOV W4, [W0]
253:                   cpos.y = cy/CHAR_HEIGHT;
001EAE  80FF84     MOV cy, W4
001EB0  DE2243     LSR W4, #3, W4
001EB2  980014     MOV W4, [W0+2]
254:                   return cpos;
255:               } // get_cursor_pos()
001EB4  060000     RETURN
256:               
257:               void set_curpos(unsigned short x, unsigned short y){// {x,y} character coord.
258:                   if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
001EB6  200224     MOV #0x22, W4
001EB8  500F84     SUB W0, W4, [W15]
001EBA  3E0006     BRA GTU, 0x1EC8
001EBC  508FFA     SUB W1, #0x1A, [W15]
001EBE  3E0004     BRA GTU, 0x1EC8
259:                       return;
260:                   cx=x*CHAR_WIDTH;
001EC0  B90266     MUL.SU W0, #6, W4
001EC2  88FF74     MOV W4, cx
261:                   cy=y*CHAR_HEIGHT;
001EC4  DD08C3     SL W1, #3, W1
001EC6  88FF81     MOV W1, cy
262:               }//set_curpos()
001EC8  060000     RETURN
263:               
264:               void invert_char(void){// invert pixels of character at cursor position
001ECA  BE9F88     MOV.D W8, [W15++]
001EE6  E80287     INC W7, W5
001EE8  B93C7B     MUL.SU W7, #27, W8
001EEA  420008     ADD W4, W8, W0
001EEC  208004     MOV #0x800, W4
001EEE  400204     ADD W0, W4, W4
001EF0  4383EA     ADD W7, #0xA, W7
265:                   register int i,l,r,b,x,y;
266:                   x=cx;
001ECC  80FF71     MOV cx, W1
267:                   y=cy;
001ECE  80FF87     MOV cy, W7
268:                   b=x>>3;
001ED0  DE8A43     ASR W1, #3, W4
269:                   r=0;
270:                   l=(8-CHAR_WIDTH)-(x&7);
001ED2  6080E7     AND W1, #0x7, W1
001ED4  1080E2     SUBR W1, #0x2, W1
271:                   if (l<0){
272:                       r=-l;
001ED6  DE8ACF     ASR W1, #15, W5
001ED8  EA0301     NEG W1, W6
001EDA  630305     AND W6, W5, W6
273:                   }
274:                   for (i=9;i;i--){
001F06  528F87     SUB W5, W7, [W15]
001F08  3AFFF4     BRA NZ, 0x1EF2
275:                       if (r){
001EF2  530FE0     SUB W6, #0x0, [W15]
001EF4  320005     BRA Z, 0x1F00
276:                           video_buffer[y][b] ^= (0x3f>>r);
001EDC  2003F5     MOV #0x3F, W5
001EDE  DEA986     ASR W5, W6, W3
001EF6  69CA14     XOR.B W3, [W4], [W4]
277:                           video_buffer[y][b+1] ^= (0x3f<<(8-r));
001EE0  130168     SUBR W6, #0x8, W2
001EE2  DD2902     SL W5, W2, W2
001EF8  904014     MOV.B [W4+1], W0
001EFA  684002     XOR.B W0, W2, W0
001EFC  984210     MOV.B W0, [W4+1]
001EFE  370001     BRA 0x1F02
278:                           y++;
279:                       } else{
280:                           video_buffer[y++][b] ^= (0x3f<<l);
001EE4  DD2881     SL W5, W1, W1
001F00  68CA14     XOR.B W1, [W4], [W4]
001F02  E80285     INC W5, W5
001F04  42027B     ADD W4, #0x1B, W4
281:                       }
282:                   }
283:               }//invert_char()
001F0A  BE044F     MOV.D [--W15], W8
001F0C  060000     RETURN
284:               
285:               static void toggle_underscore(void){
286:                   register int l,r,b,x;
287:                   x=cx;
001BC4  80FF74     MOV cx, W4
288:                   b=x>>5;
001BC6  DEA2C5     ASR W4, #5, W5
289:                   r=0;
290:                   l=(8-CHAR_WIDTH)-(x&7);
001BC8  620267     AND W4, #0x7, W4
001BCA  120262     SUBR W4, #0x2, W4
291:                   if (l<0){
001BCC  3B0014     BRA NN, 0x1BF6
292:                       r=-l;
001BCE  EA0304     NEG W4, W6
293:                   }
294:                   if (r){
001BD0  320012     BRA Z, 0x1BF6
295:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
001BD2  80FF80     MOV cy, W0
001BD4  400067     ADD W0, #0x7, W0
001BD6  208004     MOV #0x800, W4
001BD8  B9007B     MUL.SU W0, #27, W0
001BDA  400085     ADD W0, W5, W1
001BDC  420101     ADD W4, W1, W2
001BDE  2003F7     MOV #0x3F, W7
001BE0  DEB986     ASR W7, W6, W3
001BE2  78C0E4     MOV.B [W4+W1], W1
001BE4  68C903     XOR.B W1, W3, [W2]
296:                       video_buffer[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<(8-r));
001BE6  E80285     INC W5, W5
001BE8  400285     ADD W0, W5, W5
001BEA  420005     ADD W4, W5, W0
001BEC  130368     SUBR W6, #0x8, W6
001BEE  DD3B86     SL W7, W6, W7
001BF0  7AC264     MOV.B [W4+W5], W4
001BF2  6A4807     XOR.B W4, W7, [W0]
001BF4  37000A     BRA 0x1C0A
297:                   } else{
298:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
001BF6  80FF80     MOV cy, W0
001BF8  400067     ADD W0, #0x7, W0
001BFA  208006     MOV #0x800, W6
001BFC  B9007B     MUL.SU W0, #27, W0
001BFE  428280     ADD W5, W0, W5
001C00  430385     ADD W6, W5, W7
001C02  2003F0     MOV #0x3F, W0
001C04  DD0204     SL W0, W4, W4
001C06  7AC2E6     MOV.B [W6+W5], W5
001C08  6ACB84     XOR.B W5, W4, [W7]
299:                   }
300:               }//toggle_underscore()
001C0A  060000     RETURN
301:               
302:               void show_cursor(BOOL show){
001F0E  781F88     MOV W8, [W15++]
303:                   if (show){
001F10  500FE0     SUB W0, #0x0, [W15]
001F12  32000B     BRA Z, 0x1F2A
304:                       flags |= CUR_SHOW;
001F14  80FF54     MOV flags, W4
001F16  A00004     BSET W4, #0
305:                       flags ^= CUR_VIS;
001F18  A21004     BTG W4, #1
001F1A  88FF54     MOV W4, flags
306:                       if (cur_shape==CR_BLOCK){
001F1C  80FF64     MOV cur_shape, W4
001F1E  520FE1     SUB W4, #0x1, [W15]
001F20  3A0002     BRA NZ, 0x1F26
307:                           invert_char();
001F22  07FFD3     RCALL invert_char
001F24  37000E     BRA 0x1F42
308:                       }else{
309:                           toggle_underscore();
001F26  07FE4E     RCALL toggle_underscore
001F28  37000C     BRA 0x1F42
310:                       }
311:                   }else{
312:                       if (flags & CUR_VIS){
001F2A  80FF58     MOV flags, W8
001F2C  640262     AND W8, #0x2, W4
001F2E  320008     BRA Z, 0x1F40
313:                           if (cur_shape==CR_BLOCK){
001F30  80FF64     MOV cur_shape, W4
001F32  520FE1     SUB W4, #0x1, [W15]
001F34  3A0002     BRA NZ, 0x1F3A
314:                               invert_char();
001F36  07FFC9     RCALL invert_char
001F38  370001     BRA 0x1F3C
315:                           }else{
316:                               toggle_underscore();
001F3A  07FE44     RCALL toggle_underscore
317:                           }
318:                           flags &= ~CUR_VIS;
001F3C  A11008     BCLR W8, #1
001F3E  88FF58     MOV W8, flags
319:                       }
320:                       flags &= ~CUR_SHOW;
001F40  A91FEA     BCLR flags, #0
321:                   }
322:               
323:               }// show_cursor()
001F42  78044F     MOV [--W15], W8
001F44  060000     RETURN
324:               
325:               void set_cursor(cursor_t shape){
001F46  781F88     MOV W8, [W15++]
001F48  780400     MOV W0, W8
326:                   if (flags & CUR_VIS){
001F4A  AB3FEA     BTST flags, #1
001F4C  320006     BRA Z, 0x1F5A
327:                       show_cursor(FALSE);
001F4E  EB0000     CLR W0
001F50  07FFDE     RCALL show_cursor
328:                       cur_shape=shape;
001F52  88FF68     MOV W8, cur_shape
329:                       show_cursor(TRUE);
001F54  200010     MOV #0x1, W0
001F56  07FFDB     RCALL show_cursor
001F58  370001     BRA 0x1F5C
330:                   }else{
331:                       cur_shape=shape;
001F5A  88FF68     MOV W8, cur_shape
332:                   }
333:               }// set_cursor()
001F5C  78044F     MOV [--W15], W8
001F5E  060000     RETURN
334:               
335:               
336:               void invert_video(){
337:                   flags |= INV_VID;
001F60  A85FEA     BSET flags, #2
338:               }//invert_video()
001F62  060000     RETURN
339:               
340:               void normal_video(){
341:                   flags &= ~INV_VID;
001F64  A95FEA     BCLR flags, #2
342:               }//normal_video()
001F66  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/sound.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   sound.c
21:                 * Author: jacques Deschênes
22:                 * Description:  sound generation using PWM D.A.C.
23:                 * Created on 25 février 2014, 16:43
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include "sound.h"
28:                
29:                #define F_TONE  1  // tone playing flag
30:                #define F_TUNE  2  // flag tune playing
31:                #define F_WHITE 4  // white noise generation
32:                
33:                #define mTone_off() (AUDIOCON.OCM=0)
34:                #define mTone_on()  (AUDIOCON.OCM=5)
35:                
36:                
37:                volatile unsigned char fSound=0; // boolean flags
38:                volatile int tmrId;  // duratio timer identifier
39:                volatile unsigned int *tones_list;  // list of tones and interval for playing tune
40:                int tick_msec=10; // tick interval in milliseconds, default 10msec.
41:                
42:                void cb_tone(void){ // timer call back function
43:                    mTone_off();
0022EA  800C54     MOV OC2CON, W4
0022EC  A10004     BCLR W4, #0
0022EE  A11004     BCLR W4, #1
0022F0  A12004     BCLR W4, #2
0022F2  880C54     MOV W4, OC2CON
44:                    fSound &= ~(F_TONE|F_WHITE);
0022F4  21FF25     MOV #0x1FF2, W5
0022F6  784295     MOV.B [W5], W5
0022F8  B3CFA4     MOV #0xFA, W4
0022FA  62C204     AND.B W5, W4, W4
0022FC  780004     MOV W4, W0
0022FE  B7FFF2     MOV.B WREG, fSound
45:                }// f()
002300  060000     RETURN
46:                
47:                void sound_init(int tick_time){
48:                    if (tick_time) tick_msec=tick_time;
002302  500FE0     SUB W0, #0x0, [W15]
002304  320001     BRA Z, 0x2308
002306  88FFA0     MOV W0, tick_msec
49:                    tmrId=create_timer(1,TIMER_SINGLE,(timer_handler_t *)cb_tone);
002308  222EA2     MOV #0x22EA, W2
00230A  EB0080     CLR W1
00230C  200010     MOV #0x1, W0
00230E  07FE7E     RCALL create_timer
002310  88FFB0     MOV W0, tmrId
50:                    AUDIOCON.OCTSEL=1; // select OCx timer
002312  A8618A     BSET OC2CON, #3
51:                    AUDIOR=0;
002314  EF2188     CLR OC2R
52:                    AUDIOTMR.TON=0;
002316  A9E113     BCLR 0x113, #7
53:                    AUDIOTMR.TCKPS=1; // 1:8  // timer clock prescale divisor
002318  800894     MOV T3CON, W4
00231A  A04004     BSET W4, #4
00231C  A15004     BCLR W4, #5
00231E  880894     MOV W4, T3CON
54:                }//f()
002320  060000     RETURN
55:                
56:                // play tone in background
57:                void tone(unsigned freq, // frequency in hertz
58:                          unsigned msec){ // duration in  milliseconds
002322  BE9F88     MOV.D W8, [W15++]
002324  781F8A     MOV W10, [W15++]
002326  780501     MOV W1, W10
59:                    //
60:                    mTone_off(); 
002328  800C54     MOV OC2CON, W4
00232A  A10004     BCLR W4, #0
00232C  A11004     BCLR W4, #1
00232E  A12004     BCLR W4, #2
002330  880C54     MOV W4, OC2CON
61:                    AUDIORS=FCY/16/freq; // determine tone duty cycle
002332  B80461     MUL.UU W0, #1, W8
002334  BE0108     MOV.D W8, W2
002336  242400     MOV #0x4240, W0
002338  2000F1     MOV #0xF, W1
00233A  07F0C6     RCALL 0x4C8
00233C  880C30     MOV W0, OC2RS
62:                    AUDIOTMR.TON=0;
00233E  A9E113     BCLR 0x113, #7
63:                    AUDIOPR=(FCY/8/freq)-1; // pwm period
002340  BE0108     MOV.D W8, W2
002342  284800     MOV #0x8480, W0
002344  2001E1     MOV #0x1E, W1
002346  07F0C0     RCALL 0x4C8
002348  E90200     DEC W0, W4
00234A  880874     MOV W4, PR3
64:                    fSound |=F_TONE;
00234C  A81FF2     BSET fSound, #0
65:                    mTone_on(); 
00234E  800C54     MOV OC2CON, W4
002350  A00004     BSET W4, #0
002352  A11004     BCLR W4, #1
002354  A02004     BSET W4, #2
002356  880C54     MOV W4, OC2CON
66:                    AUDIOTMR.TON=1;
002358  A8E113     BSET 0x113, #7
67:                    update_timer(tmrId,msec/tick_msec);
00235A  80FFB0     MOV tmrId, W0
00235C  80FFA4     MOV tick_msec, W4
00235E  781F80     MOV W0, [W15++]
002360  090011     REPEAT #0x11
002362  D88504     DIV.UW W10, W4
002364  780080     MOV W0, W1
002366  78004F     MOV [--W15], W0
002368  07FE96     RCALL update_timer
68:                    start_timer(tmrId);
00236A  80FFB0     MOV tmrId, W0
00236C  07FE82     RCALL start_timer
69:                } //tone();
00236E  78054F     MOV [--W15], W10
002370  BE044F     MOV.D [--W15], W8
002372  060000     RETURN
70:                
71:                // play tune in background
72:                void tune(const unsigned *buffer){
73:                    tones_list=(unsigned *)buffer;
002374  88FFC0     MOV W0, tones_list
74:                    if (*tones_list && *(tones_list+1)){
002376  EB0200     CLR W4
002378  120F90     SUBR W4, [W0], [W15]
00237A  32000C     BRA Z, 0x2394
00237C  780200     MOV W0, W4
00237E  EB0280     CLR W5
002380  128FD4     SUBR W5, [++W4], [W15]
002382  320008     BRA Z, 0x2394
75:                        fSound |= F_TUNE;
002384  A83FF2     BSET fSound, #1
76:                        AUDIOIF=0;
002386  A90085     BCLR 0x85, #0
77:                        AUDIOIE=1;
002388  A80095     BSET 0x95, #0
78:                        tone(*tones_list++,*tones_list++);
00238A  780090     MOV [W0], W1
00238C  88FFC4     MOV W4, tones_list
00238E  780034     MOV [W4++], W0
002390  88FFC4     MOV W4, tones_list
002392  07FFC7     RCALL tone
79:                    }
80:                }//tune()
002394  060000     RETURN
81:                
82:                
83:                void white_noise(unsigned msec){
84:                    if (!fSound){
002396  21FF24     MOV #0x1FF2, W4
002398  784214     MOV.B [W4], W4
00239A  524FE0     SUB.B W4, #0x0, [W15]
00239C  3A0010     BRA NZ, 0x23BE
85:                        AUDIOTMR.TON=0;
00239E  A9E113     BCLR 0x113, #7
86:                        AUDIOPR=(FCY/8/10000)-1; // pwm period
0023A0  200C74     MOV #0xC7, W4
0023A2  880874     MOV W4, PR3
87:                        AUDIOTMR.TON=0;
0023A4  A9E113     BCLR 0x113, #7
88:                        AUDIOIF=0;
0023A6  A90085     BCLR 0x85, #0
89:                        AUDIOIE=1;
0023A8  A80095     BSET 0x95, #0
90:                        AUDIOTMR.TON=1;
0023AA  A8E113     BSET 0x113, #7
91:                        update_timer(tmrId,msec/tick_msec);
0023AC  80FFB4     MOV tmrId, W4
0023AE  80FFA5     MOV tick_msec, W5
0023B0  090011     REPEAT #0x11
0023B2  D88005     DIV.UW W0, W5
0023B4  FD0080     EXCH W0, W1
0023B6  780004     MOV W4, W0
0023B8  07FE6E     RCALL update_timer
92:                        start_timer(tmrId);
0023BA  80FFB0     MOV tmrId, W0
0023BC  07FE5A     RCALL start_timer
93:                    }
94:                    fSound |= F_WHITE;
0023BE  A85FF2     BSET fSound, #2
95:                }// f()
0023C0  060000     RETURN
96:                
97:                void while_sound(){
98:                    while (fSound);
0023C2  21FF24     MOV #0x1FF2, W4
0023C4  784214     MOV.B [W4], W4
0023C6  524FE0     SUB.B W4, #0x0, [W15]
0023C8  3AFFFC     BRA NZ, while_sound
99:                }// f()
0023CA  060000     RETURN
100:               
101:               // interrupt at end of tone cycle
102:               void __attribute__((interrupt, no_auto_psv))  _AUDIO_ISR(void){
0023CC  F80036     PUSH RCOUNT
0023CE  BE9F80     MOV.D W0, [W15++]
0023D0  BE9F82     MOV.D W2, [W15++]
0023D2  BE9F84     MOV.D W4, [W15++]
0023D4  BE9F86     MOV.D W6, [W15++]
103:                  unsigned int f,d;
104:                  if (fSound&F_WHITE){
0023D6  21FF24     MOV #0x1FF2, W4
0023D8  784214     MOV.B [W4], W4
0023DA  620264     AND W4, #0x4, W4
0023DC  320007     BRA Z, 0x23EC
105:                      P_NOISE_OUT=rand()&1;
0023DE  07F0DB     RCALL 0x596
0023E0  6002E1     AND W0, #0x1, W5
0023E2  DD2ACA     SL W5, #10, W5
0023E4  801664     MOV LATB, W4
0023E6  A1A004     BCLR W4, #10
0023E8  720205     IOR W4, W5, W4
0023EA  881664     MOV W4, LATB
106:                  }
107:                  if (!fSound) {
0023EC  21FF24     MOV #0x1FF2, W4
0023EE  784214     MOV.B [W4], W4
0023F0  524FE0     SUB.B W4, #0x0, [W15]
0023F2  3A0003     BRA NZ, 0x23FA
108:                      AUDIOIE=0;
0023F4  A90095     BCLR 0x95, #0
109:                      AUDIOTMR.TON=0;
0023F6  A9E113     BCLR 0x113, #7
0023F8  370027     BRA 0x2448
110:                  }else if (fSound==(fSound & F_TUNE)){
0023FA  21FF25     MOV #0x1FF2, W5
0023FC  784295     MOV.B [W5], W5
0023FE  21FF24     MOV #0x1FF2, W4
002400  784214     MOV.B [W4], W4
002402  FB8285     ZE W5, W5
002404  620262     AND W4, #0x2, W4
002406  528F84     SUB W5, W4, [W15]
002408  3A001F     BRA NZ, 0x2448
111:                      f=*tones_list++;
00240A  80FFC4     MOV tones_list, W4
00240C  780034     MOV [W4++], W0
00240E  88FFC4     MOV W4, tones_list
112:                      d=*tones_list++;
002410  7800B4     MOV [W4++], W1
002412  88FFC4     MOV W4, tones_list
113:                      if (d){
002414  508FE0     SUB W1, #0x0, [W15]
002416  320015     BRA Z, 0x2442
114:                           if (f){
002418  500FE0     SUB W0, #0x0, [W15]
00241A  320002     BRA Z, 0x2420
115:                               tone(f,d);
00241C  07FF82     RCALL tone
00241E  370014     BRA 0x2448
116:                           }else{
117:                               update_timer(tmrId,d/tick_msec);
002420  80FFB0     MOV tmrId, W0
002422  80FFA4     MOV tick_msec, W4
002424  781F80     MOV W0, [W15++]
002426  090011     REPEAT #0x11
002428  D88084     DIV.UW W1, W4
00242A  780080     MOV W0, W1
00242C  78004F     MOV [--W15], W0
00242E  07FE33     RCALL update_timer
118:                               start_timer(tmrId);
002430  80FFB0     MOV tmrId, W0
002432  07FE1F     RCALL start_timer
119:                               fSound |= F_TONE;
002434  A81FF2     BSET fSound, #0
120:                               mTone_on();
002436  800C54     MOV OC2CON, W4
002438  A00004     BSET W4, #0
00243A  A11004     BCLR W4, #1
00243C  A02004     BSET W4, #2
00243E  880C54     MOV W4, OC2CON
002440  370003     BRA 0x2448
121:                           }
122:                      }else{
123:                          fSound=0;
002442  EF7FF2     CLR.B fSound
124:                          AUDIOIE=0;
002444  A90095     BCLR 0x95, #0
125:                          AUDIOTMR.TON=0;
002446  A9E113     BCLR 0x113, #7
126:                      } // if
127:                  }
128:                  AUDIOIF=0;
002448  A90085     BCLR 0x85, #0
129:               }// _AUDIO_ISR
00244A  BE034F     MOV.D [--W15], W6
00244C  BE024F     MOV.D [--W15], W4
00244E  BE014F     MOV.D [--W15], W2
002450  BE004F     MOV.D [--W15], W0
002452  F90036     POP RCOUNT
002454  064000     RETFIE
130:               
131:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snes_paddle.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snes_paddle.c
21:                 * Author: jacques Deschênes
22:                 * Description:  SNES gemepad interface
23:                 *              1) a pulse on paddle latch input store last switches state in shift register
24:                 *              2) each rising edge of clock signal shift one bit out, bit 0 first.
25:                 *                 bit 0 is at output after latch so there is only 15 shift to do.
26:                 * Created on 25 février 2014, 16:41
27:                 */
28:                
29:                #include <stdlib.h>
30:                #include "snes_paddle.h"
31:                //#include "TVout.h"
32:                
33:                
34:                
35:                // the loop execute in 4 Tcy
36:                #define mDelay(usec) __asm__("MOV #%0,W4\n NOP\n DEC W4,W4\n BRA NZ .-4"::"i"(usec))
37:                
38:                void latch(){
39:                    P_PDL_LATCH=1;
002562  A822CC     BSET LATB, #1
40:                    mDelay(CYCLES_PER_USEC/4);
002564  200044     MOV #0x4, W4
002566  000000     NOP
002568  E90204     DEC W4, W4
00256A  3AFFFD     BRA NZ, 0x2566
41:                    P_PDL_LATCH=0;
00256C  A922CC     BCLR LATB, #1
42:                    mDelay(CYCLES_PER_USEC/4);
00256E  200044     MOV #0x4, W4
002570  000000     NOP
002572  E90204     DEC W4, W4
002574  3AFFFD     BRA NZ, 0x2570
43:                }//f()
002576  060000     RETURN
44:                
45:                void bit_shift(){
46:                    P_PDL_CLK=1;
002578  A802CC     BSET LATB, #0
47:                    mDelay(CYCLES_PER_USEC/4);
00257A  200044     MOV #0x4, W4
00257C  000000     NOP
00257E  E90204     DEC W4, W4
002580  3AFFFD     BRA NZ, 0x257C
48:                    P_PDL_CLK=0;
002582  A902CC     BCLR LATB, #0
49:                    mDelay(CYCLES_PER_USEC/4);
002584  200044     MOV #0x4, W4
002586  000000     NOP
002588  E90204     DEC W4, W4
00258A  3AFFFD     BRA NZ, 0x2586
50:                }// f()
00258C  060000     RETURN
51:                
52:                unsigned read_paddle(int paddleId) {
00258E  BE9F88     MOV.D W8, [W15++]
002590  BE9F8A     MOV.D W10, [W15++]
002592  BE9F8C     MOV.D W12, [W15++]
002594  780680     MOV W0, W13
53:                    unsigned i,pdata, p1,p2;
54:                    p1=0;
00259A  780509     MOV W9, W10
55:                    p2=0;
002598  EB0480     CLR W9
56:                    latch(); // latch data in paddles shift register
002596  07FFE5     RCALL latch
57:                    // shift out is least significant bit first.
58:                    for (i=0;i<15;i++){ // SNES paddle have 16 bits shift register
00259C  780409     MOV W9, W8
0025B6  E80408     INC W8, W8
0025B8  540FEF     SUB W8, #0xF, [W15]
0025BA  3AFFF3     BRA NZ, 0x25A2
59:                        pdata=PADDLES_DATA_PORT;
0025A2  801614     MOV PORTA, W4
60:                        p1 |= (pdata&PADDLE1)<<i;
0025A4  6202E1     AND W4, #0x1, W5
0025A6  DD2A88     SL W5, W8, W5
0025A8  750505     IOR W10, W5, W10
61:                        p2 |= (pdata&PADDLE2)?1<<i:0;
00259E  EB0580     CLR W11
0025A0  20001C     MOV #0x1, W12
0025AA  620262     AND W4, #0x2, W4
0025AC  78028B     MOV W11, W5
0025AE  320001     BRA Z, 0x25B2
0025B0  DD6288     SL W12, W8, W5
0025B2  748485     IOR W9, W5, W9
62:                        bit_shift();
0025B4  07FFE1     RCALL bit_shift
63:                    }
64:                    return paddleId==1?(~p1)&0xfff:(~p2)&0xfff;
0025BC  568FE1     SUB W13, #0x1, [W15]
0025BE  3A0004     BRA NZ, 0x25C8
0025C0  EA800A     COM W10, W0
0025C2  20FFF4     MOV #0xFFF, W4
0025C4  600004     AND W0, W4, W0
0025C6  370003     BRA 0x25CE
0025C8  EA8009     COM W9, W0
0025CA  20FFF4     MOV #0xFFF, W4
0025CC  600004     AND W0, W4, W0
65:                }//f()
0025CE  BE064F     MOV.D [--W15], W12
0025D0  BE054F     MOV.D [--W15], W10
0025D2  BE044F     MOV.D [--W15], W8
0025D4  060000     RETURN
66:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snake.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   snake.c
21:                 * Author: jacques Deschênes
22:                 * Description: snake game.
23:                 * Created on 5 mars 2014, 16:01
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <time.h>
28:                #include "PICvision.h"
29:                
30:                // PIC24FJ64GA002 Configuration Bit Settings
31:                // CONFIG2
32:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
33:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
34:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
35:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
36:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
37:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
38:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
39:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
40:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
41:                
42:                // CONFIG1
43:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
44:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
45:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
46:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
47:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
48:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
49:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
50:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
51:                
52:                typedef struct symbol{
53:                    unsigned char x;
54:                    unsigned char y;
55:                    char part;
56:                }symbol_t;
57:                
58:                #define SNAKE_MAX_LEN  64
59:                
60:                typedef struct snake_struct{
61:                    unsigned length;
62:                    unsigned calories;
63:                    unsigned lifespan;
64:                    unsigned short dx;
65:                    unsigned short dy;
66:                    symbol_t body[SNAKE_MAX_LEN];
67:                }snake_t;
68:                
69:                typedef struct msg_struct{
70:                    unsigned char x;
71:                    unsigned char y;
72:                    char *text;
73:                }msg_t;
74:                
75:                // snake some symbols
76:                #define RING  102+32
77:                #define HEAD_RIGHT  103+32
78:                #define HEAD_LEFT 104+32
79:                #define HEAD_UP  105+32
80:                #define HEAD_DOWN 106+32
81:                #define MOUSE 109+32
82:                
83:                #define BASE_METABOLISM 2   // calories lost per seconde
84:                #define MOUSE_CALORIES  20  // calories gain by eating mouse
85:                
86:                snake_t snake;
87:                
88:                symbol_t mouse;
89:                
90:                const msg_t msgCALORIES={0,0,"calories: "};
91:                const msg_t msgSECONDS={16,0,"lifespan: "};
92:                const msg_t msgGAME_OVER={6,13,"game over"};
93:                const msg_t msgSTART={8,20, "press START to begin"};
94:                const msg_t msgSTARVATION={6,14,"died of starvation"};
95:                const msg_t msgWALL_COLLIDE={6,14,"died of wall collision"};
96:                const msg_t msgTAIL_BITE={6,14,"died of tail bite."};
97:                
98:                void print_msg(const msg_t msg){
001736  BE9F88     MOV.D W8, [W15++]
001738  BE0400     MOV.D W0, W8
99:                    set_curpos(msg.x,msg.y);
00173A  DE00C8     LSR W0, #8, W1
00173C  FB8008     ZE W8, W0
00173E  0703BB     RCALL set_curpos
100:                   print(msg.text);
001740  780009     MOV W9, W0
001742  07033C     RCALL print
101:               }//f()
001744  BE044F     MOV.D [--W15], W8
001746  060000     RETURN
102:               
103:               void new_mouse(){
001748  BE9F88     MOV.D W8, [W15++]
00174A  781F8A     MOV W10, [W15++]
104:                   unsigned short i, collide,mouseX,mouseY;
105:                   collide=1;
106:                   while (collide){
107:                       mouseX=rand()%(CHAR_PER_LINE-3)+2;
00174C  200209     MOV #0x20, W9
001750  07F722     RCALL 0x596
001752  780401     MOV W1, W8
001754  090011     REPEAT #0x11
001756  D80009     DIV.SW W0, W9
001758  FD0401     EXCH W1, W8
00175A  E88408     INC2 W8, W8
108:                       mouseY=rand()%(LINE_PER_SCREEN-3)+2;
00175C  07F71C     RCALL 0x596
00175E  200184     MOV #0x18, W4
001760  090011     REPEAT #0x11
001762  D80004     DIV.SW W0, W4
001764  E88081     INC2 W1, W1
109:                       for (i=0;i<snake.length;i++){
00174E  21EE2A     MOV #0x1EE2, W10
001766  80F6C0     MOV snake, W0
001768  500FE0     SUB W0, #0x0, [W15]
00176A  320010     BRA Z, 0x178C
00176C  78020A     MOV W10, W4
00176E  EB0280     CLR W5
001780  E80285     INC W5, W5
001782  420263     ADD W4, #0x3, W4
001784  528F80     SUB W5, W0, [W15]
001786  39FFF4     BRA NC, 0x1770
110:                           if ((mouseX==snake.body[i].x)&&(mouseY==snake.body[i].y)) break;
001770  784114     MOV.B [W4], W2
001772  FB8302     ZE W2, W6
001774  530F88     SUB W6, W8, [W15]
001776  3A0004     BRA NZ, 0x1780
001778  904314     MOV.B [W4+1], W6
00177A  FB8306     ZE W6, W6
00177C  530F81     SUB W6, W1, [W15]
00177E  320004     BRA Z, 0x1788
111:                       }
112:                       if (i==snake.length) collide=0;
001788  500F85     SUB W0, W5, [W15]
00178A  3AFFE2     BRA NZ, 0x1750
113:                   }//while
114:                   mouse.x=mouseX;
00178C  780008     MOV W8, W0
00178E  B7FFA2     MOV.B WREG, mouse
115:                   mouse.y=mouseY;
001790  780001     MOV W1, W0
001792  B7FFA3     MOV.B WREG, 0x1FA3
116:                   set_curpos(mouse.x,mouse.y);
001794  FB8081     ZE W1, W1
001796  FB8008     ZE W8, W0
001798  07038E     RCALL set_curpos
117:                   put_char(mouse.part);
00179A  BFDFA4     MOV.B 0x1FA4, WREG
00179C  070284     RCALL put_char
118:               }//f()
00179E  78054F     MOV [--W15], W10
0017A0  BE044F     MOV.D [--W15], W8
0017A2  060000     RETURN
119:               
120:               void hide_snake(){
0017A4  BE9F88     MOV.D W8, [W15++]
0017A6  781F8A     MOV W10, [W15++]
121:                   unsigned i;
122:                   for (i=0;i<snake.length;i++){
0017A8  80F6C4     MOV snake, W4
0017AA  520FE0     SUB W4, #0x0, [W15]
0017AC  32000F     BRA Z, 0x17CC
0017AE  21EE38     MOV #0x1EE3, W8
0017B0  EB0480     CLR W9
0017C2  E80489     INC W9, W9
0017C4  440463     ADD W8, #0x3, W8
0017C6  80F6C4     MOV snake, W4
0017C8  520F89     SUB W4, W9, [W15]
0017CA  3EFFF4     BRA GTU, 0x17B4
123:                       set_curpos(snake.body[i].x,snake.body[i].y);
0017B4  784218     MOV.B [W8], W4
0017B6  FB8084     ZE W4, W1
0017B8  97F878     MOV.B [W8-1], W0
0017BA  FB8000     ZE W0, W0
0017BC  07037C     RCALL set_curpos
124:                       put_char(SPACE);
0017B2  B3C20A     MOV #0x20, W10
0017BE  78400A     MOV.B W10, W0
0017C0  070272     RCALL put_char
125:                   }
126:               }//f()
0017CC  78054F     MOV [--W15], W10
0017CE  BE044F     MOV.D [--W15], W8
0017D0  060000     RETURN
127:               
128:               void show_snake(){
0017D2  BE9F88     MOV.D W8, [W15++]
129:                   unsigned i;
130:                   for (i=0;i<snake.length;i++){
0017D4  80F6C4     MOV snake, W4
0017D6  520FE0     SUB W4, #0x0, [W15]
0017D8  32000E     BRA Z, 0x17F6
0017DA  21EE38     MOV #0x1EE3, W8
0017DC  EB0480     CLR W9
0017EC  E80489     INC W9, W9
0017EE  440463     ADD W8, #0x3, W8
0017F0  80F6C4     MOV snake, W4
0017F2  520F89     SUB W4, W9, [W15]
0017F4  3EFFF4     BRA GTU, 0x17DE
131:                       set_curpos(snake.body[i].x,snake.body[i].y);
0017DE  784218     MOV.B [W8], W4
0017E0  FB8084     ZE W4, W1
0017E2  97F878     MOV.B [W8-1], W0
0017E4  FB8000     ZE W0, W0
0017E6  070367     RCALL set_curpos
132:                       put_char(snake.body[i].part);
0017E8  904018     MOV.B [W8+1], W0
0017EA  07025D     RCALL put_char
133:                       
134:                   }//for
135:               }//f()
0017F6  BE044F     MOV.D [--W15], W8
0017F8  060000     RETURN
136:               
137:               
138:               void wait_start_signal(){
0017FA  781F88     MOV W8, [W15++]
139:                   unsigned p;
140:                   p=0;
141:                   print_msg(msgSTART);
0017FC  849090     MOV 0x9212, W0
0017FE  8490A1     MOV 0x9214, W1
001800  07FF9A     RCALL print_msg
142:                   while (!(p&SNES_START)){
001808  600068     AND W0, #0x8, W0
00180A  32FFFC     BRA Z, 0x1804
143:                     p=read_paddle(PADDLE1);
001802  200018     MOV #0x1, W8
001804  780008     MOV W8, W0
001806  0706C3     RCALL read_paddle
144:                   }
145:               }//f()
00180C  78044F     MOV [--W15], W8
00180E  060000     RETURN
146:               
147:               void animate_death(){
001810  BE9F88     MOV.D W8, [W15++]
001812  BE9F8A     MOV.D W10, [W15++]
001814  781F8C     MOV W12, [W15++]
001822  B94B63     MUL.SU W9, #3, W6
001824  21EE34     MOV #0x1EE3, W4
001826  430404     ADD W6, W4, W8
148:                   int i,freq;
149:                   show_snake();
001816  07FFDD     RCALL show_snake
150:                   freq=snake.length*200;
001818  80F6C4     MOV snake, W4
00181E  200C8A     MOV #0xC8, W10
001820  B9A50A     MUL.SS W4, W10, W10
151:                   for (i=snake.length-1;i>=0;i--){
00181A  E90484     DEC W4, W9
00181C  330018     BRA N, 0x184E
001846  E90489     DEC W9, W9
001848  540463     SUB W8, #0x3, W8
00184A  548FE0     SUB W9, #0x0, [W15]
00184C  3DFFEF     BRA GE, 0x182C
152:                       set_curpos(snake.body[i].x,snake.body[i].y);
00182C  784218     MOV.B [W8], W4
00182E  FB8084     ZE W4, W1
001830  97F878     MOV.B [W8-1], W0
001832  FB8000     ZE W0, W0
001834  070340     RCALL set_curpos
153:                       put_char(32);
001828  B3C20B     MOV #0x20, W11
001836  78400B     MOV.B W11, W0
001838  070236     RCALL put_char
154:                       tone(freq,500);
00182A  201F4C     MOV #0x1F4, W12
00183A  78008C     MOV W12, W1
00183C  78000A     MOV W10, W0
00183E  070571     RCALL tone
155:                       wait_n_frame(frames_per_second/2);
001840  D51ECA     LSR frames_per_second, WREG
001842  0704BD     RCALL wait_n_frame
156:                       freq -= 100;
001844  B1064A     SUB #0x64, W10
157:                   }//for
158:               }//f()
00184E  78064F     MOV [--W15], W12
001850  BE054F     MOV.D [--W15], W10
001852  BE044F     MOV.D [--W15], W8
001854  060000     RETURN
159:               
160:               // dead cause
161:               typedef enum DEATH {STARVATION,WALL_COLLISION,TAIL_BITE} death_t;
162:               
163:               unsigned char reset=0;
164:               void game_over(death_t cause){
001856  781F88     MOV W8, [W15++]
001858  780400     MOV W0, W8
165:                   animate_death();
00185A  07FFDA     RCALL animate_death
166:                   print_msg(msgGAME_OVER);
00185C  848FC0     MOV 0x91F8, W0
00185E  848FD1     MOV 0x91FA, W1
001860  07FF6A     RCALL print_msg
167:                   switch (cause){
001862  540FE1     SUB W8, #0x1, [W15]
001864  320008     BRA Z, 0x1876
001866  390003     BRA NC, 0x186E
001868  540FE2     SUB W8, #0x2, [W15]
00186A  3A000C     BRA NZ, 0x1884
00186C  370008     BRA 0x187E
168:                       case STARVATION:
169:                           print_msg(msgSTARVATION);
00186E  849150     MOV 0x922A, W0
001870  849161     MOV 0x922C, W1
001872  07FF61     RCALL print_msg
170:                           break;
001874  370007     BRA 0x1884
171:                       case WALL_COLLISION:
172:                           print_msg(msgWALL_COLLIDE);
001876  849230     MOV 0x9246, W0
001878  849241     MOV 0x9248, W1
00187A  07FF5D     RCALL print_msg
173:                           break;
00187C  370003     BRA 0x1884
174:                       case TAIL_BITE:
175:                           print_msg(msgTAIL_BITE);
00187E  8492F0     MOV 0x925E, W0
001880  849301     MOV 0x9260, W1
001882  07FF59     RCALL print_msg
176:                           break;
177:                   }//switch
178:                   reset=1;
001884  B3C014     MOV #0x1, W4
001886  FD0200     EXCH W0, W4
001888  B7FFFC     MOV.B WREG, reset
00188A  FD0200     EXCH W0, W4
179:                   wait_start_signal();
00188C  07FFB6     RCALL wait_start_signal
180:               }//f()
00188E  78044F     MOV [--W15], W8
001890  060000     RETURN
181:               
182:               void add_calories(unsigned short gain){
183:                   snake.calories+=gain;
001892  B43EDA     ADD 0x1EDA
184:                   print_msg(msgCALORIES);
001894  848ED0     MOV 0x91DA, W0
001896  848EE1     MOV 0x91DC, W1
001898  07FF4E     RCALL print_msg
185:                   print_int(snake.calories,1);
00189A  200011     MOV #0x1, W1
00189C  80F6D0     MOV 0x1EDA, W0
00189E  0702B3     RCALL print_int
186:               }//f()
0018A0  060000     RETURN
187:               
188:               
189:               void burn_calories(unsigned short lost){
190:                   unsigned newLength;
191:                   if (lost < BASE_METABOLISM) lost=BASE_METABOLISM;
0018A2  500FE1     SUB W0, #0x1, [W15]
0018A4  3E0001     BRA GTU, 0x18A8
0018A6  200020     MOV #0x2, W0
192:                   snake.calories -= lost;
0018A8  B53EDA     SUB 0x1EDA
193:                   if (snake.calories<0) snake.calories=0;
194:                   print_msg(msgCALORIES);
0018AA  848ED0     MOV 0x91DA, W0
0018AC  848EE1     MOV 0x91DC, W1
0018AE  07FF43     RCALL print_msg
195:                   clear_eol();
0018B0  0702E1     RCALL clear_eol
196:                   print_int(snake.calories,1);
0018B2  200011     MOV #0x1, W1
0018B4  80F6D0     MOV 0x1EDA, W0
0018B6  0702A7     RCALL print_int
197:                   print_msg(msgSECONDS);
0018B8  848F50     MOV 0x91EA, W0
0018BA  848F61     MOV 0x91EC, W1
0018BC  07FF3C     RCALL print_msg
198:                   print_int(snake.lifespan,1);
0018BE  200011     MOV #0x1, W1
0018C0  80F6E0     MOV 0x1EDC, W0
0018C2  0702A1     RCALL print_int
199:                   hide_snake();
0018C4  07FF6F     RCALL hide_snake
200:                   newLength=snake.calories/MOUSE_CALORIES+1;
0018C6  80F6D4     MOV 0x1EDA, W4
0018CC  200145     MOV #0x14, W5
0018CE  BE9F80     MOV.D W0, [W15++]
0018D0  090011     REPEAT #0x11
0018D2  D88205     DIV.UW W4, W5
0018D4  780200     MOV W0, W4
0018D6  BE004F     MOV.D [--W15], W0
201:                   if (snake.calories){
0018C8  520FE0     SUB W4, #0x0, [W15]
0018CA  32000A     BRA Z, 0x18E0
202:                       snake.length=newLength+1;
0018D8  E88204     INC2 W4, W4
0018DA  88F6C4     MOV W4, snake
203:                       show_snake();
0018DC  07FF7A     RCALL show_snake
0018DE  370002     BRA 0x18E4
204:                   } else{
205:                       game_over(STARVATION);
0018E0  EB0000     CLR W0
0018E2  07FFB9     RCALL game_over
206:                       return;
207:                   }
208:               }//f()
0018E4  060000     RETURN
209:               
210:               void check_if_got_mouse(){
211:                   if ((mouse.x==snake.body[0].x) && (mouse.y==snake.body[0].y)){
0018E6  21EE24     MOV #0x1EE2, W4
0018E8  784214     MOV.B [W4], W4
0018EA  21FA25     MOV #0x1FA2, W5
0018EC  784295     MOV.B [W5], W5
0018EE  52CF84     SUB.B W5, W4, [W15]
0018F0  3A006A     BRA NZ, 0x19C6
0018F2  21EE34     MOV #0x1EE3, W4
0018F4  784214     MOV.B [W4], W4
0018F6  21FA35     MOV #0x1FA3, W5
0018F8  784295     MOV.B [W5], W5
0018FA  52CF84     SUB.B W5, W4, [W15]
0018FC  3A0064     BRA NZ, 0x19C6
212:                       add_calories(MOUSE_CALORIES);
0018FE  200140     MOV #0x14, W0
001900  07FFC8     RCALL add_calories
213:                       snake.length++;
001902  80F6C4     MOV snake, W4
001904  E80284     INC W4, W5
001906  88F6C5     MOV W5, snake
214:                       snake.body[snake.length-1].part=RING;
001908  B92363     MUL.SU W4, #3, W6
00190A  B3C861     MOV #0x86, W1
00190C  21EE40     MOV #0x1EE4, W0
00190E  7B7001     MOV.B W1, [W0+W6]
215:                       if (snake.dx){
001910  80F6F6     MOV 0x1EDE, W6
001912  530FE0     SUB W6, #0x0, [W15]
001914  32002D     BRA Z, 0x1970
216:                           if (snake.body[snake.length-2].y==snake.body[0].y){
001916  E98285     DEC2 W5, W5
001918  B92863     MUL.SU W5, #3, W0
00191A  21EE27     MOV #0x1EE2, W7
00191C  400387     ADD W0, W7, W7
00191E  904017     MOV.B [W7+1], W0
001920  21EE37     MOV #0x1EE3, W7
001922  784397     MOV.B [W7], W7
001924  504F87     SUB.B W0, W7, [W15]
001926  3A000C     BRA NZ, 0x1940
217:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x-snake.dx;
001928  B92063     MUL.SU W4, #3, W0
00192A  21EE24     MOV #0x1EE2, W4
00192C  420200     ADD W4, W0, W4
00192E  B92863     MUL.SU W5, #3, W0
001930  4002EA     ADD W0, #0xA, W5
001932  21ED87     MOV #0x1ED8, W7
001934  7AC067     MOV.B [W7+W5], W0
001936  504A06     SUB.B W0, W6, [W4]
218:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
001938  438285     ADD W7, W5, W5
00193A  904295     MOV.B [W5+1], W5
00193C  984215     MOV.B W5, [W4+1]
00193E  370042     BRA 0x19C4
219:                           }else{
220:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001940  B92063     MUL.SU W4, #3, W0
001942  B92B63     MUL.SU W5, #3, W6
001944  4302EA     ADD W6, #0xA, W5
001946  21ED86     MOV #0x1ED8, W6
001948  4303EA     ADD W6, #0xA, W7
00194A  7AC166     MOV.B [W6+W5], W2
00194C  787382     MOV.B W2, [W7+W0]
221:                               if (snake.body[0].y>snake.body[snake.length-2].y){
00194E  430285     ADD W6, W5, W5
001950  904295     MOV.B [W5+1], W5
001952  21EE36     MOV #0x1EE3, W6
001954  784316     MOV.B [W6], W6
001956  534F85     SUB.B W6, W5, [W15]
001958  360005     BRA LEU, 0x1964
222:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y-1;
00195A  21EE24     MOV #0x1EE2, W4
00195C  420200     ADD W4, W0, W4
00195E  E94285     DEC.B W5, W5
001960  984215     MOV.B W5, [W4+1]
001962  370030     BRA 0x19C4
223:                               }else{
224:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y+1;
001964  B92363     MUL.SU W4, #3, W6
001966  21EE24     MOV #0x1EE2, W4
001968  420206     ADD W4, W6, W4
00196A  E84285     INC.B W5, W5
00196C  984215     MOV.B W5, [W4+1]
00196E  37002A     BRA 0x19C4
225:                               }//if
226:                           }//if
227:                       }else {
228:                           if (snake.body[snake.length-2].x==snake.body[0].x){
001970  E98285     DEC2 W5, W5
001972  B92B63     MUL.SU W5, #3, W6
001974  43036A     ADD W6, #0xA, W6
001976  21ED87     MOV #0x1ED8, W7
001978  7B43E7     MOV.B [W7+W6], W7
00197A  21EE26     MOV #0x1EE2, W6
00197C  784316     MOV.B [W6], W6
00197E  53CF86     SUB.B W7, W6, [W15]
001980  3A000C     BRA NZ, 0x199A
229:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001982  B92063     MUL.SU W4, #3, W0
001984  21EE24     MOV #0x1EE2, W4
001986  420200     ADD W4, W0, W4
001988  784A07     MOV.B W7, [W4]
230:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y-snake.dy;
00198A  B92863     MUL.SU W5, #3, W0
00198C  21EE26     MOV #0x1EE2, W6
00198E  400286     ADD W0, W6, W5
001990  904315     MOV.B [W5+1], W6
001992  80F705     MOV 0x1EE0, W5
001994  534285     SUB.B W6, W5, W5
001996  984215     MOV.B W5, [W4+1]
001998  370015     BRA 0x19C4
231:                           }else{
232:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
00199A  B92063     MUL.SU W4, #3, W0
00199C  21EE27     MOV #0x1EE2, W7
00199E  438000     ADD W7, W0, W0
0019A0  B92963     MUL.SU W5, #3, W2
0019A2  4102EA     ADD W2, #0xA, W5
0019A4  21ED87     MOV #0x1ED8, W7
0019A6  438085     ADD W7, W5, W1
0019A8  904091     MOV.B [W1+1], W1
0019AA  984011     MOV.B W1, [W0+1]
233:                               if (snake.body[0].x>snake.body[snake.length-2].x){
0019AC  7AC2E7     MOV.B [W7+W5], W5
0019AE  534F85     SUB.B W6, W5, [W15]
0019B0  360005     BRA LEU, 0x19BC
234:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x-1;
0019B2  B92363     MUL.SU W4, #3, W6
0019B4  21EE24     MOV #0x1EE2, W4
0019B6  420206     ADD W4, W6, W4
0019B8  E94A05     DEC.B W5, [W4]
0019BA  370004     BRA 0x19C4
235:                               }else{
236:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x+1;
0019BC  B92363     MUL.SU W4, #3, W6
0019BE  21EE24     MOV #0x1EE2, W4
0019C0  420206     ADD W4, W6, W4
0019C2  E84A05     INC.B W5, [W4]
237:                               }//if
238:                           }//if
239:               
240:                       }//if
241:                       new_mouse();
0019C4  07FEC1     RCALL new_mouse
242:                   }
243:               }//f()
0019C6  060000     RETURN
244:               
245:               int bit_himself(){
246:                   int i;
247:                   for (i=1;i<snake.length;i++){
0019C8  80F6C7     MOV snake, W7
0019CC  538FE1     SUB W7, #0x1, [W15]
0019CE  360011     BRA LEU, 0x19F2
0019D8  200015     MOV #0x1, W5
0019E4  E80285     INC W5, W5
0019E6  420263     ADD W4, #0x3, W4
0019E8  538F85     SUB W7, W5, [W15]
0019EA  3EFFF7     BRA GTU, 0x19DA
248:                       if ((snake.body[0].x==snake.body[i].x) &&(snake.body[0].y==snake.body[i].y)){
0019D0  BFDEE2     MOV.B 0x1EE2, WREG
0019D2  21EE31     MOV #0x1EE3, W1
0019D4  784091     MOV.B [W1], W1
0019D6  21EE54     MOV #0x1EE5, W4
0019DA  504F94     SUB.B W0, [W4], [W15]
0019DC  3A0003     BRA NZ, 0x19E4
0019DE  904314     MOV.B [W4+1], W6
0019E0  50CF86     SUB.B W1, W6, [W15]
0019E2  320006     BRA Z, 0x19F0
249:                           return 1;
0019F0  200010     MOV #0x1, W0
250:                       }
251:                   }
252:                   return 0;
0019CA  EB0000     CLR W0
0019EC  EB0000     CLR W0
0019EE  370001     BRA 0x19F2
253:               }//f()
0019F2  060000     RETURN
254:               
255:               void move_snake(){
001A0A  B92363     MUL.SU W4, #3, W6
001A0C  21EE24     MOV #0x1EE2, W4
001A0E  430204     ADD W6, W4, W4
001A10  21EDF5     MOV #0x1EDF, W5
256:                   unsigned i;
257:                   if (!(snake.dx || snake.dy)) return;
0019F4  80F6F4     MOV 0x1EDE, W4
0019F6  520FE0     SUB W4, #0x0, [W15]
0019F8  3A0003     BRA NZ, 0x1A00
0019FA  80F704     MOV 0x1EE0, W4
0019FC  520FE0     SUB W4, #0x0, [W15]
0019FE  32002F     BRA Z, 0x1A5E
258:                   hide_snake();
001A00  07FED1     RCALL hide_snake
259:                   for (i=snake.length-1;i;i--){
001A02  80F6C4     MOV snake, W4
001A04  520FE1     SUB W4, #0x1, [W15]
001A06  32000C     BRA Z, 0x1A20
001A1C  520F85     SUB W4, W5, [W15]
001A1E  3AFFF9     BRA NZ, 0x1A12
260:                       snake.body[i].x = snake.body[i-1].x;
001A08  E98204     DEC2 W4, W4
001A12  784314     MOV.B [W4], W6
001A14  984236     MOV.B W6, [W4+3]
261:                       snake.body[i].y = snake.body[i-1].y;
001A16  904314     MOV.B [W4+1], W6
001A18  984246     MOV.B W6, [W4+4]
001A1A  520263     SUB W4, #0x3, W4
262:                   }
263:                   snake.body[0].x += snake.dx;
001A20  80F6F5     MOV 0x1EDE, W5
001A22  21EE24     MOV #0x1EE2, W4
001A24  42C294     ADD.B W5, [W4], W5
001A26  FD0280     EXCH W0, W5
001A28  B7FEE2     MOV.B WREG, 0x1EE2
001A2A  FD0280     EXCH W0, W5
264:                   snake.body[0].y += snake.dy;
001A2C  80F704     MOV 0x1EE0, W4
001A2E  21EE36     MOV #0x1EE3, W6
001A30  424216     ADD.B W4, [W6], W4
001A32  FD0200     EXCH W0, W4
001A34  B7FEE3     MOV.B WREG, 0x1EE3
001A36  FD0200     EXCH W0, W4
265:                   if ((snake.body[0].x<1)||(snake.body[0].x>=(CHAR_PER_LINE)) ||
001A38  E94285     DEC.B W5, W5
001A3A  B3C216     MOV #0x21, W6
001A3C  52CF86     SUB.B W5, W6, [W15]
001A3E  3E0004     BRA GTU, 0x1A48
001A40  524FE1     SUB.B W4, #0x1, [W15]
001A42  360002     BRA LEU, 0x1A48
266:                       (snake.body[0].y<2) || (snake.body[0].y>=LINE_PER_SCREEN-1)){
001A44  524FF9     SUB.B W4, #0x19, [W15]
001A46  360003     BRA LEU, 0x1A4E
267:                       game_over(WALL_COLLISION);
001A48  200010     MOV #0x1, W0
001A4A  07FF05     RCALL game_over
001A4C  370008     BRA 0x1A5E
268:                   }else if (bit_himself()){
001A4E  07FFBC     RCALL bit_himself
001A50  500FE0     SUB W0, #0x0, [W15]
001A52  320003     BRA Z, 0x1A5A
269:                       game_over(TAIL_BITE);
001A54  200020     MOV #0x2, W0
001A56  07FEFF     RCALL game_over
001A58  370002     BRA 0x1A5E
270:                   }else{
271:                       check_if_got_mouse();
001A5A  07FF45     RCALL check_if_got_mouse
272:                       show_snake();
001A5C  07FEBA     RCALL show_snake
273:                   }//if
274:               }//f()
001A5E  060000     RETURN
275:               
276:               void present_game(){
277:                   clear_screen();
001A60  0701A6     RCALL clear_screen
278:                   print("**************\r");
001A62  290BA0     MOV #0x90BA, W0
001A64  0701AB     RCALL print
279:                   print("* SNAKE GAME *\r");
001A66  290CA0     MOV #0x90CA, W0
001A68  0701A9     RCALL print
280:                   print("**************\r\r");
001A6A  290DA0     MOV #0x90DA, W0
001A6C  0701A7     RCALL print
281:                   print("Eating a mouse increase snake length.\r");
001A6E  290EB0     MOV #0x90EB, W0
001A70  0701A5     RCALL print
282:                   print("Snake burn 10% of is calaries/sec.\r");
001A72  291120     MOV #0x9112, W0
001A74  0701A3     RCALL print
283:                   print("Die of starvation when calories=0.\r");
001A76  291360     MOV #0x9136, W0
001A78  0701A1     RCALL print
284:                   print("Eating a mouse give 20 calories.\r");
001A7A  2915A0     MOV #0x915A, W0
001A7C  07019F     RCALL print
285:                   print("Die when hitting wall.\r");
001A7E  2917C0     MOV #0x917C, W0
001A80  07019D     RCALL print
286:                   print("Die when bitting his tail.\r\r");
001A82  291940     MOV #0x9194, W0
001A84  07019B     RCALL print
287:                   print("Use ARROWS to control snake.\r");
001A86  291B10     MOV #0x91B1, W0
001A88  070199     RCALL print
288:                   wait_start_signal();
001A8A  07FEB7     RCALL wait_start_signal
289:               }//f()
001A8C  060000     RETURN
290:               
291:               void game_init(){
001A8E  781F88     MOV W8, [W15++]
292:                   reset=0;
001A90  EF7FFC     CLR.B reset
293:                   srand(time(0));
001A92  EB0000     CLR W0
001A94  07F403     RCALL 0x29C
001A96  07F578     RCALL 0x588
294:                   //snake initialisation
295:                   snake.dx=0;
001A98  EB0400     CLR W8
001A9A  88F6F8     MOV W8, 0x1EDE
296:                   snake.dy=0;
001A9C  88F708     MOV W8, 0x1EE0
297:                   snake.length=2;
001A9E  200024     MOV #0x2, W4
001AA0  88F6C4     MOV W4, snake
298:                   snake.calories=MOUSE_CALORIES;
001AA2  200144     MOV #0x14, W4
001AA4  88F6D4     MOV W4, 0x1EDA
299:                   snake.lifespan=0;
001AA6  88F6E8     MOV W8, 0x1EDC
300:                   snake.body[0].x=12;
001AA8  B3C0C4     MOV #0xC, W4
001AAA  FD0200     EXCH W0, W4
001AAC  B7FEE2     MOV.B WREG, 0x1EE2
001AAE  B7FEE3     MOV.B WREG, 0x1EE3
001AB0  FD0200     EXCH W0, W4
301:                   snake.body[0].y=12;
302:                   snake.body[0].part=HEAD_RIGHT;
001AB2  B3C875     MOV #0x87, W5
001AB4  FD0280     EXCH W0, W5
001AB6  B7FEE4     MOV.B WREG, 0x1EE4
001AB8  FD0280     EXCH W0, W5
303:                   snake.body[1].x=11;
001ABA  B3C0B5     MOV #0xB, W5
001ABC  FD0280     EXCH W0, W5
001ABE  B7FEE5     MOV.B WREG, 0x1EE5
001AC0  FD0280     EXCH W0, W5
304:                   snake.body[1].y=12;
001AC2  FD0200     EXCH W0, W4
001AC4  B7FEE6     MOV.B WREG, 0x1EE6
001AC6  FD0200     EXCH W0, W4
305:                   snake.body[1].part=RING;
001AC8  B3C864     MOV #0x86, W4
001ACA  FD0200     EXCH W0, W4
001ACC  B7FEE7     MOV.B WREG, 0x1EE7
001ACE  FD0200     EXCH W0, W4
306:                   mouse.part=MOUSE;
001AD0  424267     ADD.B W4, #0x7, W4
001AD2  FD0200     EXCH W0, W4
001AD4  B7FFA4     MOV.B WREG, 0x1FA4
001AD6  FD0200     EXCH W0, W4
307:                   clear_screen();
001AD8  07016A     RCALL clear_screen
308:                   print_msg(msgCALORIES);
001ADA  848ED0     MOV 0x91DA, W0
001ADC  848EE1     MOV 0x91DC, W1
001ADE  07FE2B     RCALL print_msg
309:                   print_int(snake.calories,1);
001AE0  200011     MOV #0x1, W1
001AE2  80F6D0     MOV 0x1EDA, W0
001AE4  070190     RCALL print_int
310:                   print_msg(msgSECONDS);
001AE6  848F50     MOV 0x91EA, W0
001AE8  848F61     MOV 0x91EC, W1
001AEA  07FE25     RCALL print_msg
311:                   print_int(snake.lifespan,1);
001AEC  200011     MOV #0x1, W1
001AEE  80F6E0     MOV 0x1EDC, W0
001AF0  07018A     RCALL print_int
312:                   //draw  borders
313:                   rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001AF2  200014     MOV #0x1, W4
001AF4  200D73     MOV #0xD7, W3
001AF6  780103     MOV W3, W2
001AF8  200081     MOV #0x8, W1
001AFA  780008     MOV W8, W0
001AFC  07FC5A     RCALL rectangle
314:                   new_mouse();
001AFE  07FE24     RCALL new_mouse
315:                   show_snake();
001B00  07FE68     RCALL show_snake
316:               }//f()
001B02  78044F     MOV [--W15], W8
001B04  060000     RETURN
317:               
318:               
319:               int main(void) {
001B06  BE9F88     MOV.D W8, [W15++]
001B08  781F8A     MOV W10, [W15++]
320:                   unsigned p,frame_count;
321:                   PICvision_init();
001B0A  0704E6     RCALL PICvision_init
322:               //    timers_init(100);
323:               //    sound_init(10);
324:                   present_game();
001B0C  07FFA9     RCALL present_game
325:                   game_init();
001B0E  07FFBF     RCALL game_init
326:                   frame_count=0;
001B10  EB0400     CLR W8
327:                   while (1){
328:                       wait_n_frame(10);
001B16  2000A0     MOV #0xA, W0
001B18  070352     RCALL wait_n_frame
329:                       frame_count += 10;
001B1A  44046A     ADD W8, #0xA, W8
330:                       if (frame_count%frames_per_second==0){
001B1C  80F654     MOV frames_per_second, W4
001B1E  BE9F80     MOV.D W0, [W15++]
001B20  090011     REPEAT #0x11
001B22  D88404     DIV.UW W8, W4
001B24  780201     MOV W1, W4
001B26  BE004F     MOV.D [--W15], W0
001B28  520FE0     SUB W4, #0x0, [W15]
001B2A  3A000E     BRA NZ, 0x1B48
331:                           snake.lifespan +=1;
001B2C  EC3EDC     INC 0x1EDC
332:                           burn_calories(snake.calories / 10);
001B2E  80F6D0     MOV 0x1EDA, W0
001B30  2000A4     MOV #0xA, W4
001B32  781F81     MOV W1, [W15++]
001B34  090011     REPEAT #0x11
001B36  D88004     DIV.UW W0, W4
001B38  7800CF     MOV [--W15], W1
001B3A  07FEB3     RCALL burn_calories
333:                           rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001B3C  200014     MOV #0x1, W4
001B3E  200D73     MOV #0xD7, W3
001B40  780103     MOV W3, W2
001B42  200081     MOV #0x8, W1
001B44  EB0000     CLR W0
001B46  07FC35     RCALL rectangle
334:                       }
335:                       p=read_paddle(PADDLE1);
001B48  200010     MOV #0x1, W0
001B4A  070521     RCALL read_paddle
336:                       switch (p){
001B12  200209     MOV #0x20, W9
001B4C  500F89     SUB W0, W9, [W15]
001B4E  32002A     BRA Z, 0x1BA4
001B50  3E0003     BRA GTU, 0x1B58
001B52  500FF0     SUB W0, #0x10, [W15]
001B54  3A0030     BRA NZ, 0x1BB6
001B56  37001C     BRA 0x1B90
001B58  200404     MOV #0x40, W4
001B5A  500F84     SUB W0, W4, [W15]
001B5C  320004     BRA Z, 0x1B66
001B5E  200804     MOV #0x80, W4
001B60  500F84     SUB W0, W4, [W15]
001B62  3A0029     BRA NZ, 0x1BB6
001B64  37000A     BRA 0x1B7A
337:                           case SNES_LEFT:
338:                               if (snake.dx==1){
001B66  80F6F4     MOV 0x1EDE, W4
001B68  520FE1     SUB W4, #0x1, [W15]
001B6A  320025     BRA Z, 0x1BB6
339:                                   break;
340:                               }
341:                               snake.dx =-1;
001B6C  EFBEDE     SETM 0x1EDE
342:                               snake.dy=0;
001B6E  EF3EE0     CLR 0x1EE0
343:                               snake.body[0].part=HEAD_LEFT;
001B70  B3C884     MOV #0x88, W4
001B72  FD0200     EXCH W0, W4
001B74  B7FEE4     MOV.B WREG, 0x1EE4
001B76  FD0200     EXCH W0, W4
344:                               break;
001B78  37001E     BRA 0x1BB6
345:                           case SNES_RIGHT:
346:                               if (snake.dx==-1){
001B7A  80F6F4     MOV 0x1EDE, W4
001B7C  420FE1     ADD W4, #0x1, [W15]
001B7E  32001B     BRA Z, 0x1BB6
347:                                   break;
348:                               }
349:                               snake.dx=1;
001B80  200014     MOV #0x1, W4
001B82  88F6F4     MOV W4, 0x1EDE
350:                               snake.dy=0;
001B84  EF3EE0     CLR 0x1EE0
351:                               snake.body[0].part=HEAD_RIGHT;
001B86  B3C874     MOV #0x87, W4
001B88  FD0200     EXCH W0, W4
001B8A  B7FEE4     MOV.B WREG, 0x1EE4
001B8C  FD0200     EXCH W0, W4
352:                               break;
001B8E  370013     BRA 0x1BB6
353:                           case SNES_UP:
354:                               if (snake.dy==1){
001B90  80F704     MOV 0x1EE0, W4
001B92  520FE1     SUB W4, #0x1, [W15]
001B94  320010     BRA Z, 0x1BB6
355:                                   break;
356:                               }
357:                               snake.dy=-1;
001B96  EFBEE0     SETM 0x1EE0
358:                               snake.dx=0;
001B98  EF3EDE     CLR 0x1EDE
359:                               snake.body[0].part=HEAD_UP;
001B9A  B3C894     MOV #0x89, W4
001B9C  FD0200     EXCH W0, W4
001B9E  B7FEE4     MOV.B WREG, 0x1EE4
001BA0  FD0200     EXCH W0, W4
360:                               break;
001BA2  370009     BRA 0x1BB6
361:                           case SNES_DOWN:
362:                               if (snake.dy==-1){
001BA4  80F704     MOV 0x1EE0, W4
001BA6  420FE1     ADD W4, #0x1, [W15]
001BA8  320006     BRA Z, 0x1BB6
363:                                   break;
364:                               }
365:                               snake.dy=1;
001BAA  200014     MOV #0x1, W4
001BAC  88F704     MOV W4, 0x1EE0
366:                               snake.dx=0;
001BAE  EF3EDE     CLR 0x1EDE
367:                               snake.body[0].part=HEAD_DOWN;
001B14  B3C8AA     MOV #0x8A, W10
001BB0  FD0500     EXCH W0, W10
001BB2  B7FEE4     MOV.B WREG, 0x1EE4
001BB4  FD0500     EXCH W0, W10
368:                               break;
369:               //            default:
370:               //                snake.dx=0;
371:               //                snake.dy=0;
372:               //                break;
373:                       }//switch
374:                       move_snake();
001BB6  07FF1E     RCALL move_snake
375:                       if (reset) game_init();
001BB8  21FFC4     MOV #0x1FFC, W4
001BBA  784214     MOV.B [W4], W4
001BBC  524FE0     SUB.B W4, #0x0, [W15]
001BBE  32FFAB     BRA Z, 0x1B16
001BC0  07FF66     RCALL game_init
001BC2  37FFA9     BRA 0x1B16
376:                   }//while
377:                   return (EXIT_SUCCESS);
378:               }//main()
379:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/hardwareProfile.c  ------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   hardwareProfile.h
21:                 * Author: jacques Deschênes
22:                 * Description:  try to centralize  hardware specific.
23:                 * Created on 1 march 2014
24:                 */
25:                
26:                #include "hardwareProfile.h"
27:                
28:                void HardwareConfig(){
29:                    // peripheral to pin association.
30:                    PPSUnLock;
0024E8  803A16     MOV OSCCON, W6
0024EA  B20BF6     AND #0xBF, W6
0024EC  200464     MOV #0x46, W4
0024EE  200575     MOV #0x57, W5
0024F0  207427     MOV #0x742, W7
0024F2  784B84     MOV.B W4, [W7]
0024F4  784B85     MOV.B W5, [W7]
0024F6  784B86     MOV.B W6, [W7]
31:                    PPSOutput(PPS_RP5,PPS_SDO1);   // video pixels output
0024F8  803626     MOV RPOR2, W6
0024FA  2E0FF7     MOV #0xE0FF, W7
0024FC  630307     AND W6, W7, W6
0024FE  207000     MOV #0x700, W0
002500  730300     IOR W6, W0, W6
002502  883626     MOV W6, RPOR2
32:                    PPSOutput(PPS_RP6,PPS_OC4);  // video delay output
002504  803630     MOV RPOR3, W0
002506  2FFE06     MOV #0xFFE0, W6
002508  600006     AND W0, W6, W0
00250A  B30150     IOR #0x15, W0
00250C  883630     MOV W0, RPOR3
33:                    PPSOutput(PPS_RP7,PPS_OC1);  // video sync output
00250E  803630     MOV RPOR3, W0
002510  600387     AND W0, W7, W7
002512  212000     MOV #0x1200, W0
002514  738380     IOR W7, W0, W7
002516  883637     MOV W7, RPOR3
34:                    PPSOutput(PPS_RP8,PPS_OC2);  // audio output
002518  803647     MOV RPOR4, W7
00251A  638306     AND W7, W6, W6
00251C  B30136     IOR #0x13, W6
00251E  883646     MOV W6, RPOR4
35:                    PPSLock;
002520  803A16     MOV OSCCON, W6
002522  A06006     BSET W6, #6
002524  207427     MOV #0x742, W7
002526  784B84     MOV.B W4, [W7]
002528  784B85     MOV.B W5, [W7]
00252A  784B86     MOV.B W6, [W7]
36:                    // pins data direction
37:                    P_PIXEL_OUT_TRIS=0;     // video pixels output
00252C  A9A2C8     BCLR TRISB, #5
38:                    P_VDLY_OUT_TRIS=0;     // video delay output
00252E  A9C2C8     BCLR TRISB, #6
39:                    P_VSYNC_OUT_TRIS=0;     // video sync output
002530  A9E2C8     BCLR TRISB, #7
40:                    P_AUDIO_OUT_TRIS=0;     // audio output
002532  A902C9     BCLR 0x2C9, #0
41:                    P_NOISE_OUT_TRIS=0;     /// white noise output
002534  A942C9     BCLR 0x2C9, #2
42:                    P_PIXDLY_IN_TRIS=1;     //input video pixels delay
002536  A822C9     BSET 0x2C9, #1
43:                    P_VIDEO_MODE_TRIS=1;    //input NTSC/PAL select input
002538  A882C9     BSET 0x2C9, #4
44:                    VIDMODE_ANDIS=1;   // disable ADC  on NTSC/PAL select input.
00253A  A8832D     BSET 0x32D, #4
45:                    // paddles interface I/O setting
46:                    P_PDL1_DAT_TRIS=1;      // paddle 1 data as input
00253C  A802C0     BSET TRISA, #0
47:                    P_PDL2_DAT_TRIS=1;      // paddle 2 data as input
00253E  A822C0     BSET TRISA, #1
48:                    P_PDL_CLK_TRIS=0;       // paddles clock signal as output
002540  A902C8     BCLR TRISB, #0
49:                    P_PDL_LATCH_TRIS=0;     // paddles latch signal as output
002542  A922C8     BCLR TRISB, #1
50:                    P_PDL1_ANDIS=1;         // disable analog input
002544  A8032C     BSET AD1PCFG, #0
51:                    P_PDL2_ANDIS=1;         // disable analog input
002546  A8232C     BSET AD1PCFG, #1
52:                    // interrupts priorities
53:                    VSYNCIP=7;  // timer interrupt used for video output must have highest priority
002548  270000     MOV #0x7000, W0
00254A  B720A6     IOR IPC1
54:                    PIXIP=7;  // change notification interrupt used for video pixels must have highest priority
00254C  B720AC     IOR IPC4
55:                    AUDIOIP=3; // audio output timer interrupt priority
00254E  800544     MOV IPC2, W4
002550  B30034     IOR #0x3, W4
002552  A12004     BCLR W4, #2
002554  880544     MOV W4, IPC2
56:                    SYSTICKIP=2; // system ticks timer interrupt priority
002556  800524     MOV IPC0, W4
002558  A1C004     BCLR W4, #12
00255A  A0D004     BSET W4, #13
00255C  A1E004     BCLR W4, #14
00255E  880524     MOV W4, IPC0
57:                }//f()
002560  060000     RETURN
58:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/graphics.c  -------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   graphics.h
21:                 * Author: jacques Deschênes
22:                 * Description: Draw geometrics figures.
23:                 *      coordinates origin is screen top,left, x increase to right, y increase to bottom
24:                 * Created on 28 février 2014, 13:07
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "graphics.h"
29:                
30:                // draw a dot
31:                
32:                void plot(int x, int y, int color){
33:                    int h,ofs;
34:                    if ((y>=VPIXELS)||(x>=HPIXELS)) return; // bound check
001284  200D74     MOV #0xD7, W4
001286  508F84     SUB W1, W4, [W15]
001288  3C0028     BRA GT, 0x12DA
00128A  500F84     SUB W0, W4, [W15]
00128C  3C0026     BRA GT, 0x12DA
35:                    h= x/8;
00128E  200084     MOV #0x8, W4
001290  781F81     MOV W1, [W15++]
001292  090011     REPEAT #0x11
001294  D80004     DIV.SW W0, W4
001296  780201     MOV W1, W4
001298  7800CF     MOV [--W15], W1
36:                    ofs = 7 - x%8;
00129A  1202E7     SUBR W4, #0x7, W5
37:                    if (color==INVERT)
00129C  510FE2     SUB W2, #0x2, [W15]
00129E  3A0009     BRA NZ, 0x12B2
38:                        video_buffer[y][h] ^= (1<<ofs);
0012A0  208006     MOV #0x800, W6
0012A2  B9097B     MUL.SU W1, #27, W2
0012A4  400082     ADD W0, W2, W1
0012A6  430381     ADD W6, W1, W7
0012A8  200014     MOV #0x1, W4
0012AA  DD2285     SL W4, W5, W5
0012AC  78C266     MOV.B [W6+W1], W4
0012AE  6A4B85     XOR.B W4, W5, [W7]
0012B0  370014     BRA 0x12DA
39:                    else if (color==WHITE)
0012B2  510FE1     SUB W2, #0x1, [W15]
0012B4  3A0009     BRA NZ, 0x12C8
40:                        video_buffer[y][h]|= (1<<ofs);
0012B6  208006     MOV #0x800, W6
0012B8  B9097B     MUL.SU W1, #27, W2
0012BA  400082     ADD W0, W2, W1
0012BC  430381     ADD W6, W1, W7
0012BE  200014     MOV #0x1, W4
0012C0  DD2285     SL W4, W5, W5
0012C2  78C266     MOV.B [W6+W1], W4
0012C4  724B85     IOR.B W4, W5, [W7]
0012C6  370009     BRA 0x12DA
41:                    else
42:                        video_buffer[y][h]&= ~(1<<ofs);
0012C8  208006     MOV #0x800, W6
0012CA  B9097B     MUL.SU W1, #27, W2
0012CC  400082     ADD W0, W2, W1
0012CE  430381     ADD W6, W1, W7
0012D0  200014     MOV #0x1, W4
0012D2  DD2285     SL W4, W5, W5
0012D4  EAC285     COM.B W5, W5
0012D6  78C366     MOV.B [W6+W1], W6
0012D8  62CB86     AND.B W5, W6, [W7]
43:                } // plot()
0012DA  060000     RETURN
44:                
45:                // dessine une droite en utilisant l'algorithme de Bresenham
46:                void line(int x1, int y1, int x2, int y2, int color){
0012DC  4787EA     ADD W15, #0xA, W15
0012DE  BE9F88     MOV.D W8, [W15++]
0012E0  BE9F8A     MOV.D W10, [W15++]
0012E2  BE9F8C     MOV.D W12, [W15++]
0012E4  781F8E     MOV W14, [W15++]
0012E6  780400     MOV W0, W8
0012E8  780501     MOV W1, W10
0012EA  780582     MOV W2, W11
0012EC  9FB7F3     MOV W3, [W15-18]
0012EE  780604     MOV W4, W12
001304  448408     ADD W9, W8, W8
001306  370004     BRA 0x1310
00131A  540209     SUB W8, W9, W4
001330  44850A     ADD W9, W10, W10
00133C  550209     SUB W10, W9, W4
47:                    int deltax,deltay;
48:                    plot(x1,y1,color);
0012F0  78010C     MOV W12, W2
0012F2  78008A     MOV W10, W1
0012F4  780008     MOV W8, W0
0012F6  07FFC6     RCALL plot
49:                    if (y1==y2){// cas particulier ligne horizontale
0012F8  97B27F     MOV [W15-18], W4
0012FA  550F84     SUB W10, W4, [W15]
0012FC  3A0012     BRA NZ, 0x1322
50:                        deltax= x1<x2?1:-1;
0012FE  540F8B     SUB W8, W11, [W15]
001300  3D0003     BRA GE, 0x1308
001302  200019     MOV #0x1, W9
001308  EB8480     SETM W9
51:                        while (x1!=x2){
00130A  540F8B     SUB W8, W11, [W15]
00130C  3AFFFB     BRA NZ, 0x1304
00130E  37004B     BRA 0x13A6
00131C  558F84     SUB W11, W4, [W15]
00131E  3AFFF8     BRA NZ, 0x1310
001320  370042     BRA 0x13A6
52:                            x1 += deltax;
53:                            plot(x1,y1,color);
001310  78010C     MOV W12, W2
001312  78008A     MOV W10, W1
001314  780008     MOV W8, W0
001316  07FFB6     RCALL plot
001318  440409     ADD W8, W9, W8
54:                        }
55:                    }else if (x1==x2){ // cas particulier ligne verticale
001322  540F8B     SUB W8, W11, [W15]
001324  3A0010     BRA NZ, 0x1346
56:                        deltay= y1<y2?1:-1;
001326  EB8480     SETM W9
001328  97B2FF     MOV [W15-18], W5
00132A  550F85     SUB W10, W5, [W15]
00132C  3D0001     BRA GE, 0x1330
00132E  200019     MOV #0x1, W9
57:                        while (y1!=y2){
00133E  97B2FF     MOV [W15-18], W5
001340  528F84     SUB W5, W4, [W15]
001342  3AFFF7     BRA NZ, 0x1332
001344  370030     BRA 0x13A6
58:                            y1+=deltay;
59:                            plot(x1,y1,color);
001332  78010C     MOV W12, W2
001334  78008A     MOV W10, W1
001336  780008     MOV W8, W0
001338  07FFA5     RCALL plot
00133A  450509     ADD W10, W9, W10
60:                        }
61:                    }else{
62:                        int sx,sy,err,e2;
63:                        deltax=abs(x2-x1);
001346  558708     SUB W11, W8, W14
001348  A7F00E     BTSC W14, #15
00134A  EA070E     NEG W14, W14
64:                        deltay=abs(y2-y1);
00134C  97B2FF     MOV [W15-18], W5
00134E  52820A     SUB W5, W10, W4
001350  A7F004     BTSC W4, #15
001352  EA0204     NEG W4, W4
001354  9FBF84     MOV W4, [W15-16]
65:                        sx = x1<x2?1:-1;
001356  EB8200     SETM W4
001358  9FB7E4     MOV W4, [W15-20]
00135A  540F8B     SUB W8, W11, [W15]
00135C  3D0002     BRA GE, 0x1362
00135E  200015     MOV #0x1, W5
001360  9FB7E5     MOV W5, [W15-20]
66:                        sy = y1<y2?1:-1;
001362  EB8200     SETM W4
001364  9FB7D4     MOV W4, [W15-22]
001366  97B2FF     MOV [W15-18], W5
001368  550F85     SUB W10, W5, [W15]
00136A  3D0002     BRA GE, 0x1370
00136C  200014     MOV #0x1, W4
00136E  9FB7D4     MOV W4, [W15-22]
67:                        err=deltax-deltay;
001370  97BA8F     MOV [W15-16], W5
001372  570485     SUB W14, W5, W9
68:                        while (!((x1==x2) && (y1==y2))){
001378  78040B     MOV W11, W8
00139C  540F8B     SUB W8, W11, [W15]
00139E  3AFFED     BRA NZ, 0x137A
0013A0  97B2FF     MOV [W15-18], W5
0013A2  550F85     SUB W10, W5, [W15]
0013A4  3AFFE9     BRA NZ, 0x1378
69:                            e2=err<<1;
00137A  448209     ADD W9, W9, W4
70:                            if (e2>-deltay){
001374  EA0685     NEG W5, W13
001376  370001     BRA 0x137A
00137C  520F8D     SUB W4, W13, [W15]
00137E  340005     BRA LE, 0x138A
71:                               err -= deltay;
001380  97BA0F     MOV [W15-16], W4
001382  548484     SUB W9, W4, W9
72:                               x1 += sx;
001384  97B2EF     MOV [W15-20], W5
001386  440405     ADD W8, W5, W8
001388  370005     BRA 0x1394
73:                            }else if (e2<deltax){
00138A  570F84     SUB W14, W4, [W15]
00138C  340003     BRA LE, 0x1394
74:                                err +=deltax;
00138E  44848E     ADD W9, W14, W9
75:                                y1 += sy;
001390  97B25F     MOV [W15-22], W4
001392  450504     ADD W10, W4, W10
76:                            }
77:                            plot(x1,y1,color);
001394  78010C     MOV W12, W2
001396  78008A     MOV W10, W1
001398  780008     MOV W8, W0
00139A  07FF74     RCALL plot
78:                        }
79:                    }
80:                } // line()
0013A6  78074F     MOV [--W15], W14
0013A8  BE064F     MOV.D [--W15], W12
0013AA  BE054F     MOV.D [--W15], W10
0013AC  BE044F     MOV.D [--W15], W8
0013AE  B100AF     SUB #0xA, W15
0013B0  060000     RETURN
81:                
82:                void rectangle(int x1, int y1, int x2, int y2, int color){
0013B2  BE9F88     MOV.D W8, [W15++]
0013B4  BE9F8A     MOV.D W10, [W15++]
0013B6  781F8C     MOV W12, [W15++]
0013B8  780480     MOV W0, W9
0013BA  780401     MOV W1, W8
0013BC  780502     MOV W2, W10
0013BE  780603     MOV W3, W12
0013C0  780584     MOV W4, W11
83:                    line(x1,y1,x1,y2,color);
0013C2  780109     MOV W9, W2
0013C4  780088     MOV W8, W1
0013C6  780009     MOV W9, W0
0013C8  07FF89     RCALL line
84:                    line(x2,y1,x2,y2,color);
0013CA  78020B     MOV W11, W4
0013CC  78018C     MOV W12, W3
0013CE  78010A     MOV W10, W2
0013D0  780088     MOV W8, W1
0013D2  78000A     MOV W10, W0
0013D4  07FF83     RCALL line
85:                    line(x1,y1,x2,y1,color);
0013D6  78020B     MOV W11, W4
0013D8  780188     MOV W8, W3
0013DA  78010A     MOV W10, W2
0013DC  780088     MOV W8, W1
0013DE  780009     MOV W9, W0
0013E0  07FF7D     RCALL line
86:                    line(x1,y2,x2,y2,color);
0013E2  78020B     MOV W11, W4
0013E4  78018C     MOV W12, W3
0013E6  78010A     MOV W10, W2
0013E8  78008C     MOV W12, W1
0013EA  780009     MOV W9, W0
0013EC  07FF77     RCALL line
87:                }//rectangle()
0013EE  78064F     MOV [--W15], W12
0013F0  BE054F     MOV.D [--W15], W10
0013F2  BE044F     MOV.D [--W15], W8
0013F4  060000     RETURN
88:                
89:                /*  algorthme mid-point
90:                 * REF: http://www.hhhprogram.com/2013/05/draw-elipse-midpoint-elipse-algorithm.html
91:                 */
92:                void ellipse (int xc, int yc, long rx, long ry, int color){
0013F6  B0036F     ADD #0x36, W15
0013F8  BE9F88     MOV.D W8, [W15++]
0013FA  BE9F8A     MOV.D W10, [W15++]
0013FC  BE9F8C     MOV.D W12, [W15++]
0013FE  781F8E     MOV W14, [W15++]
001400  9FAF90     MOV W0, [W15-46]
001402  9FAFE1     MOV W1, [W15-36]
001404  BE0504     MOV.D W4, W10
001406  780706     MOV W6, W14
001482  9FA7F2     MOV W2, [W15-50]
001484  9FAF83     MOV W3, [W15-48]
001490  97AA9F     MOV [W15-46], W5
001492  E90285     DEC W5, W5
001494  9FA7C5     MOV W5, [W15-56]
001496  97AB1F     MOV [W15-46], W6
001498  E80306     INC W6, W6
00149A  9FA7B6     MOV W6, [W15-58]
00149C  9F9FFA     MOV W10, [W15-66]
00149E  9FA78B     MOV W11, [W15-64]
0014A8  97B47F     MOV [W15-18], W8
0014AA  97A0CF     MOV [W15-56], W1
0014AC  408088     ADD W1, W8, W1
0014AE  9FB791     MOV W1, [W15-30]
0014BC  97A1BF     MOV [W15-58], W3
0014BE  518408     SUB W3, W8, W8
0014E8  97A07F     MOV [W15-50], W0
0014EA  97A88F     MOV [W15-48], W1
0014EC  40030C     ADD W0, W12, W6
0014EE  48838D     ADDC W1, W13, W7
00151E  97A47F     MOV [W15-50], W8
001520  97AC8F     MOV [W15-48], W9
001522  44030C     ADD W8, W12, W6
001524  4C838D     ADDC W9, W13, W7
001542  97B37F     MOV [W15-18], W6
001544  97BB8F     MOV [W15-16], W7
001546  530061     SUB W6, #0x1, W0
001548  5B80E0     SUBB W7, #0x0, W1
0015F2  97AA4F     MOV [W15-40], W4
0015F4  97AADF     MOV [W15-38], W5
0015F6  120260     SUBR W4, #0x0, W4
0015F8  1A82E0     SUBBR W5, #0x0, W5
0015FA  9FB794     MOV W4, [W15-30]
0015FC  9FB7A5     MOV W5, [W15-28]
0015FE  97AADF     MOV [W15-38], W5
001600  97B47F     MOV [W15-18], W8
001602  B9AB08     MUL.SS W5, W8, W6
001604  97BC8F     MOV [W15-16], W9
001606  97A84F     MOV [W15-40], W0
001608  B9CA00     MUL.SS W9, W0, W4
00160A  420206     ADD W4, W6, W4
00160C  97A9CF     MOV [W15-40], W3
00160E  97B15F     MOV [W15-22], W2
001610  B81902     MUL.UU W3, W2, W2
001612  9FB7B2     MOV W2, [W15-26]
001614  9FB7C3     MOV W3, [W15-24]
001616  420183     ADD W4, W3, W3
001618  9FB7C3     MOV W3, [W15-24]
00161A  97B23F     MOV [W15-26], W4
00161C  97B2CF     MOV [W15-24], W5
00161E  9FB7D4     MOV W4, [W15-22]
001620  9FB7E5     MOV W5, [W15-20]
00162A  97ABEF     MOV [W15-36], W7
00162C  53858C     SUB W7, W12, W11
00163A  97A8EF     MOV [W15-36], W1
00163C  40848C     ADD W1, W12, W9
001662  560261     SUB W12, #0x1, W4
001664  5E82E0     SUBB W13, #0x0, W5
001680  560261     SUB W12, #0x1, W4
001682  5E82E0     SUBB W13, #0x0, W5
93:                          long  x=0,y=ry;
94:                          long  p=(ry*ry)-(rx*rx*ry)+((rx*rx)/4);
001408  B99A02     MUL.SS W3, W2, W4
00140A  420204     ADD W4, W4, W4
00140C  B81002     MUL.UU W2, W2, W0
00140E  9FAFA0     MOV W0, [W15-44]
001410  9FAFB1     MOV W1, [W15-42]
001412  420081     ADD W4, W1, W1
001414  9FAFB1     MOV W1, [W15-42]
001416  97A92F     MOV [W15-44], W2
001418  97A9BF     MOV [W15-42], W3
00141A  550202     SUB W10, W2, W4
00141C  5D8283     SUBB W11, W3, W5
00141E  B9AB0A     MUL.SS W5, W10, W6
001420  B9D804     MUL.SS W11, W4, W0
001422  400306     ADD W0, W6, W6
001424  B8220A     MUL.UU W4, W10, W4
001426  430285     ADD W6, W5, W5
001428  BE0302     MOV.D W2, W6
00142A  510FE0     SUB W2, #0x0, [W15]
00142C  598FE0     SUBB W3, #0x0, [W15]
00142E  3D0002     BRA GE, 0x1434
001430  410363     ADD W2, #0x3, W6
001432  4983E0     ADDC W3, #0x0, W7
001434  DD39CE     SL W7, #14, W3
001436  DE3342     LSR W6, #2, W6
001438  718306     IOR W3, W6, W6
00143A  DEBBC2     ASR W7, #2, W7
00143C  430404     ADD W6, W4, W8
00143E  4B8485     ADDC W7, W5, W9
001440  9FB7B8     MOV W8, [W15-26]
001442  9FB7C9     MOV W9, [W15-24]
95:                          while((2*x*ry*ry)<(2*y*rx*rx)){
001444  B9DA0A     MUL.SS W11, W10, W4
001446  420204     ADD W4, W4, W4
001448  B8500A     MUL.UU W10, W10, W0
00144A  9FA7D0     MOV W0, [W15-54]
00144C  9FA7E1     MOV W1, [W15-52]
00144E  420081     ADD W4, W1, W1
001450  9FA7E1     MOV W1, [W15-52]
001452  97A15F     MOV [W15-54], W2
001454  97A1EF     MOV [W15-52], W3
001456  410102     ADD W2, W2, W2
001458  498183     ADDC W3, W3, W3
00145A  9FA792     MOV W2, [W15-62]
00145C  9FA7A3     MOV W3, [W15-60]
00145E  97AA2F     MOV [W15-44], W4
001460  97AABF     MOV [W15-42], W5
001462  420204     ADD W4, W4, W4
001464  4A8285     ADDC W5, W5, W5
001466  9FB7D4     MOV W4, [W15-22]
001468  9FB7E5     MOV W5, [W15-20]
001486  200014     MOV #0x1, W4
001488  200005     MOV #0x0, W5
00148A  9FB7F4     MOV W4, [W15-18]
00148C  9FBF85     MOV W5, [W15-16]
00148E  B86660     MUL.UU W12, #0, W12
0014A0  370050     BRA 0x1542
00154A  97B3DF     MOV [W15-22], W7
00154C  B9DA07     MUL.SS W11, W7, W4
00154E  97B46F     MOV [W15-20], W8
001550  B9C30A     MUL.SS W8, W10, W6
001552  430304     ADD W6, W4, W6
001554  97B4DF     MOV [W15-22], W9
001556  B85209     MUL.UU W10, W9, W4
001558  430285     ADD W6, W5, W5
00155A  520F8C     SUB W4, W12, [W15]
00155C  5A8F8D     SUBB W5, W13, [W15]
00155E  3CFFA1     BRA GT, 0x14A2
001560  BE010A     MOV.D W10, W2
001562  9FB79A     MOV W10, [W15-30]
001564  9FB7AB     MOV W11, [W15-28]
001566  9FAFF0     MOV W0, [W15-34]
001568  9FB781     MOV W1, [W15-32]
00156A  979D7F     MOV [W15-66], W10
00156C  97A58F     MOV [W15-64], W11
00156E  BE0600     MOV.D W0, W12
96:                               plot(xc+x,yc-y,color);
0014A2  97A86F     MOV [W15-36], W0
0014A4  50000A     SUB W0, W10, W0
0014A6  9FAFF0     MOV W0, [W15-34]
0014B0  78010E     MOV W14, W2
0014B2  780080     MOV W0, W1
0014B4  97B01F     MOV [W15-30], W0
0014B6  07FEE6     RCALL plot
97:                               plot(xc-x,yc+y,color);
0014B8  97A96F     MOV [W15-36], W2
0014BA  450482     ADD W10, W2, W9
0014C0  78010E     MOV W14, W2
0014C2  BE0008     MOV.D W8, W0
0014C4  07FEDF     RCALL plot
98:                               plot(xc+x,yc+y,color);
0014C6  78010E     MOV W14, W2
0014C8  780089     MOV W9, W1
0014CA  97B01F     MOV [W15-30], W0
0014CC  07FEDB     RCALL plot
99:                               plot(xc-x,yc-y,color);
0014CE  78010E     MOV W14, W2
0014D0  97A8FF     MOV [W15-34], W1
0014D2  780008     MOV W8, W0
0014D4  07FED7     RCALL plot
100:                              if(p<0){
0014D6  97B23F     MOV [W15-26], W4
0014D8  97B2CF     MOV [W15-24], W5
0014DA  520FE0     SUB W4, #0x0, [W15]
0014DC  5A8FE0     SUBB W5, #0x0, [W15]
0014DE  3D000D     BRA GE, 0x14FA
101:                                  x=x+1;
102:                                  p=p+(2*ry*ry*x)+(ry*ry);
0014E0  97A45F     MOV [W15-54], W8
0014E2  97A4EF     MOV [W15-52], W9
0014E4  440204     ADD W8, W4, W4
0014E6  4C8285     ADDC W9, W5, W5
0014F0  420106     ADD W4, W6, W2
0014F2  4A8187     ADDC W5, W7, W3
0014F4  9FB7B2     MOV W2, [W15-26]
0014F6  9FB7C3     MOV W3, [W15-24]
0014F8  37001A     BRA 0x152E
103:                              }else {
104:                                  x=x+1;
105:                                  y=y-1;
0014FA  550561     SUB W10, #0x1, W10
0014FC  5D85E0     SUBB W11, #0x0, W11
106:                                  p=p+(2*ry*ry*x+ry*ry)-(2*rx*rx*y);
00146A  2FFFE4     MOV #0xFFFE, W4
00146C  97AB3F     MOV [W15-42], W6
00146E  B9B204     MUL.SS W6, W4, W4
001470  97ABAF     MOV [W15-44], W7
001472  520207     SUB W4, W7, W4
001474  2FFFE5     MOV #0xFFFE, W5
001476  97ACAF     MOV [W15-44], W9
001478  B84C05     MUL.UU W9, W5, W8
00147A  9FAFC8     MOV W8, [W15-40]
00147C  9FAFD9     MOV W9, [W15-38]
00147E  420489     ADD W4, W9, W9
001480  9FAFD9     MOV W9, [W15-38]
0014FE  97B23F     MOV [W15-26], W4
001500  97B2CF     MOV [W15-24], W5
001502  97A45F     MOV [W15-54], W8
001504  97A4EF     MOV [W15-52], W9
001506  440304     ADD W8, W4, W6
001508  4C8385     ADDC W9, W5, W7
00150A  97ACCF     MOV [W15-40], W9
00150C  B9DA09     MUL.SS W11, W9, W4
00150E  97A95F     MOV [W15-38], W2
001510  B9900A     MUL.SS W2, W10, W0
001512  400004     ADD W0, W4, W0
001514  97A9CF     MOV [W15-40], W3
001516  B85203     MUL.UU W10, W3, W4
001518  400285     ADD W0, W5, W5
00151A  420206     ADD W4, W6, W4
00151C  4A8287     ADDC W5, W7, W5
001526  420006     ADD W4, W6, W0
001528  4A8087     ADDC W5, W7, W1
00152A  9FB7B0     MOV W0, [W15-26]
00152C  9FB7C1     MOV W1, [W15-24]
00152E  97A17F     MOV [W15-50], W2
001530  97A98F     MOV [W15-48], W3
001532  41060C     ADD W2, W12, W12
001534  49868D     ADDC W3, W13, W13
001536  97B27F     MOV [W15-18], W4
001538  97BA8F     MOV [W15-16], W5
00153A  420261     ADD W4, #0x1, W4
00153C  4A82E0     ADDC W5, #0x0, W5
00153E  9FB7F4     MOV W4, [W15-18]
001540  9FBF85     MOV W5, [W15-16]
107:                              }
108:                         }
109:                         p=((float)x+0.5)*((float)x+0.5)*ry*ry+(y-1)*(y-1)*rx*rx-rx*rx*ry*ry;
001576  BE000A     MOV.D W10, W0
001578  07F71D     RCALL 0x3B4
00157A  BE0400     MOV.D W0, W8
00157C  97B31F     MOV [W15-30], W6
00157E  97B3AF     MOV [W15-28], W7
001580  530361     SUB W6, #0x1, W6
001582  5B83E0     SUBB W7, #0x0, W7
001584  9FB7F6     MOV W6, [W15-18]
001586  9FBF87     MOV W7, [W15-16]
001588  BE000C     MOV.D W12, W0
00158A  07F714     RCALL 0x3B4
00158C  200002     MOV #0x0, W2
00158E  23F003     MOV #0x3F00, W3
001590  07F693     RCALL 0x2B8
001592  BE0100     MOV.D W0, W2
001594  07F765     RCALL 0x460
001596  BE0108     MOV.D W8, W2
001598  07F763     RCALL 0x460
00159A  BE0100     MOV.D W0, W2
00159C  BE0008     MOV.D W8, W0
00159E  07F760     RCALL 0x460
0015A0  BE0400     MOV.D W0, W8
0015A2  97BB8F     MOV [W15-16], W7
0015A4  97B07F     MOV [W15-18], W0
0015A6  B9BA00     MUL.SS W7, W0, W4
0015A8  420204     ADD W4, W4, W4
0015AA  97B0FF     MOV [W15-18], W1
0015AC  9FB7D1     MOV W1, [W15-22]
0015AE  780101     MOV W1, W2
0015B0  B81002     MUL.UU W2, W2, W0
0015B2  420081     ADD W4, W1, W1
0015B4  97A9AF     MOV [W15-44], W3
0015B6  B98B03     MUL.SS W1, W3, W6
0015B8  97A93F     MOV [W15-42], W2
0015BA  B99200     MUL.SS W2, W0, W4
0015BC  420206     ADD W4, W6, W4
0015BE  97AD2F     MOV [W15-44], W10
0015C0  B8000A     MUL.UU W0, W10, W0
0015C2  420081     ADD W4, W1, W1
0015C4  07F6F7     RCALL 0x3B4
0015C6  BE0100     MOV.D W0, W2
0015C8  BE0008     MOV.D W8, W0
0015CA  07F676     RCALL 0x2B8
0015CC  BE0400     MOV.D W0, W8
0015CE  97A9BF     MOV [W15-42], W3
0015D0  97A25F     MOV [W15-54], W4
0015D2  B99B04     MUL.SS W3, W4, W6
0015D4  97A06F     MOV [W15-52], W0
0015D6  97A8AF     MOV [W15-44], W1
0015D8  B98201     MUL.SS W0, W1, W4
0015DA  420206     ADD W4, W6, W4
0015DC  97A15F     MOV [W15-54], W2
0015DE  B85002     MUL.UU W10, W2, W0
0015E0  420081     ADD W4, W1, W1
0015E2  07F6E8     RCALL 0x3B4
0015E4  BE0100     MOV.D W0, W2
0015E6  BE0008     MOV.D W8, W0
0015E8  07F666     RCALL 0x2B6
0015EA  07F6C3     RCALL 0x372
0015EC  BE0500     MOV.D W0, W10
0015EE  97B61F     MOV [W15-30], W12
0015F0  97B6AF     MOV [W15-28], W13
110:                         while(y>=0){
001570  510FE0     SUB W2, #0x0, [W15]
001572  598FE0     SUBB W3, #0x0, [W15]
001574  3500B8     BRA LT, 0x16E6
0016E0  520FE0     SUB W4, #0x0, [W15]
0016E2  5A8FE0     SUBB W5, #0x0, [W15]
0016E4  3DFFA2     BRA GE, 0x162A
111:                              plot(xc+x,yc-y,color);
00162E  97AC7F     MOV [W15-34], W8
001630  97A81F     MOV [W15-46], W0
001632  440500     ADD W8, W0, W10
001634  78010E     MOV W14, W2
001636  BE000A     MOV.D W10, W0
001638  07FE25     RCALL plot
112:                              plot(xc-x,yc+y,color);
00163E  97A91F     MOV [W15-46], W2
001640  510408     SUB W2, W8, W8
001642  78010E     MOV W14, W2
001644  BE0008     MOV.D W8, W0
001646  07FE1E     RCALL plot
113:                              plot(xc+x,yc+y,color);
001648  78010E     MOV W14, W2
00164A  780089     MOV W9, W1
00164C  78000A     MOV W10, W0
00164E  07FE1A     RCALL plot
114:                              plot(xc-x,yc-y,color);
001650  78010E     MOV W14, W2
001652  78008B     MOV W11, W1
001654  780008     MOV W8, W0
001656  07FE16     RCALL plot
115:                              if(p>0){
001658  97B27F     MOV [W15-18], W4
00165A  97BA8F     MOV [W15-16], W5
00165C  520FE0     SUB W4, #0x0, [W15]
00165E  5A8FE0     SUBB W5, #0x0, [W15]
001660  34000F     BRA LE, 0x1680
116:                                  y=y-1;
117:                                  p=p-(2*rx*rx*y)+(rx*rx);
001666  97B47F     MOV [W15-18], W8
001668  97BC8F     MOV [W15-16], W9
00166A  97A82F     MOV [W15-44], W0
00166C  97A8BF     MOV [W15-42], W1
00166E  400308     ADD W0, W8, W6
001670  488389     ADDC W1, W9, W7
001672  97B15F     MOV [W15-22], W2
001674  97B1EF     MOV [W15-20], W3
001676  430102     ADD W6, W2, W2
001678  4B8183     ADDC W7, W3, W3
00167A  9FB7F2     MOV W2, [W15-18]
00167C  9FBF83     MOV W3, [W15-16]
00167E  370020     BRA 0x16C0
118:                              }else{
119:                                  y=y-1;
120:                                  x=x+1;
001684  97AB7F     MOV [W15-34], W6
001686  97B38F     MOV [W15-32], W7
001688  430361     ADD W6, #0x1, W6
00168A  4B83E0     ADDC W7, #0x0, W7
00168C  9FAFF6     MOV W6, [W15-34]
00168E  9FB787     MOV W7, [W15-32]
121:                                  p=p+(2*ry*ry*x)-(2*rx*rx*y)-(rx*rx);
001622  97A29F     MOV [W15-62], W5
001624  9FAFC5     MOV W5, [W15-40]
001626  9FB7FA     MOV W10, [W15-18]
001628  9FBF8B     MOV W11, [W15-16]
001690  97B47F     MOV [W15-18], W8
001692  97BC8F     MOV [W15-16], W9
001694  97A82F     MOV [W15-44], W0
001696  97A8BF     MOV [W15-42], W1
001698  540100     SUB W8, W0, W2
00169A  5C8181     SUBB W9, W1, W3
00169C  97A3AF     MOV [W15-60], W7
00169E  B9B806     MUL.SS W7, W6, W0
0016A0  97B40F     MOV [W15-32], W8
0016A2  97A49F     MOV [W15-62], W9
0016A4  B9C309     MUL.SS W8, W9, W6
0016A6  430000     ADD W6, W0, W0
0016A8  97A8CF     MOV [W15-40], W1
0016AA  97AC7F     MOV [W15-34], W8
0016AC  B80B08     MUL.UU W1, W8, W6
0016AE  400387     ADD W0, W7, W7
0016B0  430302     ADD W6, W2, W6
0016B2  4B8383     ADDC W7, W3, W7
0016B4  97B03F     MOV [W15-26], W0
0016B6  97B0CF     MOV [W15-24], W1
0016B8  430000     ADD W6, W0, W0
0016BA  4B8081     ADDC W7, W1, W1
0016BC  9FB7F0     MOV W0, [W15-18]
0016BE  9FBF81     MOV W1, [W15-16]
0016C0  560661     SUB W12, #0x1, W12
0016C2  5E86E0     SUBB W13, #0x0, W13
0016C4  97B15F     MOV [W15-22], W2
0016C6  97B1EF     MOV [W15-20], W3
0016C8  97B31F     MOV [W15-30], W6
0016CA  97B3AF     MOV [W15-28], W7
0016CC  430102     ADD W6, W2, W2
0016CE  4B8183     ADDC W7, W3, W3
0016D0  9FB7D2     MOV W2, [W15-22]
0016D2  9FB7E3     MOV W3, [W15-20]
0016D4  97B43F     MOV [W15-26], W8
0016D6  97B4CF     MOV [W15-24], W9
0016D8  430408     ADD W6, W8, W8
0016DA  4B8489     ADDC W7, W9, W9
0016DC  9FB7B8     MOV W8, [W15-26]
0016DE  9FB7C9     MOV W9, [W15-24]
122:                              }
123:                         }
124:               }//ellipse()
0016E6  78074F     MOV [--W15], W14
0016E8  BE064F     MOV.D [--W15], W12
0016EA  BE054F     MOV.D [--W15], W10
0016EC  BE044F     MOV.D [--W15], W8
0016EE  B1036F     SUB #0x36, W15
0016F0  060000     RETURN
125:               
126:               /*
127:                * points[]={x1,y1,x2,y2,x3,y3,...}
128:                * vertices est le nombre de points
129:                */
130:               void polygon(int points[], int vertices, int color){
0016F2  BE9F88     MOV.D W8, [W15++]
0016F4  BE9F8A     MOV.D W10, [W15++]
0016F6  781F8C     MOV W12, [W15++]
0016F8  780600     MOV W0, W12
0016FA  780582     MOV W2, W11
131:                   int i;
132:                   for(i=0;i<(2*vertices-2);i+=2){
0016FC  E90501     DEC W1, W10
0016FE  45050A     ADD W10, W10, W10
001700  EB0480     CLR W9
001702  550F89     SUB W10, W9, [W15]
001704  34000B     BRA LE, 0x171C
001706  78040C     MOV W12, W8
001714  E88489     INC2 W9, W9
001716  440464     ADD W8, #0x4, W8
001718  550F89     SUB W10, W9, [W15]
00171A  3CFFF6     BRA GT, 0x1708
133:                       line(points[i],points[i+1],points[i+2],points[i+3],color);
001708  900128     MOV [W8+4], W2
00170A  900098     MOV [W8+2], W1
00170C  78020B     MOV W11, W4
00170E  9001B8     MOV [W8+6], W3
001710  780018     MOV [W8], W0
001712  07FDE4     RCALL line
134:                   }
135:                   line(points[0],points[1],points[i],points[i+1],color);
00171C  E80289     INC W9, W5
00171E  428285     ADD W5, W5, W5
001720  448489     ADD W9, W9, W9
001722  90009C     MOV [W12+2], W1
001724  78020B     MOV W11, W4
001726  7A81EC     MOV [W12+W5], W3
001728  7C816C     MOV [W12+W9], W2
00172A  78001C     MOV [W12], W0
00172C  07FDD7     RCALL line
136:               }//polygon()
00172E  78064F     MOV [--W15], W12
001730  BE054F     MOV.D [--W15], W10
001732  BE044F     MOV.D [--W15], W8
001734  060000     RETURN
137:               
138:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NTSC_FRAMES_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE+40)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAMES_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE+45)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8  // flag screen in retrace phase
60:                #define F_BLANK 16   // flag keep screen blank
61:                
62:                unsigned frames_per_second;
63:                static unsigned int frame_line_cntr=0; // count line in video frame
64:                volatile static unsigned long frame_cntr=0; // number of frame since reset
65:                volatile static unsigned int flags;
66:                
67:                
68:                char video_buffer[VPIXELS][BYTES_PER_LINE];
69:                int vsync, hsync, video_mode;
70:                
71:                void ntsc_init(){
72:                    VIDPR = NTSC_LINE_PERIOD;  // video timer PRx SFR
002142  203F85     MOV #0x3F8, W5
002144  880865     MOV W5, PR2
73:                    VSYNCR= NTSC_HPULSE;       // video OCxR  SFR
002146  2004B4     MOV #0x4B, W4
002148  880C14     MOV W4, OC1R
74:                    VSYNCRS=NTSC_LINE_PERIOD;  // video OCxRS SFR
00214A  880C05     MOV W5, OC1RS
75:                    VDLYR=NTSC_VIDEO_DELAY;     // video delay OCxR SFR
00214C  200BE5     MOV #0xBE, W5
00214E  880CA5     MOV W5, OC4R
76:                    VDLYRS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;  // video delay OCxRS SFR
002150  203E05     MOV #0x3E0, W5
002152  880C95     MOV W5, OC4RS
77:                    hsync=NTSC_HPULSE;
002154  88F674     MOV W4, hsync
78:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
002156  203AC4     MOV #0x3AC, W4
002158  88F664     MOV W4, vsync
79:                    video_mode=NTSC_MODE;
00215A  EF3EC8     CLR video_mode
80:                    frames_per_second=NTSC_FRAMES_PER_SECOND;
00215C  2003C4     MOV #0x3C, W4
00215E  88F654     MOV W4, frames_per_second
81:                }//f()
002160  060000     RETURN
82:                
83:                void pal_init(){
84:                    VIDPR = PAL_LINE_PERIOD;
002162  204005     MOV #0x400, W5
002164  880865     MOV W5, PR2
85:                    VSYNCR= PAL_HPULSE;
002166  2004B4     MOV #0x4B, W4
002168  880C14     MOV W4, OC1R
86:                    VSYNCRS=PAL_LINE_PERIOD;
00216A  880C05     MOV W5, OC1RS
87:                    VDLYR=PAL_VIDEO_DELAY;
00216C  200C35     MOV #0xC3, W5
00216E  880CA5     MOV W5, OC4R
88:                    VDLYRS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
002170  203E65     MOV #0x3E6, W5
002172  880C95     MOV W5, OC4RS
89:                    hsync=PAL_HPULSE;
002174  88F674     MOV W4, hsync
90:                    vsync=PAL_LINE_PERIOD-PAL_HPULSE;
002176  203B44     MOV #0x3B4, W4
002178  88F664     MOV W4, vsync
91:                    video_mode=PAL_MODE;
00217A  200014     MOV #0x1, W4
00217C  88F644     MOV W4, video_mode
92:                    frames_per_second=PAL_FRAMES_PER_SECOND;
00217E  200324     MOV #0x32, W4
002180  88F654     MOV W4, frames_per_second
93:                }//f()
002182  060000     RETURN
94:                
95:                void  video_init(){ // initialisation sorties NTSC
96:                    VIDTMR.TON=0; // désactivation TIMER2
002184  A9E111     BCLR 0x111, #7
97:                    if (P_VIDEO_MODE){
002186  801655     MOV PORTB, W5
002188  210004     MOV #0x1000, W4
00218A  628204     AND W5, W4, W4
00218C  320002     BRA Z, 0x2192
98:                        ntsc_init();
00218E  07FFD9     RCALL ntsc_init
002190  370001     BRA 0x2194
99:                    }else{
100:                       pal_init();
002192  07FFE7     RCALL pal_init
101:                   }
102:                   //  video sync OC mode
103:                   VSYNCCON.OCM=5; // mode 5, timer 2
002194  800C24     MOV OC1CON, W4
002196  A00004     BSET W4, #0
002198  A11004     BCLR W4, #1
00219A  A02004     BSET W4, #2
00219C  880C24     MOV W4, OC1CON
104:                   //video delay change notification interrupt enable on that pin.
105:                   PIXIE=1;
00219E  A8A062     BSET CNEN2, #5
106:                   // video sync interrupt enabling
107:                   VSYNCIF=0;
0021A0  A9E084     BCLR IFS0, #7
108:                   VSYNCIE=1;
0021A2  A8E094     BSET IEC0, #7
109:                   // SPIx configuration (pixels output)
110:                   PIXCON1.DISSCK=1;
0021A4  A88243     BSET 0x243, #4
111:                   PIXCON1.MSTEN=1;
0021A6  A8A242     BSET SPI1CON1, #5
112:                   PIXCON1.SPRE=5;
0021A8  801214     MOV SPI1CON1, W4
0021AA  A02004     BSET W4, #2
0021AC  A13004     BCLR W4, #3
0021AE  A04004     BSET W4, #4
0021B0  881214     MOV W4, SPI1CON1
113:                   PIXCON1.PPRE=3;
0021B2  200030     MOV #0x3, W0
0021B4  B72242     IOR SPI1CON1
114:                   PIXCON2.SPIBEN=1;  // enhanced buffer mode
0021B6  A80244     BSET SPI1CON2, #0
115:                   PIXSTAT.SPIEN=1;
0021B8  A8E241     BSET 0x241, #7
116:                   VIDTMR.TON=1;
0021BA  A8E111     BSET 0x111, #7
117:               }//horz_sync_init()
0021BC  060000     RETURN
118:               
119:               void  wait_n_frame(unsigned n){
120:               unsigned long f0;
121:                   f0=frame_cntr+n;
0021BE  80F6A4     MOV frame_cntr, W4
0021C0  80F6B5     MOV 0x1ED6, W5
0021C2  420000     ADD W4, W0, W0
0021C4  4A80E0     ADDC W5, #0x0, W1
122:                   while (frame_cntr<f0);
0021C6  80F6A4     MOV frame_cntr, W4
0021C8  80F6B5     MOV 0x1ED6, W5
0021CA  500F84     SUB W0, W4, [W15]
0021CC  588F85     SUBB W1, W5, [W15]
0021CE  3EFFFB     BRA GTU, 0x21C6
123:               }//f()
0021D0  060000     RETURN
124:               
125:               void  blank_out(unsigned state){
126:                   if (!state){
0021D2  500FE0     SUB W0, #0x0, [W15]
0021D4  3A0002     BRA NZ, 0x21DA
127:                       flags &= ~F_BLANK;
0021D6  A99ED2     BCLR flags, #4
0021D8  370001     BRA 0x21DC
128:                   }else{
129:                       flags |=F_BLANK;
0021DA  A89ED2     BSET flags, #4
130:                   }
131:               }//f()
0021DC  060000     RETURN
132:               
133:               
134:               // video sync signal generation
135:               void __attribute__((interrupt,no_auto_psv,shadow)) _VSYNC_ISR(void){
0021DE  FEA000     PUSH.S
0021E0  BE9F84     MOV.D W4, [W15++]
136:                   frame_line_cntr++;
0021E2  80F684     MOV frame_line_cntr, W4
0021E4  E80204     INC W4, W4
0021E6  88F684     MOV W4, frame_line_cntr
137:                   switch (frame_line_cntr){
0021E8  200375     MOV #0x37, W5
0021EA  520F85     SUB W4, W5, [W15]
0021EC  320036     BRA Z, 0x225A
0021EE  3E0007     BRA GTU, 0x21FE
0021F0  520FE4     SUB W4, #0x4, [W15]
0021F2  32001C     BRA Z, 0x222C
0021F4  520FFE     SUB W4, #0x1E, [W15]
0021F6  320022     BRA Z, 0x223C
0021F8  520FE1     SUB W4, #0x1, [W15]
0021FA  3A0053     BRA NZ, 0x22A2
0021FC  37000F     BRA 0x221C
0021FE  201075     MOV #0x107, W5
002200  520F85     SUB W4, W5, [W15]
002202  32003A     BRA Z, 0x2278
002204  3E0004     BRA GTU, 0x220E
002206  5282F1     SUB W5, #0x11, W5
002208  520F85     SUB W4, W5, [W15]
00220A  3A004B     BRA NZ, 0x22A2
00220C  370020     BRA 0x224E
00220E  2010F5     MOV #0x10F, W5
002210  520F85     SUB W4, W5, [W15]
002212  32002C     BRA Z, 0x226C
002214  201395     MOV #0x139, W5
002216  520F85     SUB W4, W5, [W15]
002218  3A0044     BRA NZ, 0x22A2
00221A  370039     BRA 0x228E
138:                       case 1:
139:                           VSYNCR=vsync;
00221C  F81ECC     PUSH vsync
00221E  F90182     POP OC1R
140:                           VDLYCON.OCM=0;
002220  800CB4     MOV OC4CON, W4
002222  A10004     BCLR W4, #0
002224  A11004     BCLR W4, #1
002226  A12004     BCLR W4, #2
002228  880CB4     MOV W4, OC4CON
141:                           break;
00222A  37003B     BRA 0x22A2
142:                       case 4:
143:                           VDLYCON.OCM=5;
00222C  800CB4     MOV OC4CON, W4
00222E  A00004     BSET W4, #0
002230  A11004     BCLR W4, #1
002232  A02004     BSET W4, #2
002234  880CB4     MOV W4, OC4CON
144:                           VSYNCR=hsync;
002236  F81ECE     PUSH hsync
002238  F90182     POP OC1R
145:                           break;
00223A  370033     BRA 0x22A2
146:                       case NTSC_FIRST_VISIBLE:
147:                           if (video_mode==NTSC_MODE && !(flags&F_BLANK)){
00223C  80F644     MOV video_mode, W4
00223E  520FE0     SUB W4, #0x0, [W15]
002240  3A0030     BRA NZ, 0x22A2
002242  AB9ED2     BTST flags, #4
002244  3A002E     BRA NZ, 0x22A2
148:                               VDLYIF=0;
002246  A96086     BCLR IFS1, #3
149:                               VDLYIE=1;
002248  A86096     BSET IEC1, #3
150:                               flags &= ~F_RETRACE;
00224A  A97ED2     BCLR flags, #3
00224C  37002A     BRA 0x22A2
151:                           }
152:                           break;
153:                       case NTSC_LAST_VISIBLE:
154:                           if (video_mode==NTSC_MODE){
00224E  80F644     MOV video_mode, W4
002250  520FE0     SUB W4, #0x0, [W15]
002252  3A0027     BRA NZ, 0x22A2
155:                               VDLYIE=0;
002254  A96096     BCLR IEC1, #3
156:                               flags |= F_RETRACE;
002256  A87ED2     BSET flags, #3
002258  370024     BRA 0x22A2
157:                           }
158:                           break;
159:                       case PAL_FIRST_VISIBLE:
160:                           if (video_mode==PAL_MODE && !(flags&F_BLANK)){
00225A  80F644     MOV video_mode, W4
00225C  520FE1     SUB W4, #0x1, [W15]
00225E  3A0021     BRA NZ, 0x22A2
002260  AB9ED2     BTST flags, #4
002262  3A001F     BRA NZ, 0x22A2
161:                               VDLYIF=0;
002264  A96086     BCLR IFS1, #3
162:                               VDLYIE=1;
002266  A86096     BSET IEC1, #3
163:                               flags &= ~F_RETRACE;
002268  A97ED2     BCLR flags, #3
00226A  37001B     BRA 0x22A2
164:                           }
165:                           break;
166:                       case PAL_LAST_VISIBLE:
167:                           if (video_mode==PAL_MODE){
00226C  80F644     MOV video_mode, W4
00226E  520FE1     SUB W4, #0x1, [W15]
002270  3A0018     BRA NZ, 0x22A2
168:                               VDLYIE=0;
002272  A96096     BCLR IEC1, #3
169:                               flags |= F_RETRACE;
002274  A87ED2     BSET flags, #3
002276  370015     BRA 0x22A2
170:                           }
171:                           break;
172:                       case NTSC_LINES_PER_FRAME+1:
173:                           if (video_mode==NTSC_MODE){
002278  80F644     MOV video_mode, W4
00227A  520FE0     SUB W4, #0x0, [W15]
00227C  3A0012     BRA NZ, 0x22A2
174:                               frame_line_cntr=0;
00227E  EF3ED0     CLR frame_line_cntr
175:                               frame_cntr++;
002280  80F6A4     MOV frame_cntr, W4
002282  80F6B5     MOV 0x1ED6, W5
002284  420261     ADD W4, #0x1, W4
002286  4A82E0     ADDC W5, #0x0, W5
002288  88F6A4     MOV W4, frame_cntr
00228A  88F6B5     MOV W5, 0x1ED6
00228C  37000A     BRA 0x22A2
176:                           }
177:                           break;
178:                       case PAL_LINES_PER_FRAME+1:
179:                           if (video_mode==PAL_MODE){
00228E  80F644     MOV video_mode, W4
002290  520FE1     SUB W4, #0x1, [W15]
002292  3A0007     BRA NZ, 0x22A2
180:                               frame_line_cntr=0;
002294  EF3ED0     CLR frame_line_cntr
181:                               frame_cntr++;
002296  80F6A4     MOV frame_cntr, W4
002298  80F6B5     MOV 0x1ED6, W5
00229A  420261     ADD W4, #0x1, W4
00229C  4A82E0     ADDC W5, #0x0, W5
00229E  88F6A4     MOV W4, frame_cntr
0022A0  88F6B5     MOV W5, 0x1ED6
182:                           }
183:                           break;
184:                   }//switch
185:                   VSYNCIF=0;
0022A2  A9E084     BCLR IFS0, #7
186:               }// _VSYNC_ISR()
0022A4  BE024F     MOV.D [--W15], W4
0022A6  FE8000     POP.S
0022A8  064000     RETFIE
187:               
188:               void __attribute__((interrupt,no_auto_psv,shadow)) _VIDEO_OUT_ISR(void){
0022AA  FEA000     PUSH.S
0022AC  BE9F84     MOV.D W4, [W15++]
0022AE  BE9F86     MOV.D W6, [W15++]
0022C4  B9337B     MUL.SU W6, #27, W6
0022C6  207FF4     MOV #0x7FF, W4
0022C8  430304     ADD W6, W4, W6
189:                   int y,x;
190:                   if (PIXDLY_INP){
0022B0  AB22CB     BTST 0x2CB, #1
0022B2  320016     BRA Z, 0x22E0
191:                       if (video_mode==NTSC_MODE){
0022B4  80F644     MOV video_mode, W4
0022B6  520FE0     SUB W4, #0x0, [W15]
0022B8  3A0003     BRA NZ, 0x22C0
192:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE);
0022BA  80F686     MOV frame_line_cntr, W6
0022BC  53037E     SUB W6, #0x1E, W6
0022BE  370002     BRA 0x22C4
193:                       }else{
194:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE);
0022C0  80F686     MOV frame_line_cntr, W6
0022C2  B10376     SUB #0x37, W6
195:                       }
196:                       for (x=0;x<BYTES_PER_LINE;x++){
0022CA  EB0280     CLR W5
0022D4  E80285     INC W5, W5
0022D6  528FFB     SUB W5, #0x1B, [W15]
0022D8  3AFFF9     BRA NZ, 0x22CC
197:                           while (PIXSTAT.SPITBF);
0022CC  AB2240     BTST SPI1STAT, #1
0022CE  3AFFFE     BRA NZ, 0x22CC
198:                           PIXBUF=video_buffer[y][x];
0022D0  FB0256     SE [++W6], W4
0022D2  881244     MOV W4, SPI1BUF
199:                       }//for
200:                       while (PIXSTAT.SPITBF);
0022DA  AB2240     BTST SPI1STAT, #1
0022DC  3AFFFE     BRA NZ, 0x22DA
201:                       PIXBUF=0;
0022DE  EF2248     CLR SPI1BUF
202:                   }
203:                   VDLYIF=0;
0022E0  A96086     BCLR IFS1, #3
204:               }// _VIDEO_OUT_ISR
0022E2  BE034F     MOV.D [--W15], W6
0022E4  BE024F     MOV.D [--W15], W4
0022E6  FE8000     POP.S
0022E8  064000     RETFIE
205:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  216x216 pixels
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include "PICvision.h"
34:                #include "PICVision_banner.h"
35:                
36:                void splash_screen(){
002456  BE9F88     MOV.D W8, [W15++]
002458  BE9F8A     MOV.D W10, [W15++]
00245A  BE9F8C     MOV.D W12, [W15++]
002460  558477     SUB W11, #0x17, W8
002462  207FEC     MOV #0x7FE, W12
002466  78068A     MOV W10, W13
002468  2004F4     MOV #0x4F, W4
00246A  52020A     SUB W4, W10, W4
00247C  208003     MOV #0x800, W3
00247E  370007     BRA 0x248E
00248E  B93A78     MUL.SU W7, #24, W4
002490  E90204     DEC W4, W4
002492  420208     ADD W4, W8, W4
002494  568007     SUB W13, W7, W0
002496  B9007B     MUL.SU W0, #27, W0
002498  E80280     INC W0, W5
00249A  428283     ADD W5, W3, W5
00249C  37FFF1     BRA 0x2480
0024A4  E90007     DEC W7, W0
0024A6  B9007B     MUL.SU W0, #27, W0
0024A8  208014     MOV #0x801, W4
0024AA  400204     ADD W0, W4, W4
0024AC  B93B7B     MUL.SU W7, #27, W6
0024AE  460286     ADD W12, W6, W5
37:                    int i,k,first,last,left;
38:                    left=(HPIXELS-PIX_WIDTH)/16+1;
39:                    last=0;
00245C  EB0500     CLR W10
40:                    while (last<(VPIXELS-PIX_HEIGHT)/2+PIX_HEIGHT){
0024BC  200944     MOV #0x94, W4
0024BE  550F84     SUB W10, W4, [W15]
0024C0  3AFFD2     BRA NZ, 0x2466
41:                        first=max(0,PIX_HEIGHT-last-1);
00246C  3B0001     BRA NN, 0x2470
00246E  EB0200     CLR W4
42:                        for (i=0;i<PIX_HEIGHT-first;i++){
00245E  285E1B     MOV #0x85E1, W11
002470  200502     MOV #0x50, W2
002472  510104     SUB W2, W4, W2
002474  EB0380     CLR W7
002476  510F87     SUB W2, W7, [W15]
002478  340012     BRA LE, 0x249E
00247A  78030B     MOV W11, W6
002486  E80387     INC W7, W7
002488  430378     ADD W6, #0x18, W6
00248A  538F82     SUB W7, W2, [W15]
00248C  320008     BRA Z, 0x249E
43:                            for (k=0;k<ARRAY_WIDTH;k++){
002482  530F84     SUB W6, W4, [W15]
002484  3AFFFD     BRA NZ, 0x2480
44:                                video_buffer[last-i][left+k]=PICVISION_BANNER[i][k];
002480  786AD4     MOV.B [++W4], [++W5]
45:                            }//for
46:                        }//for
47:                        if (last-i>0){
00249E  550387     SUB W10, W7, W7
0024A0  A94042     BCLR SR, #2
0024A2  340009     BRA LE, 0x24B6
48:                            for (k=0;k<ARRAY_WIDTH;k++){
0024B2  520F85     SUB W4, W5, [W15]
0024B4  3AFFFD     BRA NZ, 0x24B0
49:                                video_buffer[last-i-1][left+k]=0;
002464  EB4480     CLR.B W9
0024B0  786A09     MOV.B W9, [++W4]
50:                            }//for
51:                        }//if
52:                        wait_n_frame(1);
0024B6  200010     MOV #0x1, W0
0024B8  07FE82     RCALL wait_n_frame
53:                        last++;
0024BA  E8050A     INC W10, W10
54:                    }//while
55:                    set_curpos(left,last/8+2);
0024C2  200141     MOV #0x14, W1
0024C4  200020     MOV #0x2, W0
0024C6  07FCF7     RCALL set_curpos
56:                    print("Copyright 2014, Jacques Deschenes");
0024C8  292620     MOV #0x9262, W0
0024CA  07FC78     RCALL print
57:                    wait_n_frame(180);
0024CC  200B40     MOV #0xB4, W0
0024CE  07FE77     RCALL wait_n_frame
58:                }//f()
0024D0  BE064F     MOV.D [--W15], W12
0024D2  BE054F     MOV.D [--W15], W10
0024D4  BE044F     MOV.D [--W15], W8
0024D6  060000     RETURN
59:                
60:                
61:                void PICvision_init(void) {
62:                    HardwareConfig();
0024D8  070007     RCALL HardwareConfig
63:                    timers_init(TICK_FREQ);
0024DA  200640     MOV #0x64, W0
0024DC  07FD45     RCALL timers_init
64:                    video_init();
0024DE  07FE52     RCALL video_init
65:                    sound_init(1000/TICK_FREQ);
0024E0  2000A0     MOV #0xA, W0
0024E2  07FF0F     RCALL sound_init
66:                    splash_screen();
0024E4  07FFB8     RCALL splash_screen
67:                }//f()
0024E6  060000     RETURN
68:                
69:                
