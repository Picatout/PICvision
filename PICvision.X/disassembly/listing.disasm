Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-02-27 22:47:19

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NSTC_FRAME_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE-10)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAME_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE-10)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8 // flag screen in retrace phase
60:                
61:                #define QUEUE_SIZE 32  // put_char queue
62:                
63:                static unsigned int frame_line_cntr=0; // count line in video frame
64:                volatile static unsigned long frame_cntr=0; // number of frame since reset
65:                volatile static unsigned int flags;
66:                
67:                typedef union coord_type{
68:                    unsigned int yx;
69:                    struct{
70:                        unsigned char y;
71:                        unsigned char x;
72:                    };
73:                }coord_t;
74:                
75:                volatile static coord_t cursor_pos;
76:                
77:                volatile static char pchar_queue[QUEUE_SIZE];
78:                
79:                char video_buffer[LINES][COLUMNS];
80:                volatile static unsigned  head=0, tail=0;
81:                int vsync, hsync, video_mode;
82:                
83:                void ntsc_init(){
84:                    PR2 = NTSC_LINE_PERIOD;
0005FE  203F85     MOV #0x3F8, W5
000600  880865     MOV W5, PR2
85:                    OC1R= NTSC_HPULSE;
000602  2004B4     MOV #0x4B, W4
000604  880C14     MOV W4, OC1R
86:                    OC1RS=NTSC_LINE_PERIOD;
000606  880C05     MOV W5, OC1RS
87:                    OC3R=NTSC_VIDEO_DELAY;
000608  2008C5     MOV #0x8C, W5
00060A  880C75     MOV W5, OC3R
88:                    OC3RS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;
00060C  203E05     MOV #0x3E0, W5
00060E  880C65     MOV W5, OC3RS
89:                    hsync=NTSC_HPULSE;
000610  885534     MOV W4, hsync
90:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
000612  203AC4     MOV #0x3AC, W4
000614  885524     MOV W4, vsync
91:                    video_mode=NTSC_MODE;
000616  EF2AA8     CLR video_mode
92:                }//f()
000618  060000     RETURN
93:                
94:                void pal_init(){
95:                    PR2 = PAL_LINE_PERIOD;
00061A  204005     MOV #0x400, W5
00061C  880865     MOV W5, PR2
96:                    OC1R= PAL_HPULSE;
00061E  2004B4     MOV #0x4B, W4
000620  880C14     MOV W4, OC1R
97:                    OC1RS=PAL_LINE_PERIOD;
000622  880C05     MOV W5, OC1RS
98:                    OC3R=PAL_VIDEO_DELAY;
000624  2008C5     MOV #0x8C, W5
000626  880C75     MOV W5, OC3R
99:                    OC3RS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
000628  203E65     MOV #0x3E6, W5
00062A  880C65     MOV W5, OC3RS
100:                   hsync=PAL_HPULSE;
00062C  885534     MOV W4, hsync
101:                   vsync=PAL_LINE_PERIOD-PAL_HPULSE;
00062E  203B44     MOV #0x3B4, W4
000630  885524     MOV W4, vsync
102:                   video_mode=PAL_MODE;
000632  200014     MOV #0x1, W4
000634  885544     MOV W4, video_mode
103:               }//f()
000636  060000     RETURN
104:               
105:               void  video_init(){ // initialisation sorties NTSC
106:                   T2CON=0; // désactivation TIMER2
000638  EF2110     CLR T2CON
107:                   if (P_VIDEO_MODE){
00063A  801655     MOV PORTB, W5
00063C  210004     MOV #0x1000, W4
00063E  628204     AND W5, W4, W4
000640  320002     BRA Z, 0x646
108:                       ntsc_init();
000642  07FFDD     RCALL ntsc_init
000644  370001     BRA 0x648
109:                   }else{
110:                       pal_init();
000646  07FFE9     RCALL pal_init
111:                   }
112:                   // OC1 video sync
113:                   OC1CON=5; // mode 5, timer 2
000648  200054     MOV #0x5, W4
00064A  880C24     MOV W4, OC1CON
114:                   //OC3 video delay timer black level fixer.
115:                   IFS0bits.OC1IF=0;
00064C  A94084     BCLR IFS0, #2
116:                   IPC0bits.OC1IP=7;
00064E  207000     MOV #0x700, W0
000650  B720A4     IOR IPC0
117:                   IPC4bits.CNIP=7;
000652  270000     MOV #0x7000, W0
000654  B720AC     IOR IPC4
118:                   CNEN1bits.CN15IE=1;
000656  A8E061     BSET 0x61, #7
119:                   // timer 2 interrupt enabling
120:                   IFS0bits.T2IF=0;
000658  A9E084     BCLR IFS0, #7
121:                   IPC1bits.T2IP=7; // plus haute priorité
00065A  B720A6     IOR IPC1
122:                   IEC0bits.T2IE=1;
00065C  A8E094     BSET IEC0, #7
123:                   // SPI1 configuration (pixel output)
124:                   SPI1CON1=0;
00065E  EB0280     CLR W5
000660  881215     MOV W5, SPI1CON1
125:                   SPI1CON1bits.DISSCK=1;
000662  A88243     BSET 0x243, #4
126:                   SPI1CON1bits.MSTEN=1;
000664  A8A242     BSET SPI1CON1, #5
127:                   SPI1CON1bits.SPRE=7;
000666  2001C0     MOV #0x1C, W0
000668  B72242     IOR SPI1CON1
128:                   SPI1CON1bits.PPRE=2;
00066A  801214     MOV SPI1CON1, W4
00066C  A10004     BCLR W4, #0
00066E  A01004     BSET W4, #1
000670  881214     MOV W4, SPI1CON1
129:                   SPI1CON2=1;
000672  200014     MOV #0x1, W4
000674  881224     MOV W4, SPI1CON2
130:                   SPI1STATbits.SPIEN=1;
000676  A8E241     BSET 0x241, #7
131:                   T2CONbits.TON=1;
000678  A8E111     BSET 0x111, #7
132:                   cursor_pos.y=0;
00067A  FD0280     EXCH W0, W5
00067C  B7EAB2     MOV.B WREG, cursor_pos
00067E  B7EAB3     MOV.B WREG, 0xAB3
000680  FD0280     EXCH W0, W5
133:                   cursor_pos.x=0;
134:               }//horz_sync_init()
000682  060000     RETURN
135:               
136:               void  wait_n_frame(unsigned n){
137:               unsigned long f0;
138:                   f0=frame_cntr+n;
000684  805574     MOV frame_cntr, W4
000686  805585     MOV 0xAB0, W5
000688  420000     ADD W4, W0, W0
00068A  4A80E0     ADDC W5, #0x0, W1
139:                   while (frame_cntr<f0);
00068C  805574     MOV frame_cntr, W4
00068E  805585     MOV 0xAB0, W5
000690  500F84     SUB W0, W4, [W15]
000692  588F85     SUBB W1, W5, [W15]
000694  3EFFFB     BRA GTU, 0x68C
140:               }//f()
000696  060000     RETURN
141:               
142:               void clear_screen(){ // clear screen
143:                   flags |= F_CLEAR;
000698  A82AAC     BSET flags, #1
144:                   while (flags & F_CLEAR);
00069A  AB2AAC     BTST flags, #1
00069C  3AFFFE     BRA NZ, 0x69A
145:               }//f()
00069E  060000     RETURN
146:               
147:               void clear_eol(){// clear line from cursor to end of line
148:                   flags |= F_CLREOL;
0006A0  A84AAC     BSET flags, #2
149:               }//f()
0006A2  060000     RETURN
150:               
151:               void move_cursor(unsigned line, unsigned column){
152:                   cursor_pos.y=line;
0006A4  B7EAB2     MOV.B WREG, cursor_pos
153:                   cursor_pos.x=column;
0006A6  780001     MOV W1, W0
0006A8  B7EAB3     MOV.B WREG, 0xAB3
154:               }//f()
0006AA  060000     RETURN
155:               
156:               unsigned get_cursor(){
157:                   return cursor_pos.yx;
0006AC  805590     MOV cursor_pos, W0
158:               }//f()
0006AE  060000     RETURN
159:               
160:               void put_char(char c){// put character at current cursor position & move cursor forward
161:                   pchar_queue[tail++]=c;
0006B0  8056B4     MOV tail, W4
0006B2  20AB65     MOV #0xAB6, W5
0006B4  7A7280     MOV.B W0, [W5+W4]
0006B6  E80204     INC W4, W4
0006B8  8856B4     MOV W4, tail
162:                   tail %= QUEUE_SIZE;
0006BA  2001F0     MOV #0x1F, W0
0006BC  B62AD6     AND tail
163:                   flags |= F_PCHAR;
0006BE  A80AAC     BSET flags, #0
164:               }//f()
0006C0  060000     RETURN
165:               
166:               void print(const char *str){
0006C2  781F88     MOV W8, [W15++]
0006C4  780400     MOV W0, W8
167:                   while (*str){
0006C6  784018     MOV.B [W8], W0
0006C8  504FE0     SUB.B W0, #0x0, [W15]
0006CA  320004     BRA Z, 0x6D4
0006CE  784058     MOV.B [++W8], W0
0006D0  504FE0     SUB.B W0, #0x0, [W15]
0006D2  3AFFFC     BRA NZ, 0x6CC
168:                       put_char(*str++);
0006CC  07FFF1     RCALL put_char
169:                   }
170:               }//f()
0006D4  78044F     MOV [--W15], W8
0006D6  060000     RETURN
171:               
172:               void wait_while_printing(){
173:                   while (flags & F_PCHAR);
0006D8  AB0AAC     BTST flags, #0
0006DA  3AFFFE     BRA NZ, wait_while_printing
174:               }//f()
0006DC  060000     RETURN
175:               
176:               void scroll_up(){ //scroll screen 1 line up
177:                   memmove((char*)video_buffer,(char*)video_buffer[1],sizeof(char)*COLUMNS*(LINES-1));
0006DE  2028A2     MOV #0x28A, W2
0006E0  208191     MOV #0x819, W1
0006E2  208000     MOV #0x800, W0
0006E4  07FDD9     RCALL 0x298
178:                   memset((char*)video_buffer[LINES-1],0,sizeof(char)*COLUMNS);
0006E6  20A8A4     MOV #0xA8A, W4
0006E8  090018     REPEAT #0x18
0006EA  EB5A00     CLR.B [W4++]
179:               }//f()
0006EC  060000     RETURN
180:               
181:               void cursor_forward(){
182:                   cursor_pos.x++;
0006EE  EC6AB3     INC.B 0xAB3
183:                   if (cursor_pos.x>=COLUMNS){
0006F0  20AB34     MOV #0xAB3, W4
0006F2  784214     MOV.B [W4], W4
0006F4  524FF8     SUB.B W4, #0x18, [W15]
0006F6  360008     BRA LEU, 0x708
184:                       cursor_pos.x=0;
0006F8  EF6AB3     CLR.B 0xAB3
185:                       cursor_pos.y++;
0006FA  EC6AB2     INC.B cursor_pos
186:                       if (cursor_pos.y>=LINES){
0006FC  20AB24     MOV #0xAB2, W4
0006FE  784214     MOV.B [W4], W4
000700  524FFA     SUB.B W4, #0x1A, [W15]
000702  360002     BRA LEU, 0x708
187:                           cursor_pos.y--;
000704  ED6AB2     DEC.B cursor_pos
188:                           scroll_up();
000706  07FFEB     RCALL scroll_up
189:                       }//if
190:                   }//if
191:               }//f()
000708  060000     RETURN
192:               
193:               // video sync signal generation
194:               void __attribute__((interrupt,no_auto_psv,shadow)) _T2Interrupt(void){
00070A  FEA000     PUSH.S
00070C  F80036     PUSH RCOUNT
00070E  BE9F84     MOV.D W4, [W15++]
000710  BE9F86     MOV.D W6, [W15++]
195:                   frame_line_cntr++;
000712  805554     MOV frame_line_cntr, W4
000714  E80204     INC W4, W4
000716  885554     MOV W4, frame_line_cntr
196:                   switch (frame_line_cntr){
000718  200375     MOV #0x37, W5
00071A  520F85     SUB W4, W5, [W15]
00071C  32002D     BRA Z, 0x778
00071E  3E0007     BRA GTU, 0x72E
000720  520FE4     SUB W4, #0x4, [W15]
000722  320018     BRA Z, 0x754
000724  520FFE     SUB W4, #0x1E, [W15]
000726  32001B     BRA Z, 0x75E
000728  520FE1     SUB W4, #0x1, [W15]
00072A  3A0049     BRA NZ, 0x7BE
00072C  37000F     BRA 0x74C
00072E  201075     MOV #0x107, W5
000730  520F85     SUB W4, W5, [W15]
000732  32002F     BRA Z, 0x792
000734  3E0004     BRA GTU, 0x73E
000736  5282F1     SUB W5, #0x11, W5
000738  520F85     SUB W4, W5, [W15]
00073A  3A0041     BRA NZ, 0x7BE
00073C  370017     BRA 0x76C
00073E  2010F5     MOV #0x10F, W5
000740  520F85     SUB W4, W5, [W15]
000742  320021     BRA Z, 0x786
000744  201395     MOV #0x139, W5
000746  520F85     SUB W4, W5, [W15]
000748  3A003A     BRA NZ, 0x7BE
00074A  37002E     BRA 0x7A8
197:                       case 1:
198:                           OC1R=vsync;
00074C  F80AA4     PUSH vsync
00074E  F90182     POP OC1R
199:                           OC3CON=0;
000750  EF2190     CLR OC3CON
200:                           break;
000752  370070     BRA 0x834
201:                       case 4:
202:                           OC3CON=5;
000754  200054     MOV #0x5, W4
000756  880C84     MOV W4, OC3CON
203:                           OC1R=hsync;
000758  F80AA6     PUSH hsync
00075A  F90182     POP OC1R
204:                           break;
00075C  37006B     BRA 0x834
205:                       case NTSC_FIRST_VISIBLE:
206:                           if (video_mode==NTSC_MODE){
00075E  805544     MOV video_mode, W4
000760  520FE0     SUB W4, #0x0, [W15]
000762  3A0068     BRA NZ, 0x834
207:                               IFS1bits.CNIF=0;
000764  A96086     BCLR IFS1, #3
208:                               IEC1bits.CNIE=1;
000766  A86096     BSET IEC1, #3
209:                               flags &= ~F_RETRACE;
000768  A96AAC     BCLR flags, #3
00076A  370064     BRA 0x834
210:                           }
211:                           break;
212:                       case NTSC_LAST_VISIBLE:
213:                           if (video_mode==NTSC_MODE){
00076C  805544     MOV video_mode, W4
00076E  520FE0     SUB W4, #0x0, [W15]
000770  3A0061     BRA NZ, 0x834
214:                               IEC1bits.CNIE=0;
000772  A96096     BCLR IEC1, #3
215:                               flags |= F_RETRACE;
000774  A86AAC     BSET flags, #3
000776  37005E     BRA 0x834
216:                           }
217:                           break;
218:                       case PAL_FIRST_VISIBLE:
219:                           if (video_mode==PAL_MODE){
000778  805544     MOV video_mode, W4
00077A  520FE1     SUB W4, #0x1, [W15]
00077C  3A005B     BRA NZ, 0x834
220:                               IFS1bits.CNIF=0;
00077E  A96086     BCLR IFS1, #3
221:                               IEC1bits.CNIE=1;
000780  A86096     BSET IEC1, #3
222:                               flags &= ~F_RETRACE;
000782  A96AAC     BCLR flags, #3
000784  370057     BRA 0x834
223:                           }
224:                           break;
225:                       case PAL_LAST_VISIBLE:
226:                           if (video_mode==PAL_MODE){
000786  805544     MOV video_mode, W4
000788  520FE1     SUB W4, #0x1, [W15]
00078A  3A0054     BRA NZ, 0x834
227:                               IEC1bits.CNIE=0;
00078C  A96096     BCLR IEC1, #3
228:                               flags |= F_RETRACE;
00078E  A86AAC     BSET flags, #3
000790  370051     BRA 0x834
229:                           }
230:                           break;
231:                       case NTSC_LINES_PER_FRAME+1:
232:                           if (video_mode==NTSC_MODE){
000792  805544     MOV video_mode, W4
000794  520FE0     SUB W4, #0x0, [W15]
000796  3A004E     BRA NZ, 0x834
233:                               frame_line_cntr=0;
000798  EF2AAA     CLR frame_line_cntr
234:                               frame_cntr++;
00079A  805574     MOV frame_cntr, W4
00079C  805585     MOV 0xAB0, W5
00079E  420261     ADD W4, #0x1, W4
0007A0  4A82E0     ADDC W5, #0x0, W5
0007A2  885574     MOV W4, frame_cntr
0007A4  885585     MOV W5, 0xAB0
0007A6  370046     BRA 0x834
235:                           }
236:                           break;
237:                       case PAL_LINES_PER_FRAME+1:
238:                           if (video_mode==PAL_MODE){
0007A8  805544     MOV video_mode, W4
0007AA  520FE1     SUB W4, #0x1, [W15]
0007AC  3A0043     BRA NZ, 0x834
239:                               frame_line_cntr=0;
0007AE  EF2AAA     CLR frame_line_cntr
240:                               frame_cntr++;
0007B0  805574     MOV frame_cntr, W4
0007B2  805585     MOV 0xAB0, W5
0007B4  420261     ADD W4, #0x1, W4
0007B6  4A82E0     ADDC W5, #0x0, W5
0007B8  885574     MOV W4, frame_cntr
0007BA  885585     MOV W5, 0xAB0
0007BC  37003B     BRA 0x834
241:                           }
242:                           break;
243:                       default:
244:                           if (flags & F_RETRACE){
0007BE  AB6AAC     BTST flags, #3
0007C0  320039     BRA Z, 0x834
245:                               if (flags & F_CLEAR){
0007C2  AB2AAC     BTST flags, #1
0007C4  32000A     BRA Z, 0x7DA
246:                                   memset((char*)video_buffer,0,sizeof(char)*LINES*COLUMNS);
0007C6  208005     MOV #0x800, W5
0007C8  0902A2     REPEAT #0x2A2
0007CA  EB5A80     CLR.B [W5++]
247:                                   flags &= ~F_CLEAR;
0007CC  A92AAC     BCLR flags, #1
248:                                   cursor_pos.y=0;
0007CE  EB4200     CLR.B W4
0007D0  FD0200     EXCH W0, W4
0007D2  B7EAB2     MOV.B WREG, cursor_pos
0007D4  B7EAB3     MOV.B WREG, 0xAB3
0007D6  FD0200     EXCH W0, W4
0007D8  37002D     BRA 0x834
249:                                   cursor_pos.x=0;
250:                               } else if (flags & F_CLREOL){
0007DA  AB4AAC     BTST flags, #2
0007DC  320012     BRA Z, 0x802
251:                                   memset((char*)video_buffer[cursor_pos.y]+cursor_pos.x,
0007E2  BFCAB2     MOV.B cursor_pos, WREG
0007E4  20AB35     MOV #0xAB3, W5
0007E6  784295     MOV.B [W5], W5
0007EC  B3C192     MOV #0x19, W2
0007EE  BC4004     MUL.B WREG2
0007F0  FB8285     ZE W5, W5
0007F2  410005     ADD W2, W5, W0
0007F4  208005     MOV #0x800, W5
0007F6  400005     ADD W0, W5, W0
0007F8  780104     MOV W4, W2
0007FA  EB0080     CLR W1
0007FC  07FD5E     RCALL 0x2BA
252:                                           0,sizeof(char)*(COLUMNS-cursor_pos.x));
0007DE  20AB34     MOV #0xAB3, W4
0007E0  784214     MOV.B [W4], W4
0007E8  FB8204     ZE W4, W4
0007EA  120279     SUBR W4, #0x19, W4
253:                                   flags &= ~F_CLREOL;
0007FE  A94AAC     BCLR flags, #2
000800  370019     BRA 0x834
254:                               }else if (flags & F_PCHAR){
000802  AB0AAC     BTST flags, #0
000804  320017     BRA Z, 0x834
255:                                   video_buffer[cursor_pos.y][cursor_pos.x]=pchar_queue[head]-32;
000806  BFCAB2     MOV.B cursor_pos, WREG
000808  20AB35     MOV #0xAB3, W5
00080A  784295     MOV.B [W5], W5
00080C  8055A4     MOV head, W4
00080E  20AB66     MOV #0xAB6, W6
000810  7A4266     MOV.B [W6+W4], W4
000812  FB8285     ZE W5, W5
000814  B3C192     MOV #0x19, W2
000816  BC4004     MUL.B WREG2
000818  410285     ADD W2, W5, W5
00081A  208006     MOV #0x800, W6
00081C  430285     ADD W6, W5, W5
00081E  B3CE06     MOV #0xE0, W6
000820  424A86     ADD.B W4, W6, [W5]
256:                                   cursor_forward();
000822  07FF65     RCALL cursor_forward
257:                                   head++;
000824  EC2AB4     INC head
258:                                   head %= QUEUE_SIZE;
000826  2001F0     MOV #0x1F, W0
000828  B62AB4     AND head
259:                                   if (head==tail){
00082A  8055A5     MOV head, W5
00082C  8056B4     MOV tail, W4
00082E  528F84     SUB W5, W4, [W15]
000830  3A0001     BRA NZ, 0x834
260:                                       flags &= ~F_PCHAR;
000832  A90AAC     BCLR flags, #0
261:                                   }
262:                               }//if
263:                           }//if
264:                           break;
265:                   }//switch
266:                   IFS0bits.T2IF=0;
000834  A9E084     BCLR IFS0, #7
267:               }// _T2Interrupt()
000836  BE034F     MOV.D [--W15], W6
000838  BE024F     MOV.D [--W15], W4
00083A  F90036     POP RCOUNT
00083C  FE8000     POP.S
00083E  064000     RETFIE
268:               
269:               void __attribute__((interrupt,no_auto_psv,shadow)) _CNInterrupt(void){
000840  FEA000     PUSH.S
000842  BE9F84     MOV.D W4, [W15++]
000844  BE9F86     MOV.D W6, [W15++]
00086C  4283F9     ADD W5, #0x19, W7
270:                   int y,x,l;
271:                   char *b;
272:                   if (PORTBbits.RB11){
000846  801655     MOV PORTB, W5
000848  208004     MOV #0x800, W4
00084A  628204     AND W5, W4, W4
00084C  32001E     BRA Z, 0x88A
273:                       if (video_mode==NTSC_MODE){
00084E  805544     MOV video_mode, W4
000850  520FE0     SUB W4, #0x0, [W15]
000852  3A0005     BRA NZ, 0x85E
274:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE)>>3;
000854  805550     MOV frame_line_cntr, W0
000856  50007E     SUB W0, #0x1E, W0
000858  DE0243     LSR W0, #3, W4
275:                           l=(frame_line_cntr-NTSC_FIRST_VISIBLE)&7;
00085A  600067     AND W0, #0x7, W0
00085C  370004     BRA 0x866
276:                       }else{
277:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE)>>3;
00085E  805550     MOV frame_line_cntr, W0
000860  B10370     SUB #0x37, W0
000862  DE0243     LSR W0, #3, W4
278:                           l=(frame_line_cntr-PAL_FIRST_VISIBLE)&7;
000864  600067     AND W0, #0x7, W0
279:                       }
280:                       b=(char*)&video_buffer[y];
000866  B92279     MUL.SU W4, #25, W4
000868  208006     MOV #0x800, W6
00086A  430284     ADD W6, W4, W5
281:                       for (x=0;x<COLUMNS;x++){
000880  528F87     SUB W5, W7, [W15]
000882  3AFFF6     BRA NZ, 0x870
282:                           while (SPI1STATbits.SPITBF);
000870  AB2240     BTST SPI1STAT, #1
000872  3AFFFE     BRA NZ, 0x870
283:                           SPI1BUF=font6x8[(int)*b++][l];
00086E  282C86     MOV #0x82C8, W6
000874  FB0235     SE [W5++], W4
000876  DD2243     SL W4, #3, W4
000878  420200     ADD W4, W0, W4
00087A  7A4266     MOV.B [W6+W4], W4
00087C  FB8204     ZE W4, W4
00087E  881244     MOV W4, SPI1BUF
284:                       }//for
285:                       while (SPI1STATbits.SPITBF);
000884  AB2240     BTST SPI1STAT, #1
000886  3AFFFE     BRA NZ, 0x884
286:                       SPI1BUF=0;
000888  EF2248     CLR SPI1BUF
287:                   }
288:                   IFS1bits.CNIF=0;
00088A  A96086     BCLR IFS1, #3
289:               }// _CNInterrupt
00088C  BE034F     MOV.D [--W15], W6
00088E  BE024F     MOV.D [--W15], W4
000890  FE8000     POP.S
000892  064000     RETFIE
290:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  200x216 pixels  (HxV)
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include <stdio.h>
34:                #include <stdlib.h>
35:                #include <PPS.h>
36:                
37:                #include "hardwareProfile.h"
38:                #include "TVout.h"
39:                
40:                // PIC24FJ64GA002 Configuration Bit Settings
41:                // CONFIG2
42:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
43:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
44:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
45:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
46:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
47:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
48:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
49:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
50:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
51:                
52:                // CONFIG1
53:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
54:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
55:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
56:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
57:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
58:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
59:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
60:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
61:                
62:                void HardwareConfig(){
63:                    PPSUnLock;
000894  803A16     MOV OSCCON, W6
000896  B20BF6     AND #0xBF, W6
000898  200464     MOV #0x46, W4
00089A  200575     MOV #0x57, W5
00089C  207427     MOV #0x742, W7
00089E  784B84     MOV.B W4, [W7]
0008A0  784B85     MOV.B W5, [W7]
0008A2  784B86     MOV.B W6, [W7]
64:                    PPSOutput(PPS_RP5,PPS_OC2);   // audio output
0008A4  803626     MOV RPOR2, W6
0008A6  2E0FF7     MOV #0xE0FF, W7
0008A8  630307     AND W6, W7, W6
0008AA  213000     MOV #0x1300, W0
0008AC  730300     IOR W6, W0, W6
0008AE  883626     MOV W6, RPOR2
65:                    PPSOutput(PPS_RP6,PPS_OC1);   // video sync signal
0008B0  803630     MOV RPOR3, W0
0008B2  2FFE06     MOV #0xFFE0, W6
0008B4  600006     AND W0, W6, W0
0008B6  B30120     IOR #0x12, W0
0008B8  883630     MOV W0, RPOR3
66:                    PPSOutput(PPS_RP7,PPS_SDO1);  // video pixels
0008BA  803630     MOV RPOR3, W0
0008BC  600387     AND W0, W7, W7
0008BE  207000     MOV #0x700, W0
0008C0  738380     IOR W7, W0, W7
0008C2  883637     MOV W7, RPOR3
67:                    PPSOutput(PPS_RP10,PPS_OC3);  // video delay output
0008C4  803657     MOV RPOR5, W7
0008C6  638306     AND W7, W6, W6
0008C8  B30146     IOR #0x14, W6
0008CA  883656     MOV W6, RPOR5
68:                    TRISBbits.TRISB5=0;     //output
0008CC  A9A2C8     BCLR TRISB, #5
69:                    TRISBbits.TRISB6=0;     //output
0008CE  A9C2C8     BCLR TRISB, #6
70:                    TRISBbits.TRISB7=0;     //output
0008D0  A9E2C8     BCLR TRISB, #7
71:                    TRISBbits.TRISB10=0;    //output
0008D2  A942C9     BCLR 0x2C9, #2
72:                    TRISBbits.TRISB11=1;    //input   video delay synchronisation
0008D4  A862C9     BSET 0x2C9, #3
73:                    AD1PCFGbits.PCFG12=1;   //disable analog input
0008D6  A8832D     BSET 0x32D, #4
74:                    TRISBbits.TRISB12=1;    //input   NTSC/PAL select input
0008D8  A882C9     BSET 0x2C9, #4
75:                    PPSLock;
0008DA  803A16     MOV OSCCON, W6
0008DC  A06006     BSET W6, #6
0008DE  207427     MOV #0x742, W7
0008E0  784B84     MOV.B W4, [W7]
0008E2  784B85     MOV.B W5, [W7]
0008E4  784B86     MOV.B W6, [W7]
76:                }//f()
0008E6  060000     RETURN
77:                
78:                const char msg[]="hello world!";
79:                const char numbers[]=" 234567890123456789012|";
80:                
81:                int main(void) {
0008E8  BE9F88     MOV.D W8, [W15++]
0008EA  781F8A     MOV W10, [W15++]
82:                    int y;
83:                    HardwareConfig();
0008EC  07FFD3     RCALL HardwareConfig
84:                    video_init();
0008EE  07FEA4     RCALL video_init
85:                    for (y=0;y<LINES;y++){
0008F0  EB0400     CLR W8
000912  E80408     INC W8, W8
000914  540FFB     SUB W8, #0x1B, [W15]
000916  3AFFEF     BRA NZ, 0x8F6
000918  37FFFF     BRA 0x918
86:                        move_cursor(y,0);
0008F6  EB0080     CLR W1
0008F8  780008     MOV W8, W0
0008FA  07FED4     RCALL move_cursor
87:                        put_char(96+' ');
0008F2  B3C809     MOV #0x80, W9
0008FC  784009     MOV.B W9, W0
0008FE  07FED8     RCALL put_char
88:                        wait_n_frame(1);
000900  200010     MOV #0x1, W0
000902  07FEC0     RCALL wait_n_frame
89:                        move_cursor(y,COLUMNS-1);
000904  200181     MOV #0x18, W1
000906  780008     MOV W8, W0
000908  07FECD     RCALL move_cursor
90:                        put_char(97+' ');
0008F4  B3C81A     MOV #0x81, W10
00090A  78400A     MOV.B W10, W0
00090C  07FED1     RCALL put_char
91:                        wait_n_frame(1);
00090E  200010     MOV #0x1, W0
000910  07FEB9     RCALL wait_n_frame
92:                    }
93:                    while (1){
94:                        
95:                    }//while
96:                    return (EXIT_SUCCESS);
97:                }//main()
98:                
99:                
