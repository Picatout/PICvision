Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-03-06 22:03:15

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/timers.c  ---------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 *  NAME: timers.c
21:                 *  DATE CREATED: 2014-02-21
22:                 *  AUTHOR: Jacques Deschênes
23:                 *  DESCRIPTION: create timers with callback. TIMER1 is used as a system timer that
24:                 *               ticks at regular interval. The ISR of TIMER1 manage created timers.
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "timers.h"
29:                
30:                #define F_TMR_USED 1
31:                #define F_TMR_HALTED 2
32:                #define F_TMR_REPEAT 4
33:                #define TMR_RUNNING 1
34:                
35:                
36:                typedef struct timer_type{
37:                    unsigned status;    // slot used,  timer halted
38:                    unsigned delay;    // timer interval
39:                    unsigned countdown;
40:                    timer_handler_t *handler; // timer callback handler
41:                }timer_t;
42:                
43:                volatile static timer_t timers[MAX_TIMERS];
44:                volatile static unsigned long ticks;
45:                
46:                void timers_init(unsigned ticks_per_second){
00168E  BE9F88     MOV.D W8, [W15++]
001690  781F8A     MOV W10, [W15++]
001692  780500     MOV W0, W10
47:                    unsigned long quotient;
48:                    unsigned prescale;
49:                    int i;
50:                    for (i=0;i<MAX_TIMERS;i++){
001694  EB0200     CLR W4
0016A6  E80204     INC W4, W4
0016A8  520FE8     SUB W4, #0x8, [W15]
0016AA  3AFFF8     BRA NZ, 0x169C
51:                        timers[i].status=0;
001696  21FAA1     MOV #0x1FAA, W1
001698  EB0300     CLR W6
00169C  DD22C3     SL W4, #3, W5
00169E  408385     ADD W1, W5, W7
0016A0  780B86     MOV W6, [W7]
52:                        timers[i].handler=NULL;
00169A  408066     ADD W1, #0x6, W0
0016A2  400285     ADD W0, W5, W5
0016A4  780A86     MOV W6, [W5]
53:                    }//for
54:                    ticks=0;
0016AC  EF3FA6     CLR ticks
0016AE  EF3FA8     CLR 0x1FA8
55:                
56:                    SYSTICKTMR.TON=0;  // disable systick timer
0016B0  A9E105     BCLR 0x105, #7
57:                    SYSTICKTMR.TCS=0;  // use internal Tcy
0016B2  A92104     BCLR T1CON, #1
58:                    quotient = FCY/ticks_per_second;
0016B4  B85461     MUL.UU W10, #1, W8
0016B6  BE0108     MOV.D W8, W2
0016B8  224000     MOV #0x2400, W0
0016BA  200F41     MOV #0xF4, W1
0016BC  07F705     RCALL 0x4C8
59:                    prescale=1;
0016C4  200014     MOV #0x1, W4
60:                    while (quotient>65535){
0016BE  400FE1     ADD W0, #0x1, [W15]
0016C0  588FE0     SUBB W1, #0x0, [W15]
0016C2  36000B     BRA LEU, 0x16DA
0016C6  2FFFF6     MOV #0xFFFF, W6
0016C8  200007     MOV #0x0, W7
0016D0  500F86     SUB W0, W6, [W15]
0016D2  588F87     SUBB W1, W7, [W15]
0016D4  3EFFFA     BRA GTU, 0x16CA
61:                        quotient >>= 1;
0016CA  D10081     LSR W1, W1
0016CC  D38000     RRC W0, W0
62:                        prescale <<= 1;
0016CE  420204     ADD W4, W4, W4
63:                    }
64:                    if (prescale==1){
0016D6  520FE1     SUB W4, #0x1, [W15]
0016D8  3A0006     BRA NZ, 0x16E6
65:                        SYSTICKTMR.TCKPS=0;
0016DA  800824     MOV T1CON, W4
0016DC  A14004     BCLR W4, #4
0016DE  A15004     BCLR W4, #5
0016E0  880824     MOV W4, T1CON
66:                        SYSTICKPR=quotient;
0016E2  880810     MOV W0, PR1
0016E4  370020     BRA 0x1726
67:                    }else if (prescale<=8){
0016E6  520FE8     SUB W4, #0x8, [W15]
0016E8  3E000A     BRA GTU, 0x16FE
68:                        SYSTICKTMR.TCKPS=1;
0016EA  800824     MOV T1CON, W4
0016EC  A04004     BSET W4, #4
0016EE  A15004     BCLR W4, #5
0016F0  880824     MOV W4, T1CON
69:                        SYSTICKPR= FCY/8/ticks_per_second;
0016F2  BE0108     MOV.D W8, W2
0016F4  284800     MOV #0x8480, W0
0016F6  2001E1     MOV #0x1E, W1
0016F8  07F6E7     RCALL 0x4C8
0016FA  880810     MOV W0, PR1
0016FC  370014     BRA 0x1726
70:                    }else if (prescale<=64){
0016FE  200405     MOV #0x40, W5
001700  520F85     SUB W4, W5, [W15]
001702  3E000A     BRA GTU, 0x1718
71:                        SYSTICKTMR.TCKPS=2;
001704  800824     MOV T1CON, W4
001706  A14004     BCLR W4, #4
001708  A05004     BSET W4, #5
00170A  880824     MOV W4, T1CON
72:                        SYSTICKPR= FCY/64/ticks_per_second;
00170C  BE0108     MOV.D W8, W2
00170E  2D0900     MOV #0xD090, W0
001710  200031     MOV #0x3, W1
001712  07F6DA     RCALL 0x4C8
001714  880810     MOV W0, PR1
001716  370007     BRA 0x1726
73:                    }else{
74:                        SYSTICKTMR.TCKPS=3;
001718  200300     MOV #0x30, W0
00171A  B72104     IOR T1CON
75:                        SYSTICKPR = FCY/256/ticks_per_second;
00171C  2F4244     MOV #0xF424, W4
00171E  090011     REPEAT #0x11
001720  D8820A     DIV.UW W4, W10
001722  780200     MOV W0, W4
001724  880814     MOV W4, PR1
76:                    }//if
77:                    SYSTICKIF=0; // reset interrupt flag
001726  A96084     BCLR IFS0, #3
78:                    SYSTICKIE=1; // enable interrupt on systick timer
001728  A86094     BSET IEC0, #3
79:                    SYSTICKTMR.TON = 1; // enable systick timer
00172A  A8E105     BSET 0x105, #7
80:                }//f()
00172C  78054F     MOV [--W15], W10
00172E  BE044F     MOV.D [--W15], W8
001730  060000     RETURN
81:                
82:                int create_timer(unsigned delay, unsigned repeat, timer_handler_t *handler){
83:                    int i;
84:                    if (!handler) return -1;
001732  EB8200     SETM W4
001734  510FE0     SUB W2, #0x0, [W15]
001736  320020     BRA Z, 0x1778
85:                    for (i=0;i<MAX_TIMERS;i++){
00173C  200014     MOV #0x1, W4
001770  E80204     INC W4, W4
001772  520FE8     SUB W4, #0x8, [W15]
001774  3AFFE4     BRA NZ, 0x173E
86:                        if (!(timers[i].status & F_TMR_USED)){
001738  AB1FAA     BTST timers, #0
00173A  320007     BRA Z, 0x174A
00173E  DD22C3     SL W4, #3, W5
001740  21FAA6     MOV #0x1FAA, W6
001742  7A82E6     MOV [W6+W5], W5
001744  6282E1     AND W5, #0x1, W5
001746  3A0014     BRA NZ, 0x1770
001748  370001     BRA 0x174C
00174A  EB0200     CLR W4
87:                            timers[i].status = F_TMR_USED|F_TMR_HALTED;
00174C  DD22C3     SL W4, #3, W5
00174E  200037     MOV #0x3, W7
001750  21FAA6     MOV #0x1FAA, W6
001752  7AB307     MOV W7, [W6+W5]
88:                            if (repeat==TIMER_REPEAT) {timers[i].status |= F_TMR_REPEAT;}
001754  508FE1     SUB W1, #0x1, [W15]
001756  3A0004     BRA NZ, 0x1760
001758  7A83E6     MOV [W6+W5], W7
00175A  430285     ADD W6, W5, W5
00175C  A02007     BSET W7, #2
00175E  780A87     MOV W7, [W5]
89:                            timers[i].delay=delay;
001760  DD22C3     SL W4, #3, W5
001762  21FAC6     MOV #0x1FAC, W6
001764  7AB300     MOV W0, [W6+W5]
90:                            timers[i].countdown=delay;
001766  E88306     INC2 W6, W6
001768  7AB300     MOV W0, [W6+W5]
91:                            timers[i].handler=handler;
00176A  E88306     INC2 W6, W6
00176C  7AB302     MOV W2, [W6+W5]
92:                            return i;
00176E  370004     BRA 0x1778
93:                        }//if
94:                    }//for
95:                    return -1;
001776  EB8200     SETM W4
96:                }//f()
001778  780004     MOV W4, W0
00177A  060000     RETURN
97:                
98:                void stop_timer(int timer_id){
99:                    if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
00177C  500FE7     SUB W0, #0x7, [W15]
00177E  3E000B     BRA GTU, 0x1796
001786  620261     AND W4, #0x1, W4
001788  320006     BRA Z, 0x1796
100:                        (timers[timer_id].status & F_TMR_USED)){
001780  DD0243     SL W0, #3, W4
001782  21FAA5     MOV #0x1FAA, W5
001784  7A0265     MOV [W5+W4], W4
101:                       timers[timer_id].status |= F_TMR_HALTED;
00178A  DD0043     SL W0, #3, W0
00178C  780205     MOV W5, W4
00178E  7802E4     MOV [W4+W0], W5
001790  420000     ADD W4, W0, W0
001792  A01005     BSET W5, #1
001794  780805     MOV W5, [W0]
102:                   }//if
103:               }//f()
001796  060000     RETURN
104:               
105:               void start_timer(int timer_id){
106:                   if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
001798  500FE7     SUB W0, #0x7, [W15]
00179A  3E000F     BRA GTU, 0x17BA
0017A2  620261     AND W4, #0x1, W4
0017A4  32000A     BRA Z, 0x17BA
107:                       (timers[timer_id].status & F_TMR_USED)){
00179C  DD0243     SL W0, #3, W4
00179E  21FAA5     MOV #0x1FAA, W5
0017A0  7A0265     MOV [W5+W4], W4
108:                           timers[timer_id].countdown=timers[timer_id].delay;
0017A6  DD0043     SL W0, #3, W0
0017A8  E88300     INC2 W0, W6
0017AA  780205     MOV W5, W4
0017AC  4282E4     ADD W5, #0x4, W5
0017AE  7B0364     MOV [W4+W6], W6
0017B0  783286     MOV W6, [W5+W0]
109:                           timers[timer_id].status &= ~F_TMR_HALTED;
0017B2  7802E4     MOV [W4+W0], W5
0017B4  420000     ADD W4, W0, W0
0017B6  A11005     BCLR W5, #1
0017B8  780805     MOV W5, [W0]
110:                   }//if
111:               }//f()
0017BA  060000     RETURN
112:               
113:               void update_timer(int timer_id, unsigned new_delay){
114:                   if ((timer_id>=0)&&(timer_id<=MAX_TIMERS)&&timers[timer_id].status){
0017BC  500FE8     SUB W0, #0x8, [W15]
0017BE  3E0008     BRA GTU, 0x17D0
0017C0  DD0243     SL W0, #3, W4
0017C2  21FAA5     MOV #0x1FAA, W5
0017C4  7A0265     MOV [W5+W4], W4
0017C6  520FE0     SUB W4, #0x0, [W15]
0017C8  320003     BRA Z, 0x17D0
115:                       timers[timer_id].delay=new_delay;
0017CA  DD0043     SL W0, #3, W0
0017CC  E88205     INC2 W5, W4
0017CE  783201     MOV W1, [W4+W0]
116:                   }
117:               }//f()
0017D0  060000     RETURN
118:               
119:               void destroy_timer(int timer_id){
120:                   if ((timer_id<0)||(timer_id>=MAX_TIMERS)) return;
0017D2  500FE7     SUB W0, #0x7, [W15]
0017D4  3E0008     BRA GTU, 0x17E6
121:                   timers[timer_id].status=0;
0017D6  DD0043     SL W0, #3, W0
0017D8  21FAA5     MOV #0x1FAA, W5
0017DA  428280     ADD W5, W0, W5
0017DC  EB0200     CLR W4
0017DE  780A84     MOV W4, [W5]
122:                   timers[timer_id].handler=NULL;
0017E0  21FB05     MOV #0x1FB0, W5
0017E2  428000     ADD W5, W0, W0
0017E4  780804     MOV W4, [W0]
123:               }//f()
0017E6  060000     RETURN
124:               
125:               unsigned long sys_ticks(){
126:                   return ticks;
0017E8  80FD30     MOV ticks, W0
0017EA  80FD41     MOV 0x1FA8, W1
127:               }//f()
0017EC  060000     RETURN
128:               
129:               void __attribute__((interrupt,no_auto_psv)) _SYSTICK_ISR(void){
0017EE  F80036     PUSH RCOUNT
0017F0  BE9F80     MOV.D W0, [W15++]
0017F2  BE9F82     MOV.D W2, [W15++]
0017F4  BE9F84     MOV.D W4, [W15++]
0017F6  BE9F86     MOV.D W6, [W15++]
0017F8  BE9F88     MOV.D W8, [W15++]
0017FA  BE9F8A     MOV.D W10, [W15++]
130:                   int i;
131:                   ticks++;
0017FC  80FD34     MOV ticks, W4
0017FE  80FD45     MOV 0x1FA8, W5
001800  420261     ADD W4, #0x1, W4
001802  4A82E0     ADDC W5, #0x0, W5
001804  88FD34     MOV W4, ticks
001806  88FD45     MOV W5, 0x1FA8
132:                   for (i=0;i<MAX_TIMERS;i++){
001808  EB0400     CLR W8
001850  E80408     INC W8, W8
001852  540FE8     SUB W8, #0x8, [W15]
001854  3AFFDB     BRA NZ, 0x180C
133:                       if (((timers[i].status&(F_TMR_USED|F_TMR_HALTED))==TMR_RUNNING)){
00180C  DD4243     SL W8, #3, W4
00180E  21FAA5     MOV #0x1FAA, W5
001810  7A0265     MOV [W5+W4], W4
001812  620263     AND W4, #0x3, W4
001814  520FE1     SUB W4, #0x1, [W15]
001816  3A001C     BRA NZ, 0x1850
134:                           if (--timers[i].countdown==0){
00180A  21FAE9     MOV #0x1FAE, W9
001818  DD4343     SL W8, #3, W6
00181A  430264     ADD W6, #0x4, W4
00181C  7A03E5     MOV [W5+W4], W7
00181E  448306     ADD W9, W6, W6
001820  E90B07     DEC W7, [W6]
001822  7A0265     MOV [W5+W4], W4
001824  520FE0     SUB W4, #0x0, [W15]
001826  3A0014     BRA NZ, 0x1850
135:                               timers[i].handler();
001828  DD45C3     SL W8, #3, W11
00182A  458266     ADD W11, #0x6, W4
00182C  780505     MOV W5, W10
00182E  7A026A     MOV [W10+W4], W4
001830  010004     CALL W4
136:                               if (timers[i].status & F_TMR_REPEAT) {
001832  7D826A     MOV [W10+W11], W4
001834  620264     AND W4, #0x4, W4
001836  320006     BRA Z, 0x1844
137:                                   timers[i].countdown=timers[i].delay;
001838  78020B     MOV W11, W4
00183A  E88284     INC2 W4, W5
00183C  78030A     MOV W10, W6
00183E  7A8366     MOV [W6+W5], W6
001840  7A3486     MOV W6, [W9+W4]
001842  370006     BRA 0x1850
138:                               }else{
139:                                   timers[i].status |= F_TMR_HALTED;
001844  DD4243     SL W8, #3, W4
001846  21FAA5     MOV #0x1FAA, W5
001848  7A0365     MOV [W5+W4], W6
00184A  428204     ADD W5, W4, W4
00184C  A01006     BSET W6, #1
00184E  780A06     MOV W6, [W4]
140:                               }
141:                           }//if
142:                       }
143:                   }//for
144:                   SYSTICKIF=0;
001856  A96084     BCLR IFS0, #3
145:               }// _SYSTICK_ISR()
001858  BE054F     MOV.D [--W15], W10
00185A  BE044F     MOV.D [--W15], W8
00185C  BE034F     MOV.D [--W15], W6
00185E  BE024F     MOV.D [--W15], W4
001860  BE014F     MOV.D [--W15], W2
001862  BE004F     MOV.D [--W15], W0
001864  F90036     POP RCOUNT
001866  064000     RETFIE
146:               
147:               
148:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/text_console.c  ---------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   text_console.h
21:                 * Author: jacques Deschênes
22:                 * Description: manage text writing in video_buffer
23:                 * Created on 28 février 2014, 10:04
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                #include "text_console.h"
29:                
30:                //static text_coord_t cursor_pos;
31:                
32:                //#define X_OFS  ((HPIXELS-CHAR_PER_LINE*CHAR_WIDTH)/2)  // x offset to cursor from screen edge
33:                //#define Y_OFS  ((VPIXELS-LINE_PER_SCREEN*CHAR_HEIGHT)/2) // y offset to cursor from screen edge
34:                
35:                // boolean flags
36:                #define CUR_SHOW 1  // cursor active
37:                #define CUR_VIS  2  // cursor state visible
38:                #define INV_VID  4  // invert video
39:                
40:                
41:                static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
42:                static unsigned char tab_width=TAB_WIDTH;
43:                static cursor_t cur_shape=CR_UNDER;
44:                static unsigned short flags=0;
45:                
46:                
47:                
48:                void scroll_up(void){
49:                    char *src, *dst;
50:                    dst = (char*)video_buffer;
51:                    src = (char*)video_buffer + CHAR_HEIGHT*BYTES_PER_LINE;
52:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001332  215F02     MOV #0x15F0, W2
001334  208D81     MOV #0x8D8, W1
001336  208000     MOV #0x800, W0
001338  07F916     RCALL 0x566
53:                    dst= (char*)video_buffer+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*BYTES_PER_LINE;
54:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
00133A  21DF04     MOV #0x1DF0, W4
00133C  0900D7     REPEAT #0xD7
00133E  EB5A00     CLR.B [W4++]
55:                }//scroll_up();
001340  060000     RETURN
56:                
57:                void scroll_down(void){
58:                    char *src, *dst;
59:                    src = (char*)video_buffer;
60:                    dst = (char*)video_buffer+CHAR_HEIGHT*BYTES_PER_LINE;
61:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001342  215F02     MOV #0x15F0, W2
001344  208001     MOV #0x800, W1
001346  200D80     MOV #0xD8, W0
001348  400001     ADD W0, W1, W0
00134A  07F90D     RCALL 0x566
62:                    dst=(char*)video_buffer;
63:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
00134C  208004     MOV #0x800, W4
00134E  0900D7     REPEAT #0xD7
001350  EB5A00     CLR.B [W4++]
64:                }//scroll_down()
001352  060000     RETURN
65:                
66:                
67:                void cursor_right(void){
68:                    cx += CHAR_WIDTH;
001354  80FF74     MOV cx, W4
001356  420266     ADD W4, #0x6, W4
001358  88FF74     MOV W4, cx
69:                    if (cx>(CHAR_PER_LINE*CHAR_WIDTH)){
00135A  200D25     MOV #0xD2, W5
00135C  520F85     SUB W4, W5, [W15]
00135E  36000A     BRA LEU, 0x1374
70:                        cx = 0;
001360  EF3FEE     CLR cx
71:                        cy += CHAR_HEIGHT;
001362  80FF84     MOV cy, W4
001364  420268     ADD W4, #0x8, W4
001366  88FF84     MOV W4, cy
72:                        if (cy>(LINE_PER_SCREEN*CHAR_HEIGHT)){
001368  4282E6     ADD W5, #0x6, W5
00136A  520F85     SUB W4, W5, [W15]
00136C  360003     BRA LEU, 0x1374
73:                            scroll_up();
00136E  07FFE1     RCALL scroll_up
74:                            cy -= CHAR_HEIGHT;
001370  2FFF80     MOV #0xFFF8, W0
001372  B43FF0     ADD cy
75:                        }
76:                    }
77:                } // cursor_right()
001374  060000     RETURN
78:                
79:                void cursor_left(void){
80:                    if (cx>=CHAR_WIDTH){
001376  80FF74     MOV cx, W4
001378  520FE5     SUB W4, #0x5, [W15]
00137A  360003     BRA LEU, 0x1382
81:                        cx -= CHAR_WIDTH;
00137C  520266     SUB W4, #0x6, W4
00137E  88FF74     MOV W4, cx
001380  370009     BRA 0x1394
82:                    }else{
83:                        cx = CHAR_WIDTH*(CHAR_PER_LINE-1);
001382  200CC4     MOV #0xCC, W4
001384  88FF74     MOV W4, cx
84:                        if (cy>=CHAR_HEIGHT){
001386  80FF84     MOV cy, W4
001388  520FE7     SUB W4, #0x7, [W15]
00138A  360003     BRA LEU, 0x1392
85:                            cy -= CHAR_HEIGHT;
00138C  520268     SUB W4, #0x8, W4
00138E  88FF84     MOV W4, cy
001390  370001     BRA 0x1394
86:                        }else{
87:                            scroll_down();
001392  07FFD7     RCALL scroll_down
88:                        }
89:                    }
90:                }// cursor_left()
001394  060000     RETURN
91:                
92:                void cursor_up(void){
93:                    if (cy>=CHAR_HEIGHT){
001396  80FF84     MOV cy, W4
001398  520FE7     SUB W4, #0x7, [W15]
00139A  360003     BRA LEU, 0x13A2
94:                        cy -= CHAR_HEIGHT;
00139C  520268     SUB W4, #0x8, W4
00139E  88FF84     MOV W4, cy
0013A0  370001     BRA 0x13A4
95:                    }else{
96:                        scroll_down();
0013A2  07FFCF     RCALL scroll_down
97:                    }
98:                }// cursor_up()
0013A4  060000     RETURN
99:                
100:               void cursor_down(void){
101:                   if (cy<=(CHAR_HEIGHT*(LINE_PER_SCREEN-2))){
0013A6  80FF84     MOV cy, W4
0013A8  200C85     MOV #0xC8, W5
0013AA  520F85     SUB W4, W5, [W15]
0013AC  3E0003     BRA GTU, 0x13B4
102:                       cy += CHAR_HEIGHT;
0013AE  420268     ADD W4, #0x8, W4
0013B0  88FF84     MOV W4, cy
0013B2  370001     BRA 0x13B6
103:                   }else{
104:                       scroll_up();
0013B4  07FFBE     RCALL scroll_up
105:                   }
106:               }//cursor_down()
0013B6  060000     RETURN
107:               
108:               void crlf(void){
109:                   cx=0;
0013B8  EF3FEE     CLR cx
110:                   if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
0013BA  80FF84     MOV cy, W4
0013BC  200D05     MOV #0xD0, W5
0013BE  520F85     SUB W4, W5, [W15]
0013C0  3A0002     BRA NZ, 0x13C6
111:                       scroll_up();
0013C2  07FFB7     RCALL scroll_up
0013C4  370002     BRA 0x13CA
112:                   }else{
113:                       cy += CHAR_HEIGHT;
0013C6  420268     ADD W4, #0x8, W4
0013C8  88FF84     MOV W4, cy
114:                   }
115:               }//crlf()
0013CA  060000     RETURN
116:               
117:               void put_char(unsigned char c){
0013CC  4787E6     ADD W15, #0x6, W15
0013CE  BE9F88     MOV.D W8, [W15++]
0013D0  BE9F8A     MOV.D W10, [W15++]
0013D2  BE9F8C     MOV.D W12, [W15++]
0013D4  781F8E     MOV W14, [W15++]
00144C  E80389     INC W9, W7
00144E  B94A7B     MUL.SU W9, #27, W4
001450  780284     MOV W4, W5
001452  42820D     ADD W5, W13, W4
001454  208000     MOV #0x800, W0
001456  420200     ADD W4, W0, W4
00145A  DD3743     SL W6, #3, W14
00145C  285CA6     MOV #0x85CA, W6
00145E  470306     ADD W14, W6, W6
001460  E8068D     INC W13, W13
001462  42828D     ADD W5, W13, W5
001464  428280     ADD W5, W0, W5
001466  448069     ADD W9, #0x9, W0
118:                   register int i,l,r,b,x,y;
119:                   x=cx;
0013D6  80FF73     MOV cx, W3
120:                   y=cy;
0013D8  80FF89     MOV cy, W9
121:                   switch (c){
0013DA  504FE9     SUB.B W0, #0x9, [W15]
0013DC  320007     BRA Z, 0x13EC
0013DE  504FED     SUB.B W0, #0xD, [W15]
0013E0  320003     BRA Z, 0x13E8
0013E2  504FE8     SUB.B W0, #0x8, [W15]
0013E4  3A001B     BRA NZ, 0x141C
0013E6  370018     BRA 0x1418
122:                       case CR:
123:                           crlf();
0013E8  07FFE7     RCALL crlf
124:                           break;
0013EA  37006E     BRA 0x14C8
125:                       case TAB:
126:                           cx += (cx%tab_width);
0013EC  21FFA4     MOV #0x1FFA, W4
0013EE  784214     MOV.B [W4], W4
0013F0  FB8204     ZE W4, W4
0013F2  BE9F80     MOV.D W0, [W15++]
0013F4  090011     REPEAT #0x11
0013F6  D88184     DIV.UW W3, W4
0013F8  780201     MOV W1, W4
0013FA  BE004F     MOV.D [--W15], W0
0013FC  420183     ADD W4, W3, W3
0013FE  88FF73     MOV W3, cx
127:                           if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
001400  200D14     MOV #0xD1, W4
001402  518F84     SUB W3, W4, [W15]
001404  360061     BRA LEU, 0x14C8
128:                               cx = 0;
001406  EF3FEE     CLR cx
129:                               if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
001408  E90204     DEC W4, W4
00140A  548F84     SUB W9, W4, [W15]
00140C  3A0002     BRA NZ, 0x1412
130:                                   scroll_up();
00140E  07FF91     RCALL scroll_up
001410  37005B     BRA 0x14C8
131:                               }else{
132:                                   cy += CHAR_HEIGHT;
001412  4484E8     ADD W9, #0x8, W9
001414  88FF89     MOV W9, cy
001416  370058     BRA 0x14C8
133:                               }
134:                           }
135:                           break;
136:                       case '\b':
137:                           cursor_left();
001418  07FFAE     RCALL cursor_left
138:                           break;
00141A  370056     BRA 0x14C8
139:                       default:
140:                           if ((c<32) || (c>=(FONT_SIZE+32))) break;
00141C  B3CE06     MOV #0xE0, W6
00141E  404306     ADD.B W0, W6, W6
001420  B3C6D4     MOV #0x6D, W4
001422  534F84     SUB.B W6, W4, [W15]
001424  3E0051     BRA GTU, 0x14C8
141:                           c -=32;
142:                           b=x>>3; // character position in video_buffer
001426  DE9EC3     ASR W3, #3, W13
143:                           r=0;
144:                           l=(8-CHAR_WIDTH)-(x&7); // shift inside this byte
001428  6181E7     AND W3, #0x7, W3
00142A  1181E2     SUBR W3, #0x2, W3
145:                           if (l<0){
146:                               r=-l;
00142C  DE9A4F     ASR W3, #15, W4
00142E  EA0083     NEG W3, W1
001430  608084     AND W1, W4, W1
147:                           }
148:                           for (i=0;i<8;i++){
0014C2  538F80     SUB W7, W0, [W15]
0014C4  3AFFD1     BRA NZ, 0x1468
149:                               if (r){
001468  508FE0     SUB W1, #0x0, [W15]
00146A  320018     BRA Z, 0x149C
150:                                   if (flags & INV_VID){
001432  80FF52     MOV flags, W2
001434  610164     AND W2, #0x4, W2
00146C  510FE0     SUB W2, #0x0, [W15]
00146E  32000B     BRA Z, 0x1486
151:                                       video_buffer[y][b] |= (0x3f>>r);
001436  2003FA     MOV #0x3F, W10
001438  DED601     ASR W10, W1, W12
001478  764694     IOR.B W12, [W4], W13
152:                                       video_buffer[y][b] &=~(font6x8[(int)c][i]>>r);
001470  784696     MOV.B [W6], W13
001472  FB848D     ZE W13, W9
001474  DECF01     ASR W9, W1, W14
001476  EAC70E     COM.B W14, W14
00147A  674A0D     AND.B W14, W13, [W4]
153:                                       video_buffer[y][b+1] |= (0x3f<<(8-r));
00143A  108468     SUBR W1, #0x8, W8
00143C  DD5588     SL W10, W8, W11
001480  75C695     IOR.B W11, [W5], W13
154:                                       video_buffer[y][b+1] &= ~(font6x8[(int)c][i]<<(8-r));
00147C  DD4C88     SL W9, W8, W9
00147E  EAC489     COM.B W9, W9
001482  64CA8D     AND.B W9, W13, [W5]
001484  37001A     BRA 0x14BA
155:                                   }else{
156:                                       video_buffer[y][b] &= ~(0x3f>>r);
00143E  EAC20C     COM.B W12, W4
001440  9FF784     MOV.B W4, [W15-16]
00148A  97F68F     MOV.B [W15-16], W13
00148C  66C714     AND.B W13, [W4], W14
157:                                       video_buffer[y][b] |= font6x8[(int)c][i]>>r;
001486  784716     MOV.B [W6], W14
001488  FB848E     ZE W14, W9
00148E  DECE81     ASR W9, W1, W13
001490  774A0D     IOR.B W14, W13, [W4]
158:                                       video_buffer[y][b+1] &= ~(0x3f<<(8-r));
001442  EAC70B     COM.B W11, W14
001444  9FEFFE     MOV.B W14, [W15-17]
001492  97EF7F     MOV.B [W15-17], W14
001494  674695     AND.B W14, [W5], W13
159:                                       video_buffer[y][b+1] |= font6x8[(int)c][i]<<(8-r);
001496  DD4C88     SL W9, W8, W9
001498  76CA89     IOR.B W13, W9, [W5]
00149A  37000F     BRA 0x14BA
160:                                   }
161:                                   y++;
162:                               } else{
163:                                   if (flags & INV_VID){
00149C  510FE0     SUB W2, #0x0, [W15]
00149E  320007     BRA Z, 0x14AE
164:                                       video_buffer[y][b] |= (0x3f<<l);
001446  DD5503     SL W10, W3, W10
0014A8  754494     IOR.B W10, [W4], W9
165:                                       video_buffer[y++][b] &=~(font6x8[(int)c][i]<<l);
001458  FB8306     ZE W6, W6
0014A0  784496     MOV.B [W6], W9
0014A2  FB8689     ZE W9, W13
0014A4  DD6E83     SL W13, W3, W13
0014A6  EAC68D     COM.B W13, W13
0014AA  66CA09     AND.B W13, W9, [W4]
0014AC  370006     BRA 0x14BA
166:                                   }else{
167:                                       video_buffer[y][b] &= ~(0x3f<<l);
001448  EAC20A     COM.B W10, W4
00144A  9FEFE4     MOV.B W4, [W15-18]
0014AE  97EF6F     MOV.B [W15-18], W14
0014B0  674694     AND.B W14, [W4], W13
168:                                       video_buffer[y++][b] |= font6x8[(int)c][i]<<l;
0014B2  784716     MOV.B [W6], W14
0014B4  FB848E     ZE W14, W9
0014B6  DD4C83     SL W9, W3, W9
0014B8  76CA09     IOR.B W13, W9, [W4]
0014BA  E80387     INC W7, W7
0014BC  42027B     ADD W4, #0x1B, W4
0014BE  E80306     INC W6, W6
0014C0  4282FB     ADD W5, #0x1B, W5
169:                                   }
170:                               }
171:                           }
172:                           cursor_right();
0014C6  07FF46     RCALL cursor_right
173:                   }//switch(c)
174:               }//put_char()
0014C8  78074F     MOV [--W15], W14
0014CA  BE064F     MOV.D [--W15], W12
0014CC  BE054F     MOV.D [--W15], W10
0014CE  BE044F     MOV.D [--W15], W8
0014D0  B1006F     SUB #0x6, W15
0014D2  060000     RETURN
175:               
176:               void clear_screen(){
177:                   memset(video_buffer,0,HPIXELS/8*VPIXELS);
0014D4  208004     MOV #0x800, W4
0014D6  0916C7     REPEAT #0x16C7
0014D8  EB5A00     CLR.B [W4++]
178:                   cx=0;
0014DA  EB0200     CLR W4
0014DC  88FF74     MOV W4, cx
179:                   cy=0;
0014DE  88FF84     MOV W4, cy
180:               } // clear_screen()
0014E0  060000     RETURN
181:               
182:               void print(const char *text){
0014E2  781F88     MOV W8, [W15++]
0014E4  780400     MOV W0, W8
183:                   while (*text){
0014E6  784018     MOV.B [W8], W0
0014E8  504FE0     SUB.B W0, #0x0, [W15]
0014EA  320004     BRA Z, 0x14F4
0014EE  784058     MOV.B [++W8], W0
0014F0  504FE0     SUB.B W0, #0x0, [W15]
0014F2  3AFFFC     BRA NZ, 0x14EC
184:                       put_char(*text++);
0014EC  07FF6F     RCALL put_char
185:                   }
186:               }// print()
0014F4  78044F     MOV [--W15], W8
0014F6  060000     RETURN
187:               
188:               void print_hex(unsigned int hex, unsigned char width){
0014F8  FA000C     LNK #0xC
189:                   char c[12], *d;
190:                   int i;
191:                   c[11]=0;
0014FA  EB4200     CLR.B W4
0014FC  9FFFF4     MOV.B W4, [W15-1]
192:                   d= &c[10];
001500  E9820F     DEC2 W15, W4
193:                   for(i=width;i>=0||hex;i--){
0014FE  FB8301     ZE W1, W6
001502  37000C     BRA 0x151C
00151A  E90306     DEC W6, W6
00151C  530FE0     SUB W6, #0x0, [W15]
00151E  3DFFF2     BRA GE, 0x1504
001520  500FE0     SUB W0, #0x0, [W15]
001522  3AFFF0     BRA NZ, 0x1504
194:                       *d=(hex%16);
001504  6042EF     AND.B W0, #0xF, W5
001506  784A05     MOV.B W5, [W4]
195:                       if (*d<10)
001508  52CFE9     SUB.B W5, #0x9, [W15]
00150A  3C0003     BRA GT, 0x1512
196:                           *d += '0';
00150C  B3C307     MOV #0x30, W7
00150E  42CA07     ADD.B W5, W7, [W4]
001510  370002     BRA 0x1516
197:                       else
198:                           *d += 'A'-10;
001512  B3C377     MOV #0x37, W7
001514  42CA07     ADD.B W5, W7, [W4]
199:                       hex /=16;
001516  DE0044     LSR W0, #4, W0
200:                       d--;
001518  E90204     DEC W4, W4
201:                   }
202:                   print(++d);
001524  E80004     INC W4, W0
001526  07FFDD     RCALL print
203:               } // print_hex()
001528  FA8000     ULNK
00152A  060000     RETURN
204:               
205:               void print_int(int number, unsigned short width){ // imprime entier,width inclus le signe
00152C  FA000E     LNK #0xE
001572  538005     SUB W7, W5, W0
001574  780207     MOV W7, W4
206:                   int sign=0, i;
001538  EB0100     CLR W2
207:                   char str[14], *d;
208:                   str[13]=0;
00152E  EB4200     CLR.B W4
001530  9FFFF4     MOV.B W4, [W15-1]
001532  508FED     SUB W1, #0xD, [W15]
001534  360001     BRA LEU, 0x1538
001536  2000D1     MOV #0xD, W1
209:                   d=&str[12];
001548  E9820F     DEC2 W15, W4
001562  E9838F     DEC2 W15, W7
210:                   if (width>13){width=13;}
211:                   if (number<0){
00153A  500F82     SUB W0, W2, [W15]
00153C  3D0002     BRA GE, 0x1542
212:                       sign=1;
001540  200012     MOV #0x1, W2
213:                       number = -number;
00153E  EA0000     NEG W0, W0
214:                   }
215:                   //for (i=--width;i>=0||number;i--){
216:                   i=width;
001542  780281     MOV W1, W5
217:                   while (number>0){
001544  500FE0     SUB W0, #0x0, [W15]
001546  34000D     BRA LE, 0x1562
00155C  500FE0     SUB W0, #0x0, [W15]
00155E  3CFFF6     BRA GT, 0x154C
001560  370001     BRA 0x1564
218:                      *d--=(number%10)+'0';
00154A  2000A6     MOV #0xA, W6
00154C  780381     MOV W1, W7
00154E  090011     REPEAT #0x11
001550  D80006     DIV.SW W0, W6
001552  FD0381     EXCH W1, W7
001554  B3C303     MOV #0x30, W3
001556  43D203     ADD.B W7, W3, [W4--]
001558  780384     MOV W4, W7
219:                       number /= 10;
220:                       i--;
00155A  E90285     DEC W5, W5
221:                   }
222:                   if (i==width){
001564  508F85     SUB W1, W5, [W15]
001566  3A0003     BRA NZ, 0x156E
223:                       *d--='0';
001568  B3C304     MOV #0x30, W4
00156A  785384     MOV.B W4, [W7--]
224:                       i--;
00156C  E90285     DEC W5, W5
225:                   }
226:                   while (i>0){
00156E  528FE0     SUB W5, #0x0, [W15]
001570  340007     BRA LE, 0x1580
00157A  520F80     SUB W4, W0, [W15]
00157C  3AFFFD     BRA NZ, 0x1578
00157E  538385     SUB W7, W5, W7
227:                       *d--=' ';
001576  B3C206     MOV #0x20, W6
001578  785206     MOV.B W6, [W4--]
228:                       i--;
229:                   }
230:                   if (sign){*d='-';}else{*d=' ';}
001580  510FE0     SUB W2, #0x0, [W15]
001582  320003     BRA Z, 0x158A
001584  B3C2D4     MOV #0x2D, W4
001586  784B84     MOV.B W4, [W7]
001588  370002     BRA 0x158E
00158A  B3C204     MOV #0x20, W4
00158C  784B84     MOV.B W4, [W7]
231:                   print(d);
00158E  780007     MOV W7, W0
001590  07FFA8     RCALL print
232:               }// print_int()
001592  FA8000     ULNK
001594  060000     RETURN
233:               
234:               void set_tab_width(unsigned char width){
235:                   tab_width=width;
001596  B7FFFA     MOV.B WREG, tab_width
236:               }// set_tab_width()
001598  060000     RETURN
237:               
238:               void clear_eol(void){
00159A  BE9F88     MOV.D W8, [W15++]
00159C  BE9F8A     MOV.D W10, [W15++]
239:                   int x,y;
240:                   x=cx;
00159E  80FF7A     MOV cx, W10
241:                   y=cy;
0015A0  80FF8B     MOV cy, W11
242:                   while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
0015A2  200C54     MOV #0xC5, W4
0015A4  550F84     SUB W10, W4, [W15]
0015A6  3E0007     BRA GTU, 0x15B6
0015AA  780484     MOV W4, W9
0015B0  80FF74     MOV cx, W4
0015B2  520F89     SUB W4, W9, [W15]
0015B4  36FFFB     BRA LEU, 0x15AC
243:                       put_char(32);
0015A8  B3C208     MOV #0x20, W8
0015AC  784008     MOV.B W8, W0
0015AE  07FF0E     RCALL put_char
244:                   }
245:                   put_char(32);
0015B6  B3C200     MOV #0x20, W0
0015B8  07FF09     RCALL put_char
246:                   cx=x;
0015BA  88FF7A     MOV W10, cx
247:                   cy=y;
0015BC  88FF8B     MOV W11, cy
248:               }// clear_eol()
0015BE  BE054F     MOV.D [--W15], W10
0015C0  BE044F     MOV.D [--W15], W8
0015C2  060000     RETURN
249:               
250:               text_coord_t get_curpos(){
251:                   text_coord_t cpos;
252:                   cpos.x = cx/CHAR_WIDTH;
0015C4  80FF75     MOV cx, W5
0015C6  200064     MOV #0x6, W4
0015C8  781F80     MOV W0, [W15++]
0015CA  090011     REPEAT #0x11
0015CC  D88284     DIV.UW W5, W4
0015CE  780200     MOV W0, W4
0015D0  78004F     MOV [--W15], W0
0015D2  780804     MOV W4, [W0]
253:                   cpos.y = cy/CHAR_HEIGHT;
0015D4  80FF84     MOV cy, W4
0015D6  DE2243     LSR W4, #3, W4
0015D8  980014     MOV W4, [W0+2]
254:                   return cpos;
255:               } // get_cursor_pos()
0015DA  060000     RETURN
256:               
257:               void set_curpos(unsigned short x, unsigned short y){// {x,y} character coord.
258:                   if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
0015DC  200224     MOV #0x22, W4
0015DE  500F84     SUB W0, W4, [W15]
0015E0  3E0006     BRA GTU, 0x15EE
0015E2  508FFA     SUB W1, #0x1A, [W15]
0015E4  3E0004     BRA GTU, 0x15EE
259:                       return;
260:                   cx=x*CHAR_WIDTH;
0015E6  B90266     MUL.SU W0, #6, W4
0015E8  88FF74     MOV W4, cx
261:                   cy=y*CHAR_HEIGHT;
0015EA  DD08C3     SL W1, #3, W1
0015EC  88FF81     MOV W1, cy
262:               }//set_curpos()
0015EE  060000     RETURN
263:               
264:               void invert_char(void){// invert pixels of character at cursor position
0015F0  BE9F88     MOV.D W8, [W15++]
00160C  E80287     INC W7, W5
00160E  B93C7B     MUL.SU W7, #27, W8
001610  420008     ADD W4, W8, W0
001612  208004     MOV #0x800, W4
001614  400204     ADD W0, W4, W4
001616  4383EA     ADD W7, #0xA, W7
265:                   register int i,l,r,b,x,y;
266:                   x=cx;
0015F2  80FF71     MOV cx, W1
267:                   y=cy;
0015F4  80FF87     MOV cy, W7
268:                   b=x>>3;
0015F6  DE8A43     ASR W1, #3, W4
269:                   r=0;
270:                   l=(8-CHAR_WIDTH)-(x&7);
0015F8  6080E7     AND W1, #0x7, W1
0015FA  1080E2     SUBR W1, #0x2, W1
271:                   if (l<0){
272:                       r=-l;
0015FC  DE8ACF     ASR W1, #15, W5
0015FE  EA0301     NEG W1, W6
001600  630305     AND W6, W5, W6
273:                   }
274:                   for (i=9;i;i--){
00162C  528F87     SUB W5, W7, [W15]
00162E  3AFFF4     BRA NZ, 0x1618
275:                       if (r){
001618  530FE0     SUB W6, #0x0, [W15]
00161A  320005     BRA Z, 0x1626
276:                           video_buffer[y][b] ^= (0x3f>>r);
001602  2003F5     MOV #0x3F, W5
001604  DEA986     ASR W5, W6, W3
00161C  69CA14     XOR.B W3, [W4], [W4]
277:                           video_buffer[y][b+1] ^= (0x3f<<(8-r));
001606  130168     SUBR W6, #0x8, W2
001608  DD2902     SL W5, W2, W2
00161E  904014     MOV.B [W4+1], W0
001620  684002     XOR.B W0, W2, W0
001622  984210     MOV.B W0, [W4+1]
001624  370001     BRA 0x1628
278:                           y++;
279:                       } else{
280:                           video_buffer[y++][b] ^= (0x3f<<l);
00160A  DD2881     SL W5, W1, W1
001626  68CA14     XOR.B W1, [W4], [W4]
001628  E80285     INC W5, W5
00162A  42027B     ADD W4, #0x1B, W4
281:                       }
282:                   }
283:               }//invert_char()
001630  BE044F     MOV.D [--W15], W8
001632  060000     RETURN
284:               
285:               static void toggle_underscore(void){
286:                   register int l,r,b,x;
287:                   x=cx;
0012EA  80FF74     MOV cx, W4
288:                   b=x>>5;
0012EC  DEA2C5     ASR W4, #5, W5
289:                   r=0;
290:                   l=(8-CHAR_WIDTH)-(x&7);
0012EE  620267     AND W4, #0x7, W4
0012F0  120262     SUBR W4, #0x2, W4
291:                   if (l<0){
0012F2  3B0014     BRA NN, 0x131C
292:                       r=-l;
0012F4  EA0304     NEG W4, W6
293:                   }
294:                   if (r){
0012F6  320012     BRA Z, 0x131C
295:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
0012F8  80FF80     MOV cy, W0
0012FA  400067     ADD W0, #0x7, W0
0012FC  208004     MOV #0x800, W4
0012FE  B9007B     MUL.SU W0, #27, W0
001300  400085     ADD W0, W5, W1
001302  420101     ADD W4, W1, W2
001304  2003F7     MOV #0x3F, W7
001306  DEB986     ASR W7, W6, W3
001308  78C0E4     MOV.B [W4+W1], W1
00130A  68C903     XOR.B W1, W3, [W2]
296:                       video_buffer[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<(8-r));
00130C  E80285     INC W5, W5
00130E  400285     ADD W0, W5, W5
001310  420005     ADD W4, W5, W0
001312  130368     SUBR W6, #0x8, W6
001314  DD3B86     SL W7, W6, W7
001316  7AC264     MOV.B [W4+W5], W4
001318  6A4807     XOR.B W4, W7, [W0]
00131A  37000A     BRA 0x1330
297:                   } else{
298:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
00131C  80FF80     MOV cy, W0
00131E  400067     ADD W0, #0x7, W0
001320  208006     MOV #0x800, W6
001322  B9007B     MUL.SU W0, #27, W0
001324  428280     ADD W5, W0, W5
001326  430385     ADD W6, W5, W7
001328  2003F0     MOV #0x3F, W0
00132A  DD0204     SL W0, W4, W4
00132C  7AC2E6     MOV.B [W6+W5], W5
00132E  6ACB84     XOR.B W5, W4, [W7]
299:                   }
300:               }//toggle_underscore()
001330  060000     RETURN
301:               
302:               void show_cursor(BOOL show){
001634  781F88     MOV W8, [W15++]
303:                   if (show){
001636  500FE0     SUB W0, #0x0, [W15]
001638  32000B     BRA Z, 0x1650
304:                       flags |= CUR_SHOW;
00163A  80FF54     MOV flags, W4
00163C  A00004     BSET W4, #0
305:                       flags ^= CUR_VIS;
00163E  A21004     BTG W4, #1
001640  88FF54     MOV W4, flags
306:                       if (cur_shape==CR_BLOCK){
001642  80FF64     MOV cur_shape, W4
001644  520FE1     SUB W4, #0x1, [W15]
001646  3A0002     BRA NZ, 0x164C
307:                           invert_char();
001648  07FFD3     RCALL invert_char
00164A  37000E     BRA 0x1668
308:                       }else{
309:                           toggle_underscore();
00164C  07FE4E     RCALL toggle_underscore
00164E  37000C     BRA 0x1668
310:                       }
311:                   }else{
312:                       if (flags & CUR_VIS){
001650  80FF58     MOV flags, W8
001652  640262     AND W8, #0x2, W4
001654  320008     BRA Z, 0x1666
313:                           if (cur_shape==CR_BLOCK){
001656  80FF64     MOV cur_shape, W4
001658  520FE1     SUB W4, #0x1, [W15]
00165A  3A0002     BRA NZ, 0x1660
314:                               invert_char();
00165C  07FFC9     RCALL invert_char
00165E  370001     BRA 0x1662
315:                           }else{
316:                               toggle_underscore();
001660  07FE44     RCALL toggle_underscore
317:                           }
318:                           flags &= ~CUR_VIS;
001662  A11008     BCLR W8, #1
001664  88FF58     MOV W8, flags
319:                       }
320:                       flags &= ~CUR_SHOW;
001666  A91FEA     BCLR flags, #0
321:                   }
322:               
323:               }// show_cursor()
001668  78044F     MOV [--W15], W8
00166A  060000     RETURN
324:               
325:               void set_cursor(cursor_t shape){
00166C  781F88     MOV W8, [W15++]
00166E  780400     MOV W0, W8
326:                   if (flags & CUR_VIS){
001670  AB3FEA     BTST flags, #1
001672  320006     BRA Z, 0x1680
327:                       show_cursor(FALSE);
001674  EB0000     CLR W0
001676  07FFDE     RCALL show_cursor
328:                       cur_shape=shape;
001678  88FF68     MOV W8, cur_shape
329:                       show_cursor(TRUE);
00167A  200010     MOV #0x1, W0
00167C  07FFDB     RCALL show_cursor
00167E  370001     BRA 0x1682
330:                   }else{
331:                       cur_shape=shape;
001680  88FF68     MOV W8, cur_shape
332:                   }
333:               }// set_cursor()
001682  78044F     MOV [--W15], W8
001684  060000     RETURN
334:               
335:               
336:               void invert_video(){
337:                   flags |= INV_VID;
001686  A85FEA     BSET flags, #2
338:               }//invert_video()
001688  060000     RETURN
339:               
340:               void normal_video(){
341:                   flags &= ~INV_VID;
00168A  A95FEA     BCLR flags, #2
342:               }//normal_video()
00168C  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/sound.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   sound.c
21:                 * Author: jacques Deschênes
22:                 * Description:  sound generation using PWM D.A.C.
23:                 * Created on 25 février 2014, 16:43
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include "sound.h"
28:                
29:                #define F_TONE  1  // tone playing flag
30:                #define F_TUNE  2  // flag tune playing
31:                #define F_WHITE 4  // white noise generation
32:                
33:                #define mTone_off() (AUDIOCON.OCM=0)
34:                #define mTone_on()  (AUDIOCON.OCM=5)
35:                
36:                
37:                volatile unsigned char fSound=0; // boolean flags
38:                volatile int tmrId;  // duratio timer identifier
39:                volatile unsigned int *tones_list;  // list of tones and interval for playing tune
40:                int tick_msec=10; // tick interval in milliseconds, default 10msec.
41:                
42:                void cb_tone(void){ // timer call back function
43:                    mTone_off();
0019FC  800C54     MOV OC2CON, W4
0019FE  A10004     BCLR W4, #0
001A00  A11004     BCLR W4, #1
001A02  A12004     BCLR W4, #2
001A04  880C54     MOV W4, OC2CON
44:                    fSound &= ~(F_TONE|F_WHITE);
001A06  21FF25     MOV #0x1FF2, W5
001A08  784295     MOV.B [W5], W5
001A0A  B3CFA4     MOV #0xFA, W4
001A0C  62C204     AND.B W5, W4, W4
001A0E  780004     MOV W4, W0
001A10  B7FFF2     MOV.B WREG, fSound
45:                }// f()
001A12  060000     RETURN
46:                
47:                void sound_init(int tick_time){
48:                    if (tick_time) tick_msec=tick_time;
001A14  500FE0     SUB W0, #0x0, [W15]
001A16  320001     BRA Z, 0x1A1A
001A18  88FFA0     MOV W0, tick_msec
49:                    tmrId=create_timer(1,TIMER_SINGLE,(timer_handler_t *)cb_tone);
001A1A  219FC2     MOV #0x19FC, W2
001A1C  EB0080     CLR W1
001A1E  200010     MOV #0x1, W0
001A20  07FE88     RCALL create_timer
001A22  88FFB0     MOV W0, tmrId
50:                    AUDIOCON.OCTSEL=1; // select OCx timer
001A24  A8618A     BSET OC2CON, #3
51:                    AUDIOR=0;
001A26  EF2188     CLR OC2R
52:                    AUDIOTMR.TON=0;
001A28  A9E113     BCLR 0x113, #7
53:                    AUDIOTMR.TCKPS=1; // 1:8  // timer clock prescale divisor
001A2A  800894     MOV T3CON, W4
001A2C  A04004     BSET W4, #4
001A2E  A15004     BCLR W4, #5
001A30  880894     MOV W4, T3CON
54:                }//f()
001A32  060000     RETURN
55:                
56:                // play tone in background
57:                void tone(unsigned freq, // frequency in hertz
58:                          unsigned msec){ // duration in  milliseconds
001A34  BE9F88     MOV.D W8, [W15++]
001A36  781F8A     MOV W10, [W15++]
001A38  780501     MOV W1, W10
59:                    //
60:                    mTone_off(); 
001A3A  800C54     MOV OC2CON, W4
001A3C  A10004     BCLR W4, #0
001A3E  A11004     BCLR W4, #1
001A40  A12004     BCLR W4, #2
001A42  880C54     MOV W4, OC2CON
61:                    AUDIORS=FCY/16/freq; // determine tone duty cycle
001A44  B80461     MUL.UU W0, #1, W8
001A46  BE0108     MOV.D W8, W2
001A48  242400     MOV #0x4240, W0
001A4A  2000F1     MOV #0xF, W1
001A4C  07F53D     RCALL 0x4C8
001A4E  880C30     MOV W0, OC2RS
62:                    AUDIOTMR.TON=0;
001A50  A9E113     BCLR 0x113, #7
63:                    AUDIOPR=(FCY/8/freq)-1; // pwm period
001A52  BE0108     MOV.D W8, W2
001A54  284800     MOV #0x8480, W0
001A56  2001E1     MOV #0x1E, W1
001A58  07F537     RCALL 0x4C8
001A5A  E90200     DEC W0, W4
001A5C  880874     MOV W4, PR3
64:                    fSound |=F_TONE;
001A5E  A81FF2     BSET fSound, #0
65:                    mTone_on(); 
001A60  800C54     MOV OC2CON, W4
001A62  A00004     BSET W4, #0
001A64  A11004     BCLR W4, #1
001A66  A02004     BSET W4, #2
001A68  880C54     MOV W4, OC2CON
66:                    AUDIOTMR.TON=1;
001A6A  A8E113     BSET 0x113, #7
67:                    update_timer(tmrId,msec/tick_msec);
001A6C  80FFB0     MOV tmrId, W0
001A6E  80FFA4     MOV tick_msec, W4
001A70  781F80     MOV W0, [W15++]
001A72  090011     REPEAT #0x11
001A74  D88504     DIV.UW W10, W4
001A76  780080     MOV W0, W1
001A78  78004F     MOV [--W15], W0
001A7A  07FEA0     RCALL update_timer
68:                    start_timer(tmrId);
001A7C  80FFB0     MOV tmrId, W0
001A7E  07FE8C     RCALL start_timer
69:                } //tone();
001A80  78054F     MOV [--W15], W10
001A82  BE044F     MOV.D [--W15], W8
001A84  060000     RETURN
70:                
71:                // play tune in background
72:                void tune(const unsigned *buffer){
73:                    tones_list=(unsigned *)buffer;
001A86  88FFC0     MOV W0, tones_list
74:                    if (*tones_list && *(tones_list+1)){
001A88  EB0200     CLR W4
001A8A  120F90     SUBR W4, [W0], [W15]
001A8C  32000C     BRA Z, 0x1AA6
001A8E  780200     MOV W0, W4
001A90  EB0280     CLR W5
001A92  128FD4     SUBR W5, [++W4], [W15]
001A94  320008     BRA Z, 0x1AA6
75:                        fSound |= F_TUNE;
001A96  A83FF2     BSET fSound, #1
76:                        AUDIOIF=0;
001A98  A90085     BCLR 0x85, #0
77:                        AUDIOIE=1;
001A9A  A80095     BSET 0x95, #0
78:                        tone(*tones_list++,*tones_list++);
001A9C  780090     MOV [W0], W1
001A9E  88FFC4     MOV W4, tones_list
001AA0  780034     MOV [W4++], W0
001AA2  88FFC4     MOV W4, tones_list
001AA4  07FFC7     RCALL tone
79:                    }
80:                }//tune()
001AA6  060000     RETURN
81:                
82:                
83:                void white_noise(unsigned msec){
84:                    if (!fSound){
001AA8  21FF24     MOV #0x1FF2, W4
001AAA  784214     MOV.B [W4], W4
001AAC  524FE0     SUB.B W4, #0x0, [W15]
001AAE  3A0010     BRA NZ, 0x1AD0
85:                        AUDIOTMR.TON=0;
001AB0  A9E113     BCLR 0x113, #7
86:                        AUDIOPR=(FCY/8/10000)-1; // pwm period
001AB2  200C74     MOV #0xC7, W4
001AB4  880874     MOV W4, PR3
87:                        AUDIOTMR.TON=0;
001AB6  A9E113     BCLR 0x113, #7
88:                        AUDIOIF=0;
001AB8  A90085     BCLR 0x85, #0
89:                        AUDIOIE=1;
001ABA  A80095     BSET 0x95, #0
90:                        AUDIOTMR.TON=1;
001ABC  A8E113     BSET 0x113, #7
91:                        update_timer(tmrId,msec/tick_msec);
001ABE  80FFB4     MOV tmrId, W4
001AC0  80FFA5     MOV tick_msec, W5
001AC2  090011     REPEAT #0x11
001AC4  D88005     DIV.UW W0, W5
001AC6  FD0080     EXCH W0, W1
001AC8  780004     MOV W4, W0
001ACA  07FE78     RCALL update_timer
92:                        start_timer(tmrId);
001ACC  80FFB0     MOV tmrId, W0
001ACE  07FE64     RCALL start_timer
93:                    }
94:                    fSound |= F_WHITE;
001AD0  A85FF2     BSET fSound, #2
95:                }// f()
001AD2  060000     RETURN
96:                
97:                void while_sound(){
98:                    while (fSound);
001AD4  21FF24     MOV #0x1FF2, W4
001AD6  784214     MOV.B [W4], W4
001AD8  524FE0     SUB.B W4, #0x0, [W15]
001ADA  3AFFFC     BRA NZ, while_sound
99:                }// f()
001ADC  060000     RETURN
100:               
101:               // interrupt at end of tone cycle
102:               void __attribute__((interrupt, no_auto_psv))  _AUDIO_ISR(void){
001ADE  F80036     PUSH RCOUNT
001AE0  BE9F80     MOV.D W0, [W15++]
001AE2  BE9F82     MOV.D W2, [W15++]
001AE4  BE9F84     MOV.D W4, [W15++]
001AE6  BE9F86     MOV.D W6, [W15++]
103:                  unsigned int f,d;
104:                  if (fSound&F_WHITE){
001AE8  21FF24     MOV #0x1FF2, W4
001AEA  784214     MOV.B [W4], W4
001AEC  620264     AND W4, #0x4, W4
001AEE  320007     BRA Z, 0x1AFE
105:                      P_NOISE_OUT=rand()&1;
001AF0  07F552     RCALL 0x596
001AF2  6002E1     AND W0, #0x1, W5
001AF4  DD2ACA     SL W5, #10, W5
001AF6  801664     MOV LATB, W4
001AF8  A1A004     BCLR W4, #10
001AFA  720205     IOR W4, W5, W4
001AFC  881664     MOV W4, LATB
106:                  }
107:                  if (!fSound) {
001AFE  21FF24     MOV #0x1FF2, W4
001B00  784214     MOV.B [W4], W4
001B02  524FE0     SUB.B W4, #0x0, [W15]
001B04  3A0003     BRA NZ, 0x1B0C
108:                      AUDIOIE=0;
001B06  A90095     BCLR 0x95, #0
109:                      AUDIOTMR.TON=0;
001B08  A9E113     BCLR 0x113, #7
001B0A  370027     BRA 0x1B5A
110:                  }else if (fSound==(fSound & F_TUNE)){
001B0C  21FF25     MOV #0x1FF2, W5
001B0E  784295     MOV.B [W5], W5
001B10  21FF24     MOV #0x1FF2, W4
001B12  784214     MOV.B [W4], W4
001B14  FB8285     ZE W5, W5
001B16  620262     AND W4, #0x2, W4
001B18  528F84     SUB W5, W4, [W15]
001B1A  3A001F     BRA NZ, 0x1B5A
111:                      f=*tones_list++;
001B1C  80FFC4     MOV tones_list, W4
001B1E  780034     MOV [W4++], W0
001B20  88FFC4     MOV W4, tones_list
112:                      d=*tones_list++;
001B22  7800B4     MOV [W4++], W1
001B24  88FFC4     MOV W4, tones_list
113:                      if (d){
001B26  508FE0     SUB W1, #0x0, [W15]
001B28  320015     BRA Z, 0x1B54
114:                           if (f){
001B2A  500FE0     SUB W0, #0x0, [W15]
001B2C  320002     BRA Z, 0x1B32
115:                               tone(f,d);
001B2E  07FF82     RCALL tone
001B30  370014     BRA 0x1B5A
116:                           }else{
117:                               update_timer(tmrId,d/tick_msec);
001B32  80FFB0     MOV tmrId, W0
001B34  80FFA4     MOV tick_msec, W4
001B36  781F80     MOV W0, [W15++]
001B38  090011     REPEAT #0x11
001B3A  D88084     DIV.UW W1, W4
001B3C  780080     MOV W0, W1
001B3E  78004F     MOV [--W15], W0
001B40  07FE3D     RCALL update_timer
118:                               start_timer(tmrId);
001B42  80FFB0     MOV tmrId, W0
001B44  07FE29     RCALL start_timer
119:                               fSound |= F_TONE;
001B46  A81FF2     BSET fSound, #0
120:                               mTone_on();
001B48  800C54     MOV OC2CON, W4
001B4A  A00004     BSET W4, #0
001B4C  A11004     BCLR W4, #1
001B4E  A02004     BSET W4, #2
001B50  880C54     MOV W4, OC2CON
001B52  370003     BRA 0x1B5A
121:                           }
122:                      }else{
123:                          fSound=0;
001B54  EF7FF2     CLR.B fSound
124:                          AUDIOIE=0;
001B56  A90095     BCLR 0x95, #0
125:                          AUDIOTMR.TON=0;
001B58  A9E113     BCLR 0x113, #7
126:                      } // if
127:                  }
128:                  AUDIOIF=0;
001B5A  A90085     BCLR 0x85, #0
129:               }// _AUDIO_ISR
001B5C  BE034F     MOV.D [--W15], W6
001B5E  BE024F     MOV.D [--W15], W4
001B60  BE014F     MOV.D [--W15], W2
001B62  BE004F     MOV.D [--W15], W0
001B64  F90036     POP RCOUNT
001B66  064000     RETFIE
130:               
131:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snes_paddle.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snes_paddle.c
21:                 * Author: jacques Deschênes
22:                 * Description:  SNES gemepad interface
23:                 *              1) a pulse on paddle latch input store last switches state in shift register
24:                 *              2) each rising edge of clock signal shift one bit out, bit 0 first.
25:                 *                 bit 0 is at output after latch so there is only 15 shift to do.
26:                 * Created on 25 février 2014, 16:41
27:                 */
28:                
29:                #include <stdlib.h>
30:                #include "snes_paddle.h"
31:                //#include "TVout.h"
32:                
33:                
34:                
35:                // the loop execute in 4 Tcy
36:                #define mDelay(usec) __asm__("MOV #%0,W4\n NOP\n DEC W4,W4\n BRA NZ .-4"::"i"(usec))
37:                
38:                void latch(){
39:                    P_PDL_LATCH=1;
001BE2  A822CC     BSET LATB, #1
40:                    mDelay(CYCLES_PER_USEC/4);
001BE4  200044     MOV #0x4, W4
001BE6  000000     NOP
001BE8  E90204     DEC W4, W4
001BEA  3AFFFD     BRA NZ, 0x1BE6
41:                    P_PDL_LATCH=0;
001BEC  A922CC     BCLR LATB, #1
42:                    mDelay(CYCLES_PER_USEC/4);
001BEE  200044     MOV #0x4, W4
001BF0  000000     NOP
001BF2  E90204     DEC W4, W4
001BF4  3AFFFD     BRA NZ, 0x1BF0
43:                }//f()
001BF6  060000     RETURN
44:                
45:                void bit_shift(){
46:                    P_PDL_CLK=1;
001BF8  A802CC     BSET LATB, #0
47:                    mDelay(CYCLES_PER_USEC/4);
001BFA  200044     MOV #0x4, W4
001BFC  000000     NOP
001BFE  E90204     DEC W4, W4
001C00  3AFFFD     BRA NZ, 0x1BFC
48:                    P_PDL_CLK=0;
001C02  A902CC     BCLR LATB, #0
49:                    mDelay(CYCLES_PER_USEC/4);
001C04  200044     MOV #0x4, W4
001C06  000000     NOP
001C08  E90204     DEC W4, W4
001C0A  3AFFFD     BRA NZ, 0x1C06
50:                }// f()
001C0C  060000     RETURN
51:                
52:                unsigned read_paddle(int paddleId) {
001C0E  BE9F88     MOV.D W8, [W15++]
001C10  BE9F8A     MOV.D W10, [W15++]
001C12  BE9F8C     MOV.D W12, [W15++]
001C14  780680     MOV W0, W13
53:                    unsigned i,pdata, p1,p2;
54:                    p1=0;
001C1A  780509     MOV W9, W10
55:                    p2=0;
001C18  EB0480     CLR W9
56:                    latch(); // latch data in paddles shift register
001C16  07FFE5     RCALL latch
57:                    // shift out is least significant bit first.
58:                    for (i=0;i<15;i++){ // SNES paddle have 16 bits shift register
001C1C  780409     MOV W9, W8
001C36  E80408     INC W8, W8
001C38  540FEF     SUB W8, #0xF, [W15]
001C3A  3AFFF3     BRA NZ, 0x1C22
59:                        pdata=PADDLES_DATA_PORT;
001C22  801614     MOV PORTA, W4
60:                        p1 |= (pdata&PADDLE1)<<i;
001C24  6202E1     AND W4, #0x1, W5
001C26  DD2A88     SL W5, W8, W5
001C28  750505     IOR W10, W5, W10
61:                        p2 |= (pdata&PADDLE2)?1<<i:0;
001C1E  EB0580     CLR W11
001C20  20001C     MOV #0x1, W12
001C2A  620262     AND W4, #0x2, W4
001C2C  78028B     MOV W11, W5
001C2E  320001     BRA Z, 0x1C32
001C30  DD6288     SL W12, W8, W5
001C32  748485     IOR W9, W5, W9
62:                        bit_shift();
001C34  07FFE1     RCALL bit_shift
63:                    }
64:                    return paddleId==1?(~p1)&0xfff:(~p2)&0xfff;
001C3C  568FE1     SUB W13, #0x1, [W15]
001C3E  3A0004     BRA NZ, 0x1C48
001C40  EA800A     COM W10, W0
001C42  20FFF4     MOV #0xFFF, W4
001C44  600004     AND W0, W4, W0
001C46  370003     BRA 0x1C4E
001C48  EA8009     COM W9, W0
001C4A  20FFF4     MOV #0xFFF, W4
001C4C  600004     AND W0, W4, W0
65:                }//f()
001C4E  BE064F     MOV.D [--W15], W12
001C50  BE054F     MOV.D [--W15], W10
001C52  BE044F     MOV.D [--W15], W8
001C54  060000     RETURN
66:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snake.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   snake.c
21:                 * Author: jacques Deschênes
22:                 * Description: snake game.
23:                 * Created on 5 mars 2014, 16:01
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <time.h>
28:                #include "PICvision.h"
29:                
30:                
31:                // PIC24FJ64GA002 Configuration Bit Settings
32:                // CONFIG2
33:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
34:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
35:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
36:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
37:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
38:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
39:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
40:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
41:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
42:                
43:                // CONFIG1
44:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
45:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
46:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
47:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
48:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
49:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
50:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
51:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
52:                
53:                typedef struct symbol{
54:                    unsigned char x;
55:                    unsigned char y;
56:                    char part;
57:                }symbol_t;
58:                
59:                #define SNAKE_MAX_LEN  64
60:                
61:                typedef struct snake_struct{
62:                    unsigned length;
63:                    unsigned calories;
64:                    unsigned lifespan;
65:                    unsigned short dx;
66:                    unsigned short dy;
67:                    symbol_t body[SNAKE_MAX_LEN];
68:                }snake_t;
69:                
70:                typedef struct msg_struct{
71:                    unsigned char x;
72:                    unsigned char y;
73:                    char *text;
74:                }msg_t;
75:                
76:                // snake some symbols
77:                #define RING  102+32
78:                #define HEAD_RIGHT  103+32
79:                #define HEAD_LEFT 104+32
80:                #define HEAD_UP  105+32
81:                #define HEAD_DOWN 106+32
82:                #define MOUSE 109+32
83:                
84:                #define BASE_METABOLISM 1   // calories lost per seconde
85:                #define MOUSE_CALORIES  20  // calories gain by eating mouse
86:                
87:                snake_t snake;
88:                
89:                symbol_t mouse;
90:                
91:                const msg_t msgCALORIES={0,0,"calories: "};
92:                const msg_t msgSECONDS={15,0,"lifespan: "};
93:                const msg_t msgGAME_OVER={8,13,"game over"};
94:                const msg_t msgSTART={8,15, "press START to begin"};
95:                
96:                void print_msg(const msg_t msg){
000EE2  BE9F88     MOV.D W8, [W15++]
000EE4  BE0400     MOV.D W0, W8
97:                    set_curpos(msg.x,msg.y);
000EE6  DE00C8     LSR W0, #8, W1
000EE8  FB8008     ZE W8, W0
000EEA  070378     RCALL set_curpos
98:                    print(msg.text);
000EEC  780009     MOV W9, W0
000EEE  0702F9     RCALL print
99:                }//f()
000EF0  BE044F     MOV.D [--W15], W8
000EF2  060000     RETURN
100:               
101:               void new_mouse(){
000EF4  BE9F88     MOV.D W8, [W15++]
000EF6  781F8A     MOV W10, [W15++]
102:                   unsigned short i, collide,mouseX,mouseY;
103:                   collide=1;
104:                   while (collide){
105:                       mouseX=rand()%CHAR_PER_LINE;
000EF8  200239     MOV #0x23, W9
000EFC  07FB4C     RCALL 0x596
000EFE  780401     MOV W1, W8
000F00  090011     REPEAT #0x11
000F02  D80009     DIV.SW W0, W9
000F04  FD0401     EXCH W1, W8
106:                       mouseY=rand()%(LINE_PER_SCREEN-1)+1;
000F06  07FB47     RCALL 0x596
000F08  2001A4     MOV #0x1A, W4
000F0A  090011     REPEAT #0x11
000F0C  D80004     DIV.SW W0, W4
000F0E  E80081     INC W1, W1
107:                       for (i=0;i<snake.length;i++){
000EFA  21EE2A     MOV #0x1EE2, W10
000F10  80F6C0     MOV snake, W0
000F12  500FE0     SUB W0, #0x0, [W15]
000F14  320010     BRA Z, 0xF36
000F16  78020A     MOV W10, W4
000F18  EB0280     CLR W5
000F2A  E80285     INC W5, W5
000F2C  420263     ADD W4, #0x3, W4
000F2E  528F80     SUB W5, W0, [W15]
000F30  39FFF4     BRA NC, 0xF1A
108:                           if ((mouseX==snake.body[i].x)&&(mouseY==snake.body[i].y)) break;
000F1A  784114     MOV.B [W4], W2
000F1C  FB8302     ZE W2, W6
000F1E  530F88     SUB W6, W8, [W15]
000F20  3A0004     BRA NZ, 0xF2A
000F22  904314     MOV.B [W4+1], W6
000F24  FB8306     ZE W6, W6
000F26  530F81     SUB W6, W1, [W15]
000F28  320004     BRA Z, 0xF32
109:                       }
110:                       if (i==snake.length) collide=0;
000F32  500F85     SUB W0, W5, [W15]
000F34  3AFFE3     BRA NZ, 0xEFC
111:                   }//while
112:                   mouse.x=mouseX;
000F36  780008     MOV W8, W0
000F38  B7FFA2     MOV.B WREG, mouse
113:                   mouse.y=mouseY;
000F3A  780001     MOV W1, W0
000F3C  B7FFA3     MOV.B WREG, 0x1FA3
114:                   set_curpos(mouse.x,mouse.y);
000F3E  FB8081     ZE W1, W1
000F40  FB8008     ZE W8, W0
000F42  07034C     RCALL set_curpos
115:                   put_char(mouse.part);
000F44  BFDFA4     MOV.B 0x1FA4, WREG
000F46  070242     RCALL put_char
116:               }//f()
000F48  78054F     MOV [--W15], W10
000F4A  BE044F     MOV.D [--W15], W8
000F4C  060000     RETURN
117:               
118:               void hide_snake(){
000F4E  BE9F88     MOV.D W8, [W15++]
000F50  781F8A     MOV W10, [W15++]
119:                   unsigned i;
120:                   for (i=0;i<snake.length;i++){
000F52  80F6C4     MOV snake, W4
000F54  520FE0     SUB W4, #0x0, [W15]
000F56  32000F     BRA Z, 0xF76
000F58  21EE38     MOV #0x1EE3, W8
000F5A  EB0480     CLR W9
000F6C  E80489     INC W9, W9
000F6E  440463     ADD W8, #0x3, W8
000F70  80F6C4     MOV snake, W4
000F72  520F89     SUB W4, W9, [W15]
000F74  3EFFF4     BRA GTU, 0xF5E
121:                       set_curpos(snake.body[i].x,snake.body[i].y);
000F5E  784218     MOV.B [W8], W4
000F60  FB8084     ZE W4, W1
000F62  97F878     MOV.B [W8-1], W0
000F64  FB8000     ZE W0, W0
000F66  07033A     RCALL set_curpos
122:                       put_char(SPACE);
000F5C  B3C20A     MOV #0x20, W10
000F68  78400A     MOV.B W10, W0
000F6A  070230     RCALL put_char
123:                   }
124:               }//f()
000F76  78054F     MOV [--W15], W10
000F78  BE044F     MOV.D [--W15], W8
000F7A  060000     RETURN
125:               
126:               void show_snake(){
000F7C  BE9F88     MOV.D W8, [W15++]
127:                   unsigned i;
128:                   for (i=0;i<snake.length;i++){
000F7E  80F6C4     MOV snake, W4
000F80  520FE0     SUB W4, #0x0, [W15]
000F82  32000E     BRA Z, 0xFA0
000F84  21EE38     MOV #0x1EE3, W8
000F86  EB0480     CLR W9
000F96  E80489     INC W9, W9
000F98  440463     ADD W8, #0x3, W8
000F9A  80F6C4     MOV snake, W4
000F9C  520F89     SUB W4, W9, [W15]
000F9E  3EFFF4     BRA GTU, 0xF88
129:                       set_curpos(snake.body[i].x,snake.body[i].y);
000F88  784218     MOV.B [W8], W4
000F8A  FB8084     ZE W4, W1
000F8C  97F878     MOV.B [W8-1], W0
000F8E  FB8000     ZE W0, W0
000F90  070325     RCALL set_curpos
130:                       put_char(snake.body[i].part);
000F92  904018     MOV.B [W8+1], W0
000F94  07021B     RCALL put_char
131:                       
132:                   }//for
133:               }//f()
000FA0  BE044F     MOV.D [--W15], W8
000FA2  060000     RETURN
134:               
135:               
136:               void wait_start_signal(){
000FA4  781F88     MOV W8, [W15++]
137:                   unsigned p;
138:                   p=0;
139:                   print_msg(msgSTART);
000FA6  845160     MOV 0x8A2C, W0
000FA8  845171     MOV 0x8A2E, W1
000FAA  07FF9B     RCALL print_msg
140:                   while (!(p&SNES_START)){
000FB2  600068     AND W0, #0x8, W0
000FB4  32FFFC     BRA Z, 0xFAE
141:                     p=read_paddle(PADDLE1);
000FAC  200018     MOV #0x1, W8
000FAE  780008     MOV W8, W0
000FB0  07062E     RCALL read_paddle
142:                   }
143:               }//f()
000FB6  78044F     MOV [--W15], W8
000FB8  060000     RETURN
144:               
145:               
146:               unsigned char reset=0;
147:               void game_over(){
148:                   print_msg(msgGAME_OVER);
000FBA  845090     MOV 0x8A12, W0
000FBC  8450A1     MOV 0x8A14, W1
000FBE  07FF91     RCALL print_msg
149:                   reset=1;
000FC0  B3C014     MOV #0x1, W4
000FC2  FD0200     EXCH W0, W4
000FC4  B7FFFC     MOV.B WREG, reset
000FC6  FD0200     EXCH W0, W4
150:                   wait_start_signal();
000FC8  07FFED     RCALL wait_start_signal
151:               }//f()
000FCA  060000     RETURN
152:               
153:               void add_calories(unsigned short gain){
154:                   snake.calories+=gain;
000FCC  B43EDA     ADD 0x1EDA
155:                   print_msg(msgCALORIES);
000FCE  844FA0     MOV 0x89F4, W0
000FD0  844FB1     MOV 0x89F6, W1
000FD2  07FF87     RCALL print_msg
156:                   print_int(snake.calories,2);
000FD4  200021     MOV #0x2, W1
000FD6  80F6D0     MOV 0x1EDA, W0
000FD8  0702A9     RCALL print_int
157:               }//f()
000FDA  060000     RETURN
158:               
159:               
160:               void burn_calories(unsigned short lost){
161:                   unsigned newLength;
162:                   snake.calories -= lost;
000FDC  B53EDA     SUB 0x1EDA
163:                   print_msg(msgCALORIES);
000FDE  844FA0     MOV 0x89F4, W0
000FE0  844FB1     MOV 0x89F6, W1
000FE2  07FF7F     RCALL print_msg
164:                   clear_eol();
000FE4  0702DA     RCALL clear_eol
165:                   print_int(snake.calories,2);
000FE6  200021     MOV #0x2, W1
000FE8  80F6D0     MOV 0x1EDA, W0
000FEA  0702A0     RCALL print_int
166:                   print_msg(msgSECONDS);
000FEC  845020     MOV 0x8A04, W0
000FEE  845031     MOV 0x8A06, W1
000FF0  07FF78     RCALL print_msg
167:                   print_int(snake.lifespan,2);
000FF2  200021     MOV #0x2, W1
000FF4  80F6E0     MOV 0x1EDC, W0
000FF6  07029A     RCALL print_int
168:                   if (snake.calories%MOUSE_CALORIES==0){
000FF8  80F6D5     MOV 0x1EDA, W5
000FFA  200144     MOV #0x14, W4
000FFC  BE9F80     MOV.D W0, [W15++]
000FFE  090011     REPEAT #0x11
001000  D88284     DIV.UW W5, W4
001002  780201     MOV W1, W4
001004  BE004F     MOV.D [--W15], W0
001006  520FE0     SUB W4, #0x0, [W15]
001008  3A000F     BRA NZ, 0x1028
169:                       hide_snake();
00100A  07FFA1     RCALL hide_snake
170:                       newLength=snake.calories/MOUSE_CALORIES+1;
00100C  80F6D4     MOV 0x1EDA, W4
001012  200145     MOV #0x14, W5
001014  BE9F80     MOV.D W0, [W15++]
001016  090011     REPEAT #0x11
001018  D88205     DIV.UW W4, W5
00101A  780200     MOV W0, W4
00101C  BE004F     MOV.D [--W15], W0
171:                       if (snake.calories){
00100E  520FE0     SUB W4, #0x0, [W15]
001010  32000A     BRA Z, 0x1026
172:                           snake.length=newLength+1;
00101E  E88204     INC2 W4, W4
001020  88F6C4     MOV W4, snake
173:                           show_snake();
001022  07FFAC     RCALL show_snake
001024  370001     BRA 0x1028
174:                       } else{
175:                           game_over();
001026  07FFC9     RCALL game_over
176:                           return;
177:                       }
178:                   }
179:               }//f()
001028  060000     RETURN
180:               
181:               void check_if_got_mouse(){
182:                   if ((mouse.x==snake.body[0].x) && (mouse.y==snake.body[0].y)){
00102A  21EE24     MOV #0x1EE2, W4
00102C  784214     MOV.B [W4], W4
00102E  21FA25     MOV #0x1FA2, W5
001030  784295     MOV.B [W5], W5
001032  52CF84     SUB.B W5, W4, [W15]
001034  3A006A     BRA NZ, 0x110A
001036  21EE34     MOV #0x1EE3, W4
001038  784214     MOV.B [W4], W4
00103A  21FA35     MOV #0x1FA3, W5
00103C  784295     MOV.B [W5], W5
00103E  52CF84     SUB.B W5, W4, [W15]
001040  3A0064     BRA NZ, 0x110A
183:                       add_calories(MOUSE_CALORIES);
001042  200140     MOV #0x14, W0
001044  07FFC3     RCALL add_calories
184:                       snake.length++;
001046  80F6C4     MOV snake, W4
001048  E80284     INC W4, W5
00104A  88F6C5     MOV W5, snake
185:                       snake.body[snake.length-1].part=RING;
00104C  B92363     MUL.SU W4, #3, W6
00104E  B3C861     MOV #0x86, W1
001050  21EE40     MOV #0x1EE4, W0
001052  7B7001     MOV.B W1, [W0+W6]
186:                       if (snake.dx){
001054  80F6F6     MOV 0x1EDE, W6
001056  530FE0     SUB W6, #0x0, [W15]
001058  32002D     BRA Z, 0x10B4
187:                           if (snake.body[snake.length-2].y==snake.body[0].y){
00105A  E98285     DEC2 W5, W5
00105C  B92863     MUL.SU W5, #3, W0
00105E  21EE27     MOV #0x1EE2, W7
001060  400387     ADD W0, W7, W7
001062  904017     MOV.B [W7+1], W0
001064  21EE37     MOV #0x1EE3, W7
001066  784397     MOV.B [W7], W7
001068  504F87     SUB.B W0, W7, [W15]
00106A  3A000C     BRA NZ, 0x1084
188:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x-snake.dx;
00106C  B92063     MUL.SU W4, #3, W0
00106E  21EE24     MOV #0x1EE2, W4
001070  420200     ADD W4, W0, W4
001072  B92863     MUL.SU W5, #3, W0
001074  4002EA     ADD W0, #0xA, W5
001076  21ED87     MOV #0x1ED8, W7
001078  7AC067     MOV.B [W7+W5], W0
00107A  504A06     SUB.B W0, W6, [W4]
189:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
00107C  438285     ADD W7, W5, W5
00107E  904295     MOV.B [W5+1], W5
001080  984215     MOV.B W5, [W4+1]
001082  370042     BRA 0x1108
190:                           }else{
191:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001084  B92063     MUL.SU W4, #3, W0
001086  B92B63     MUL.SU W5, #3, W6
001088  4302EA     ADD W6, #0xA, W5
00108A  21ED86     MOV #0x1ED8, W6
00108C  4303EA     ADD W6, #0xA, W7
00108E  7AC166     MOV.B [W6+W5], W2
001090  787382     MOV.B W2, [W7+W0]
192:                               if (snake.body[0].y>snake.body[snake.length-2].y){
001092  430285     ADD W6, W5, W5
001094  904295     MOV.B [W5+1], W5
001096  21EE36     MOV #0x1EE3, W6
001098  784316     MOV.B [W6], W6
00109A  534F85     SUB.B W6, W5, [W15]
00109C  360005     BRA LEU, 0x10A8
193:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y-1;
00109E  21EE24     MOV #0x1EE2, W4
0010A0  420200     ADD W4, W0, W4
0010A2  E94285     DEC.B W5, W5
0010A4  984215     MOV.B W5, [W4+1]
0010A6  370030     BRA 0x1108
194:                               }else{
195:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y+1;
0010A8  B92363     MUL.SU W4, #3, W6
0010AA  21EE24     MOV #0x1EE2, W4
0010AC  420206     ADD W4, W6, W4
0010AE  E84285     INC.B W5, W5
0010B0  984215     MOV.B W5, [W4+1]
0010B2  37002A     BRA 0x1108
196:                               }//if
197:                           }//if
198:                       }else {
199:                           if (snake.body[snake.length-2].x==snake.body[0].x){
0010B4  E98285     DEC2 W5, W5
0010B6  B92B63     MUL.SU W5, #3, W6
0010B8  43036A     ADD W6, #0xA, W6
0010BA  21ED87     MOV #0x1ED8, W7
0010BC  7B43E7     MOV.B [W7+W6], W7
0010BE  21EE26     MOV #0x1EE2, W6
0010C0  784316     MOV.B [W6], W6
0010C2  53CF86     SUB.B W7, W6, [W15]
0010C4  3A000C     BRA NZ, 0x10DE
200:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
0010C6  B92063     MUL.SU W4, #3, W0
0010C8  21EE24     MOV #0x1EE2, W4
0010CA  420200     ADD W4, W0, W4
0010CC  784A07     MOV.B W7, [W4]
201:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y-snake.dy;
0010CE  B92863     MUL.SU W5, #3, W0
0010D0  21EE26     MOV #0x1EE2, W6
0010D2  400286     ADD W0, W6, W5
0010D4  904315     MOV.B [W5+1], W6
0010D6  80F705     MOV 0x1EE0, W5
0010D8  534285     SUB.B W6, W5, W5
0010DA  984215     MOV.B W5, [W4+1]
0010DC  370015     BRA 0x1108
202:                           }else{
203:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
0010DE  B92063     MUL.SU W4, #3, W0
0010E0  21EE27     MOV #0x1EE2, W7
0010E2  438000     ADD W7, W0, W0
0010E4  B92963     MUL.SU W5, #3, W2
0010E6  4102EA     ADD W2, #0xA, W5
0010E8  21ED87     MOV #0x1ED8, W7
0010EA  438085     ADD W7, W5, W1
0010EC  904091     MOV.B [W1+1], W1
0010EE  984011     MOV.B W1, [W0+1]
204:                               if (snake.body[0].x>snake.body[snake.length-2].x){
0010F0  7AC2E7     MOV.B [W7+W5], W5
0010F2  534F85     SUB.B W6, W5, [W15]
0010F4  360005     BRA LEU, 0x1100
205:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x-1;
0010F6  B92363     MUL.SU W4, #3, W6
0010F8  21EE24     MOV #0x1EE2, W4
0010FA  420206     ADD W4, W6, W4
0010FC  E94A05     DEC.B W5, [W4]
0010FE  370004     BRA 0x1108
206:                               }else{
207:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x+1;
001100  B92363     MUL.SU W4, #3, W6
001102  21EE24     MOV #0x1EE2, W4
001104  420206     ADD W4, W6, W4
001106  E84A05     INC.B W5, [W4]
208:                               }//if
209:                           }//if
210:               
211:                       }//if
212:                       new_mouse();
001108  07FEF5     RCALL new_mouse
213:                   }
214:               }//f()
00110A  060000     RETURN
215:               
216:               void move_snake(){
001122  B92363     MUL.SU W4, #3, W6
001124  21EE24     MOV #0x1EE2, W4
001126  430204     ADD W6, W4, W4
001128  21EDF5     MOV #0x1EDF, W5
217:                   unsigned i;
218:                   if (!(snake.dx || snake.dy)) return;
00110C  80F6F4     MOV 0x1EDE, W4
00110E  520FE0     SUB W4, #0x0, [W15]
001110  3A0003     BRA NZ, 0x1118
001112  80F704     MOV 0x1EE0, W4
001114  520FE0     SUB W4, #0x0, [W15]
001116  320028     BRA Z, 0x1168
219:                   hide_snake();
001118  07FF1A     RCALL hide_snake
220:                   for (i=snake.length-1;i;i--){
00111A  80F6C4     MOV snake, W4
00111C  520FE1     SUB W4, #0x1, [W15]
00111E  32000C     BRA Z, 0x1138
001134  520F85     SUB W4, W5, [W15]
001136  3AFFF9     BRA NZ, 0x112A
221:                       snake.body[i].x = snake.body[i-1].x;
001120  E98204     DEC2 W4, W4
00112A  784314     MOV.B [W4], W6
00112C  984236     MOV.B W6, [W4+3]
222:                       snake.body[i].y = snake.body[i-1].y;
00112E  904314     MOV.B [W4+1], W6
001130  984246     MOV.B W6, [W4+4]
001132  520263     SUB W4, #0x3, W4
223:                   }
224:                   snake.body[0].x += snake.dx;
001138  80F6F5     MOV 0x1EDE, W5
00113A  21EE24     MOV #0x1EE2, W4
00113C  42C294     ADD.B W5, [W4], W5
00113E  FD0280     EXCH W0, W5
001140  B7FEE2     MOV.B WREG, 0x1EE2
001142  FD0280     EXCH W0, W5
225:                   snake.body[0].y += snake.dy;
001144  80F704     MOV 0x1EE0, W4
001146  21EE36     MOV #0x1EE3, W6
001148  424216     ADD.B W4, [W6], W4
00114A  FD0200     EXCH W0, W4
00114C  B7FEE3     MOV.B WREG, 0x1EE3
00114E  FD0200     EXCH W0, W4
226:                   if ((snake.body[0].x<1)||(snake.body[0].x>=(CHAR_PER_LINE-1)) ||
001150  E94285     DEC.B W5, W5
001152  B3C206     MOV #0x20, W6
001154  52CF86     SUB.B W5, W6, [W15]
001156  3E0004     BRA GTU, 0x1160
001158  524FE0     SUB.B W4, #0x0, [W15]
00115A  320002     BRA Z, 0x1160
227:                       (snake.body[0].y<1) || (snake.body[0].y>=LINE_PER_SCREEN)){
00115C  524FFA     SUB.B W4, #0x1A, [W15]
00115E  360002     BRA LEU, 0x1164
228:                       game_over();
001160  07FF2C     RCALL game_over
001162  370002     BRA 0x1168
229:                   }else{
230:                       check_if_got_mouse();
001164  07FF62     RCALL check_if_got_mouse
231:                       show_snake();
001166  07FF0A     RCALL show_snake
232:                   }//if
233:               }//f()
001168  060000     RETURN
234:               
235:               void present_game(){
236:                   clear_screen();
00116A  0701B4     RCALL clear_screen
237:                   set_curpos(4,0);
00116C  EB0080     CLR W1
00116E  200040     MOV #0x4, W0
001170  070235     RCALL set_curpos
238:                   print("**************");
001172  2893A0     MOV #0x893A, W0
001174  0701B6     RCALL print
239:                   set_curpos(4,1);
001176  200011     MOV #0x1, W1
001178  200040     MOV #0x4, W0
00117A  070230     RCALL set_curpos
240:                   print("* SNAKE GAME *");
00117C  289490     MOV #0x8949, W0
00117E  0701B1     RCALL print
241:                   set_curpos(4,2);
001180  200021     MOV #0x2, W1
001182  200040     MOV #0x4, W0
001184  07022B     RCALL set_curpos
242:                   print("**************");
001186  2893A0     MOV #0x893A, W0
001188  0701AC     RCALL print
243:                   set_curpos(4,3);
00118A  200031     MOV #0x3, W1
00118C  200040     MOV #0x4, W0
00118E  070226     RCALL set_curpos
244:                   print("increase snake lifespan");
001190  289580     MOV #0x8958, W0
001192  0701A7     RCALL print
245:                   set_curpos(4,4);
001194  200041     MOV #0x4, W1
001196  200040     MOV #0x4, W0
001198  070221     RCALL set_curpos
246:                   print("by eating mouses.");
00119A  289700     MOV #0x8970, W0
00119C  0701A2     RCALL print
247:                   set_curpos(4,5);
00119E  200051     MOV #0x5, W1
0011A0  200040     MOV #0x4, W0
0011A2  07021C     RCALL set_curpos
248:                   print("snake burn calories,");
0011A4  289820     MOV #0x8982, W0
0011A6  07019D     RCALL print
249:                   set_curpos(4,6);
0011A8  200061     MOV #0x6, W1
0011AA  200040     MOV #0x4, W0
0011AC  070217     RCALL set_curpos
250:                   print("die when calories down to 0.");
0011AE  289970     MOV #0x8997, W0
0011B0  070198     RCALL print
251:                   set_curpos(4,7);
0011B2  200071     MOV #0x7, W1
0011B4  200040     MOV #0x4, W0
0011B6  070212     RCALL set_curpos
252:                   print("die when hit wall.");
0011B8  289B40     MOV #0x89B4, W0
0011BA  070193     RCALL print
253:                   set_curpos(4,8);
0011BC  200081     MOV #0x8, W1
0011BE  200040     MOV #0x4, W0
0011C0  07020D     RCALL set_curpos
254:                   print("eating a mouse give 20 calories.");
0011C2  289C70     MOV #0x89C7, W0
0011C4  07018E     RCALL print
255:                   wait_start_signal();
0011C6  07FEEE     RCALL wait_start_signal
256:               }//f()
0011C8  060000     RETURN
257:               
258:               void game_init(){
0011CA  BE9F88     MOV.D W8, [W15++]
259:                   reset=0;
0011CC  EF7FFC     CLR.B reset
260:                   srand(time(0));
0011CE  EB0000     CLR W0
0011D0  07F865     RCALL 0x29C
0011D2  07F9DA     RCALL 0x588
261:                   //snake initialisation
262:                   snake.dx=0;
0011D4  EB0400     CLR W8
0011D6  88F6F8     MOV W8, 0x1EDE
263:                   snake.dy=0;
0011D8  88F708     MOV W8, 0x1EE0
264:                   snake.length=2;
0011DA  200029     MOV #0x2, W9
0011DC  88F6C9     MOV W9, snake
265:                   snake.calories=MOUSE_CALORIES;
0011DE  200144     MOV #0x14, W4
0011E0  88F6D4     MOV W4, 0x1EDA
266:                   snake.lifespan=0;
0011E2  88F6E8     MOV W8, 0x1EDC
267:                   snake.body[0].x=12;
0011E4  B3C0C4     MOV #0xC, W4
0011E6  FD0200     EXCH W0, W4
0011E8  B7FEE2     MOV.B WREG, 0x1EE2
0011EA  B7FEE3     MOV.B WREG, 0x1EE3
0011EC  FD0200     EXCH W0, W4
268:                   snake.body[0].y=12;
269:                   snake.body[0].part=HEAD_RIGHT;
0011EE  B3C875     MOV #0x87, W5
0011F0  FD0280     EXCH W0, W5
0011F2  B7FEE4     MOV.B WREG, 0x1EE4
0011F4  FD0280     EXCH W0, W5
270:                   snake.body[1].x=11;
0011F6  B3C0B5     MOV #0xB, W5
0011F8  FD0280     EXCH W0, W5
0011FA  B7FEE5     MOV.B WREG, 0x1EE5
0011FC  FD0280     EXCH W0, W5
271:                   snake.body[1].y=12;
0011FE  FD0200     EXCH W0, W4
001200  B7FEE6     MOV.B WREG, 0x1EE6
001202  FD0200     EXCH W0, W4
272:                   snake.body[1].part=RING;
001204  B3C864     MOV #0x86, W4
001206  FD0200     EXCH W0, W4
001208  B7FEE7     MOV.B WREG, 0x1EE7
00120A  FD0200     EXCH W0, W4
273:                   mouse.part=MOUSE;
00120C  424267     ADD.B W4, #0x7, W4
00120E  FD0200     EXCH W0, W4
001210  B7FFA4     MOV.B WREG, 0x1FA4
001212  FD0200     EXCH W0, W4
274:                   clear_screen();
001214  07015F     RCALL clear_screen
275:                   print_msg(msgCALORIES);
001216  844FA0     MOV 0x89F4, W0
001218  844FB1     MOV 0x89F6, W1
00121A  07FE63     RCALL print_msg
276:                   print_int(snake.calories,2);
00121C  780089     MOV W9, W1
00121E  80F6D0     MOV 0x1EDA, W0
001220  070185     RCALL print_int
277:                   print_msg(msgSECONDS);
001222  845020     MOV 0x8A04, W0
001224  845031     MOV 0x8A06, W1
001226  07FE5D     RCALL print_msg
278:                   print_int(snake.lifespan,2);
001228  780089     MOV W9, W1
00122A  80F6E0     MOV 0x1EDC, W0
00122C  07017F     RCALL print_int
279:                   //draw  borders
280:                   rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
00122E  200014     MOV #0x1, W4
001230  200D73     MOV #0xD7, W3
001232  780103     MOV W3, W2
001234  200081     MOV #0x8, W1
001236  780008     MOV W8, W0
001238  07FC92     RCALL rectangle
281:                   new_mouse();
00123A  07FE5C     RCALL new_mouse
282:                   show_snake();
00123C  07FE9F     RCALL show_snake
283:               }//f()
00123E  BE044F     MOV.D [--W15], W8
001240  060000     RETURN
284:               
285:               
286:               
287:               int main(void) {
001242  BE9F88     MOV.D W8, [W15++]
001244  781F8A     MOV W10, [W15++]
288:                   unsigned p,frame_count;
289:                   PICvision_init();
001246  070527     RCALL PICvision_init
290:                   present_game();
001248  07FF90     RCALL present_game
291:                   game_init();
00124A  07FFBF     RCALL game_init
292:                   frame_count=0;
00124C  EB0400     CLR W8
293:                   while (1){
294:                       wait_n_frame(10);
001252  2000A0     MOV #0xA, W0
001254  070347     RCALL wait_n_frame
295:                       frame_count += 10;
001256  44046A     ADD W8, #0xA, W8
296:                       if (frame_count%frames_per_second==0){
001258  80F654     MOV frames_per_second, W4
00125A  BE9F80     MOV.D W0, [W15++]
00125C  090011     REPEAT #0x11
00125E  D88404     DIV.UW W8, W4
001260  780201     MOV W1, W4
001262  BE004F     MOV.D [--W15], W0
001264  520FE0     SUB W4, #0x0, [W15]
001266  3A0003     BRA NZ, 0x126E
297:                           snake.lifespan +=1;
001268  EC3EDC     INC 0x1EDC
298:                           burn_calories(1);
00126A  200010     MOV #0x1, W0
00126C  07FEB7     RCALL burn_calories
299:                       }
300:                       p=read_paddle(PADDLE1);
00126E  200010     MOV #0x1, W0
001270  0704CE     RCALL read_paddle
301:                       switch (p){
00124E  200209     MOV #0x20, W9
001272  500F89     SUB W0, W9, [W15]
001274  32002A     BRA Z, 0x12CA
001276  3E0003     BRA GTU, 0x127E
001278  500FF0     SUB W0, #0x10, [W15]
00127A  3A0030     BRA NZ, 0x12DC
00127C  37001C     BRA 0x12B6
00127E  200404     MOV #0x40, W4
001280  500F84     SUB W0, W4, [W15]
001282  320004     BRA Z, 0x128C
001284  200804     MOV #0x80, W4
001286  500F84     SUB W0, W4, [W15]
001288  3A0029     BRA NZ, 0x12DC
00128A  37000A     BRA 0x12A0
302:                           case SNES_LEFT:
303:                               if (snake.dx==1){
00128C  80F6F4     MOV 0x1EDE, W4
00128E  520FE1     SUB W4, #0x1, [W15]
001290  320025     BRA Z, 0x12DC
304:                                   break;
305:                               }
306:                               snake.dx =-1;
001292  EFBEDE     SETM 0x1EDE
307:                               snake.dy=0;
001294  EF3EE0     CLR 0x1EE0
308:                               snake.body[0].part=HEAD_LEFT;
001296  B3C884     MOV #0x88, W4
001298  FD0200     EXCH W0, W4
00129A  B7FEE4     MOV.B WREG, 0x1EE4
00129C  FD0200     EXCH W0, W4
309:                               break;
00129E  37001E     BRA 0x12DC
310:                           case SNES_RIGHT:
311:                               if (snake.dx==-1){
0012A0  80F6F4     MOV 0x1EDE, W4
0012A2  420FE1     ADD W4, #0x1, [W15]
0012A4  32001B     BRA Z, 0x12DC
312:                                   break;
313:                               }
314:                               snake.dx=1;
0012A6  200014     MOV #0x1, W4
0012A8  88F6F4     MOV W4, 0x1EDE
315:                               snake.dy=0;
0012AA  EF3EE0     CLR 0x1EE0
316:                               snake.body[0].part=HEAD_RIGHT;
0012AC  B3C874     MOV #0x87, W4
0012AE  FD0200     EXCH W0, W4
0012B0  B7FEE4     MOV.B WREG, 0x1EE4
0012B2  FD0200     EXCH W0, W4
317:                               break;
0012B4  370013     BRA 0x12DC
318:                           case SNES_UP:
319:                               if (snake.dy==1){
0012B6  80F704     MOV 0x1EE0, W4
0012B8  520FE1     SUB W4, #0x1, [W15]
0012BA  320010     BRA Z, 0x12DC
320:                                   break;
321:                               }
322:                               snake.dy=-1;
0012BC  EFBEE0     SETM 0x1EE0
323:                               snake.dx=0;
0012BE  EF3EDE     CLR 0x1EDE
324:                               snake.body[0].part=HEAD_UP;
0012C0  B3C894     MOV #0x89, W4
0012C2  FD0200     EXCH W0, W4
0012C4  B7FEE4     MOV.B WREG, 0x1EE4
0012C6  FD0200     EXCH W0, W4
325:                               break;
0012C8  370009     BRA 0x12DC
326:                           case SNES_DOWN:
327:                               if (snake.dy==-1){
0012CA  80F704     MOV 0x1EE0, W4
0012CC  420FE1     ADD W4, #0x1, [W15]
0012CE  320006     BRA Z, 0x12DC
328:                                   break;
329:                               }
330:                               snake.dy=1;
0012D0  200014     MOV #0x1, W4
0012D2  88F704     MOV W4, 0x1EE0
331:                               snake.dx=0;
0012D4  EF3EDE     CLR 0x1EDE
332:                               snake.body[0].part=HEAD_DOWN;
001250  B3C8AA     MOV #0x8A, W10
0012D6  FD0500     EXCH W0, W10
0012D8  B7FEE4     MOV.B WREG, 0x1EE4
0012DA  FD0500     EXCH W0, W10
333:                               break;
334:               //            default:
335:               //                snake.dx=0;
336:               //                snake.dy=0;
337:               //                break;
338:                       }//switch
339:                       move_snake();
0012DC  07FF17     RCALL move_snake
340:                       if (reset) game_init();
0012DE  21FFC4     MOV #0x1FFC, W4
0012E0  784214     MOV.B [W4], W4
0012E2  524FE0     SUB.B W4, #0x0, [W15]
0012E4  32FFB6     BRA Z, 0x1252
0012E6  07FF71     RCALL game_init
0012E8  37FFB4     BRA 0x1252
341:                   }//while
342:                   return (EXIT_SUCCESS);
343:               }//main()
344:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/hardwareProfile.c  ------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   hardwareProfile.h
21:                 * Author: jacques Deschênes
22:                 * Description:  try to centralize  hardware specific.
23:                 * Created on 1 march 2014
24:                 */
25:                
26:                #include "hardwareProfile.h"
27:                
28:                void HardwareConfig(){
29:                    // peripheral to pin association.
30:                    PPSUnLock;
001B68  803A16     MOV OSCCON, W6
001B6A  B20BF6     AND #0xBF, W6
001B6C  200464     MOV #0x46, W4
001B6E  200575     MOV #0x57, W5
001B70  207427     MOV #0x742, W7
001B72  784B84     MOV.B W4, [W7]
001B74  784B85     MOV.B W5, [W7]
001B76  784B86     MOV.B W6, [W7]
31:                    PPSOutput(PPS_RP5,PPS_SDO1);   // video pixels output
001B78  803626     MOV RPOR2, W6
001B7A  2E0FF7     MOV #0xE0FF, W7
001B7C  630307     AND W6, W7, W6
001B7E  207000     MOV #0x700, W0
001B80  730300     IOR W6, W0, W6
001B82  883626     MOV W6, RPOR2
32:                    PPSOutput(PPS_RP6,PPS_OC4);  // video delay output
001B84  803630     MOV RPOR3, W0
001B86  2FFE06     MOV #0xFFE0, W6
001B88  600006     AND W0, W6, W0
001B8A  B30150     IOR #0x15, W0
001B8C  883630     MOV W0, RPOR3
33:                    PPSOutput(PPS_RP7,PPS_OC1);  // video sync output
001B8E  803630     MOV RPOR3, W0
001B90  600387     AND W0, W7, W7
001B92  212000     MOV #0x1200, W0
001B94  738380     IOR W7, W0, W7
001B96  883637     MOV W7, RPOR3
34:                    PPSOutput(PPS_RP8,PPS_OC2);  // audio output
001B98  803647     MOV RPOR4, W7
001B9A  638306     AND W7, W6, W6
001B9C  B30136     IOR #0x13, W6
001B9E  883646     MOV W6, RPOR4
35:                    PPSLock;
001BA0  803A16     MOV OSCCON, W6
001BA2  A06006     BSET W6, #6
001BA4  207427     MOV #0x742, W7
001BA6  784B84     MOV.B W4, [W7]
001BA8  784B85     MOV.B W5, [W7]
001BAA  784B86     MOV.B W6, [W7]
36:                    // pins data direction
37:                    P_PIXEL_OUT_TRIS=0;     // video pixels output
001BAC  A9A2C8     BCLR TRISB, #5
38:                    P_VDLY_OUT_TRIS=0;     // video delay output
001BAE  A9C2C8     BCLR TRISB, #6
39:                    P_VSYNC_OUT_TRIS=0;     // video sync output
001BB0  A9E2C8     BCLR TRISB, #7
40:                    P_AUDIO_OUT_TRIS=0;     // audio output
001BB2  A902C9     BCLR 0x2C9, #0
41:                    P_NOISE_OUT_TRIS=0;     /// white noise output
001BB4  A942C9     BCLR 0x2C9, #2
42:                    P_PIXDLY_IN_TRIS=1;     //input video pixels delay
001BB6  A822C9     BSET 0x2C9, #1
43:                    P_VIDEO_MODE_TRIS=1;    //input NTSC/PAL select input
001BB8  A882C9     BSET 0x2C9, #4
44:                    VIDMODE_ANDIS=1;   // disable ADC  on NTSC/PAL select input.
001BBA  A8832D     BSET 0x32D, #4
45:                    // paddles interface I/O setting
46:                    P_PDL1_DAT_TRIS=1;      // paddle 1 data as input
001BBC  A802C0     BSET TRISA, #0
47:                    P_PDL2_DAT_TRIS=1;      // paddle 2 data as input
001BBE  A822C0     BSET TRISA, #1
48:                    P_PDL_CLK_TRIS=0;       // paddles clock signal as output
001BC0  A902C8     BCLR TRISB, #0
49:                    P_PDL_LATCH_TRIS=0;     // paddles latch signal as output
001BC2  A922C8     BCLR TRISB, #1
50:                    P_PDL1_ANDIS=1;         // disable analog input
001BC4  A8032C     BSET AD1PCFG, #0
51:                    P_PDL2_ANDIS=1;         // disable analog input
001BC6  A8232C     BSET AD1PCFG, #1
52:                    // interrupts priorities
53:                    VSYNCIP=7;  // timer interrupt used for video output must have highest priority
001BC8  270000     MOV #0x7000, W0
001BCA  B720A6     IOR IPC1
54:                    PIXIP=7;  // change notification interrupt used for video pixels must have highest priority
001BCC  B720AC     IOR IPC4
55:                    AUDIOIP=3; // audio output timer interrupt priority
001BCE  800544     MOV IPC2, W4
001BD0  B30034     IOR #0x3, W4
001BD2  A12004     BCLR W4, #2
001BD4  880544     MOV W4, IPC2
56:                    SYSTICKIP=2; // system ticks timer interrupt priority
001BD6  800524     MOV IPC0, W4
001BD8  A1C004     BCLR W4, #12
001BDA  A0D004     BSET W4, #13
001BDC  A1E004     BCLR W4, #14
001BDE  880524     MOV W4, IPC0
57:                }//f()
001BE0  060000     RETURN
58:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/graphics.c  -------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   graphics.h
21:                 * Author: jacques Deschênes
22:                 * Description: Draw geometrics figures.
23:                 *      coordinates origin is screen top,left, x increase to right, y increase to bottom
24:                 * Created on 28 février 2014, 13:07
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "graphics.h"
29:                
30:                // draw a dot
31:                
32:                void plot(int x, int y, int color){
33:                    int h,ofs;
34:                    if ((y>=VPIXELS)||(x>=HPIXELS)) return; // bound check
000A30  200D74     MOV #0xD7, W4
000A32  508F84     SUB W1, W4, [W15]
000A34  3C0028     BRA GT, 0xA86
000A36  500F84     SUB W0, W4, [W15]
000A38  3C0026     BRA GT, 0xA86
35:                    h= x/8;
000A3A  200084     MOV #0x8, W4
000A3C  781F81     MOV W1, [W15++]
000A3E  090011     REPEAT #0x11
000A40  D80004     DIV.SW W0, W4
000A42  780201     MOV W1, W4
000A44  7800CF     MOV [--W15], W1
36:                    ofs = 7 - x%8;
000A46  1202E7     SUBR W4, #0x7, W5
37:                    if (color==INVERT)
000A48  510FE2     SUB W2, #0x2, [W15]
000A4A  3A0009     BRA NZ, 0xA5E
38:                        video_buffer[y][h] ^= (1<<ofs);
000A4C  208006     MOV #0x800, W6
000A4E  B9097B     MUL.SU W1, #27, W2
000A50  400082     ADD W0, W2, W1
000A52  430381     ADD W6, W1, W7
000A54  200014     MOV #0x1, W4
000A56  DD2285     SL W4, W5, W5
000A58  78C266     MOV.B [W6+W1], W4
000A5A  6A4B85     XOR.B W4, W5, [W7]
000A5C  370014     BRA 0xA86
39:                    else if (color==WHITE)
000A5E  510FE1     SUB W2, #0x1, [W15]
000A60  3A0009     BRA NZ, 0xA74
40:                        video_buffer[y][h]|= (1<<ofs);
000A62  208006     MOV #0x800, W6
000A64  B9097B     MUL.SU W1, #27, W2
000A66  400082     ADD W0, W2, W1
000A68  430381     ADD W6, W1, W7
000A6A  200014     MOV #0x1, W4
000A6C  DD2285     SL W4, W5, W5
000A6E  78C266     MOV.B [W6+W1], W4
000A70  724B85     IOR.B W4, W5, [W7]
000A72  370009     BRA 0xA86
41:                    else
42:                        video_buffer[y][h]&= ~(1<<ofs);
000A74  208006     MOV #0x800, W6
000A76  B9097B     MUL.SU W1, #27, W2
000A78  400082     ADD W0, W2, W1
000A7A  430381     ADD W6, W1, W7
000A7C  200014     MOV #0x1, W4
000A7E  DD2285     SL W4, W5, W5
000A80  EAC285     COM.B W5, W5
000A82  78C366     MOV.B [W6+W1], W6
000A84  62CB86     AND.B W5, W6, [W7]
43:                } // plot()
000A86  060000     RETURN
44:                
45:                // dessine une droite en utilisant l'algorithme de Bresenham
46:                void line(int x1, int y1, int x2, int y2, int color){
000A88  4787EA     ADD W15, #0xA, W15
000A8A  BE9F88     MOV.D W8, [W15++]
000A8C  BE9F8A     MOV.D W10, [W15++]
000A8E  BE9F8C     MOV.D W12, [W15++]
000A90  781F8E     MOV W14, [W15++]
000A92  780400     MOV W0, W8
000A94  780501     MOV W1, W10
000A96  780582     MOV W2, W11
000A98  9FB7F3     MOV W3, [W15-18]
000A9A  780604     MOV W4, W12
000AB0  448408     ADD W9, W8, W8
000AB2  370004     BRA 0xABC
000AC6  540209     SUB W8, W9, W4
000ADC  44850A     ADD W9, W10, W10
000AE8  550209     SUB W10, W9, W4
47:                    int deltax,deltay;
48:                    plot(x1,y1,color);
000A9C  78010C     MOV W12, W2
000A9E  78008A     MOV W10, W1
000AA0  780008     MOV W8, W0
000AA2  07FFC6     RCALL plot
49:                    if (y1==y2){// cas particulier ligne horizontale
000AA4  97B27F     MOV [W15-18], W4
000AA6  550F84     SUB W10, W4, [W15]
000AA8  3A0012     BRA NZ, 0xACE
50:                        deltax= x1<x2?1:-1;
000AAA  540F8B     SUB W8, W11, [W15]
000AAC  3D0003     BRA GE, 0xAB4
000AAE  200019     MOV #0x1, W9
000AB4  EB8480     SETM W9
51:                        while (x1!=x2){
000AB6  540F8B     SUB W8, W11, [W15]
000AB8  3AFFFB     BRA NZ, 0xAB0
000ABA  37004B     BRA 0xB52
000AC8  558F84     SUB W11, W4, [W15]
000ACA  3AFFF8     BRA NZ, 0xABC
000ACC  370042     BRA 0xB52
52:                            x1 += deltax;
53:                            plot(x1,y1,color);
000ABC  78010C     MOV W12, W2
000ABE  78008A     MOV W10, W1
000AC0  780008     MOV W8, W0
000AC2  07FFB6     RCALL plot
000AC4  440409     ADD W8, W9, W8
54:                        }
55:                    }else if (x1==x2){ // cas particulier ligne verticale
000ACE  540F8B     SUB W8, W11, [W15]
000AD0  3A0010     BRA NZ, 0xAF2
56:                        deltay= y1<y2?1:-1;
000AD2  EB8480     SETM W9
000AD4  97B2FF     MOV [W15-18], W5
000AD6  550F85     SUB W10, W5, [W15]
000AD8  3D0001     BRA GE, 0xADC
000ADA  200019     MOV #0x1, W9
57:                        while (y1!=y2){
000AEA  97B2FF     MOV [W15-18], W5
000AEC  528F84     SUB W5, W4, [W15]
000AEE  3AFFF7     BRA NZ, 0xADE
000AF0  370030     BRA 0xB52
58:                            y1+=deltay;
59:                            plot(x1,y1,color);
000ADE  78010C     MOV W12, W2
000AE0  78008A     MOV W10, W1
000AE2  780008     MOV W8, W0
000AE4  07FFA5     RCALL plot
000AE6  450509     ADD W10, W9, W10
60:                        }
61:                    }else{
62:                        int sx,sy,err,e2;
63:                        deltax=abs(x2-x1);
000AF2  558708     SUB W11, W8, W14
000AF4  A7F00E     BTSC W14, #15
000AF6  EA070E     NEG W14, W14
64:                        deltay=abs(y2-y1);
000AF8  97B2FF     MOV [W15-18], W5
000AFA  52820A     SUB W5, W10, W4
000AFC  A7F004     BTSC W4, #15
000AFE  EA0204     NEG W4, W4
000B00  9FBF84     MOV W4, [W15-16]
65:                        sx = x1<x2?1:-1;
000B02  EB8200     SETM W4
000B04  9FB7E4     MOV W4, [W15-20]
000B06  540F8B     SUB W8, W11, [W15]
000B08  3D0002     BRA GE, 0xB0E
000B0A  200015     MOV #0x1, W5
000B0C  9FB7E5     MOV W5, [W15-20]
66:                        sy = y1<y2?1:-1;
000B0E  EB8200     SETM W4
000B10  9FB7D4     MOV W4, [W15-22]
000B12  97B2FF     MOV [W15-18], W5
000B14  550F85     SUB W10, W5, [W15]
000B16  3D0002     BRA GE, 0xB1C
000B18  200014     MOV #0x1, W4
000B1A  9FB7D4     MOV W4, [W15-22]
67:                        err=deltax-deltay;
000B1C  97BA8F     MOV [W15-16], W5
000B1E  570485     SUB W14, W5, W9
68:                        while (!((x1==x2) && (y1==y2))){
000B24  78040B     MOV W11, W8
000B48  540F8B     SUB W8, W11, [W15]
000B4A  3AFFED     BRA NZ, 0xB26
000B4C  97B2FF     MOV [W15-18], W5
000B4E  550F85     SUB W10, W5, [W15]
000B50  3AFFE9     BRA NZ, 0xB24
69:                            e2=err<<1;
000B26  448209     ADD W9, W9, W4
70:                            if (e2>-deltay){
000B20  EA0685     NEG W5, W13
000B22  370001     BRA 0xB26
000B28  520F8D     SUB W4, W13, [W15]
000B2A  340005     BRA LE, 0xB36
71:                               err -= deltay;
000B2C  97BA0F     MOV [W15-16], W4
000B2E  548484     SUB W9, W4, W9
72:                               x1 += sx;
000B30  97B2EF     MOV [W15-20], W5
000B32  440405     ADD W8, W5, W8
000B34  370005     BRA 0xB40
73:                            }else if (e2<deltax){
000B36  570F84     SUB W14, W4, [W15]
000B38  340003     BRA LE, 0xB40
74:                                err +=deltax;
000B3A  44848E     ADD W9, W14, W9
75:                                y1 += sy;
000B3C  97B25F     MOV [W15-22], W4
000B3E  450504     ADD W10, W4, W10
76:                            }
77:                            plot(x1,y1,color);
000B40  78010C     MOV W12, W2
000B42  78008A     MOV W10, W1
000B44  780008     MOV W8, W0
000B46  07FF74     RCALL plot
78:                        }
79:                    }
80:                } // line()
000B52  78074F     MOV [--W15], W14
000B54  BE064F     MOV.D [--W15], W12
000B56  BE054F     MOV.D [--W15], W10
000B58  BE044F     MOV.D [--W15], W8
000B5A  B100AF     SUB #0xA, W15
000B5C  060000     RETURN
81:                
82:                void rectangle(int x1, int y1, int x2, int y2, int color){
000B5E  BE9F88     MOV.D W8, [W15++]
000B60  BE9F8A     MOV.D W10, [W15++]
000B62  781F8C     MOV W12, [W15++]
000B64  780480     MOV W0, W9
000B66  780401     MOV W1, W8
000B68  780502     MOV W2, W10
000B6A  780603     MOV W3, W12
000B6C  780584     MOV W4, W11
83:                    line(x1,y1,x1,y2,color);
000B6E  780109     MOV W9, W2
000B70  780088     MOV W8, W1
000B72  780009     MOV W9, W0
000B74  07FF89     RCALL line
84:                    line(x2,y1,x2,y2,color);
000B76  78020B     MOV W11, W4
000B78  78018C     MOV W12, W3
000B7A  78010A     MOV W10, W2
000B7C  780088     MOV W8, W1
000B7E  78000A     MOV W10, W0
000B80  07FF83     RCALL line
85:                    line(x1,y1,x2,y1,color);
000B82  78020B     MOV W11, W4
000B84  780188     MOV W8, W3
000B86  78010A     MOV W10, W2
000B88  780088     MOV W8, W1
000B8A  780009     MOV W9, W0
000B8C  07FF7D     RCALL line
86:                    line(x1,y2,x2,y2,color);
000B8E  78020B     MOV W11, W4
000B90  78018C     MOV W12, W3
000B92  78010A     MOV W10, W2
000B94  78008C     MOV W12, W1
000B96  780009     MOV W9, W0
000B98  07FF77     RCALL line
87:                }//rectangle()
000B9A  78064F     MOV [--W15], W12
000B9C  BE054F     MOV.D [--W15], W10
000B9E  BE044F     MOV.D [--W15], W8
000BA0  060000     RETURN
88:                
89:                /*  algorthme mid-point
90:                 * REF: http://www.hhhprogram.com/2013/05/draw-elipse-midpoint-elipse-algorithm.html
91:                 */
92:                void ellipse (int xc, int yc, long rx, long ry, int color){
000BA2  B0036F     ADD #0x36, W15
000BA4  BE9F88     MOV.D W8, [W15++]
000BA6  BE9F8A     MOV.D W10, [W15++]
000BA8  BE9F8C     MOV.D W12, [W15++]
000BAA  781F8E     MOV W14, [W15++]
000BAC  9FAF90     MOV W0, [W15-46]
000BAE  9FAFE1     MOV W1, [W15-36]
000BB0  BE0504     MOV.D W4, W10
000BB2  780706     MOV W6, W14
000C2E  9FA7F2     MOV W2, [W15-50]
000C30  9FAF83     MOV W3, [W15-48]
000C3C  97AA9F     MOV [W15-46], W5
000C3E  E90285     DEC W5, W5
000C40  9FA7C5     MOV W5, [W15-56]
000C42  97AB1F     MOV [W15-46], W6
000C44  E80306     INC W6, W6
000C46  9FA7B6     MOV W6, [W15-58]
000C48  9F9FFA     MOV W10, [W15-66]
000C4A  9FA78B     MOV W11, [W15-64]
000C54  97B47F     MOV [W15-18], W8
000C56  97A0CF     MOV [W15-56], W1
000C58  408088     ADD W1, W8, W1
000C5A  9FB791     MOV W1, [W15-30]
000C68  97A1BF     MOV [W15-58], W3
000C6A  518408     SUB W3, W8, W8
000C94  97A07F     MOV [W15-50], W0
000C96  97A88F     MOV [W15-48], W1
000C98  40030C     ADD W0, W12, W6
000C9A  48838D     ADDC W1, W13, W7
000CCA  97A47F     MOV [W15-50], W8
000CCC  97AC8F     MOV [W15-48], W9
000CCE  44030C     ADD W8, W12, W6
000CD0  4C838D     ADDC W9, W13, W7
000CEE  97B37F     MOV [W15-18], W6
000CF0  97BB8F     MOV [W15-16], W7
000CF2  530061     SUB W6, #0x1, W0
000CF4  5B80E0     SUBB W7, #0x0, W1
000D9E  97AA4F     MOV [W15-40], W4
000DA0  97AADF     MOV [W15-38], W5
000DA2  120260     SUBR W4, #0x0, W4
000DA4  1A82E0     SUBBR W5, #0x0, W5
000DA6  9FB794     MOV W4, [W15-30]
000DA8  9FB7A5     MOV W5, [W15-28]
000DAA  97AADF     MOV [W15-38], W5
000DAC  97B47F     MOV [W15-18], W8
000DAE  B9AB08     MUL.SS W5, W8, W6
000DB0  97BC8F     MOV [W15-16], W9
000DB2  97A84F     MOV [W15-40], W0
000DB4  B9CA00     MUL.SS W9, W0, W4
000DB6  420206     ADD W4, W6, W4
000DB8  97A9CF     MOV [W15-40], W3
000DBA  97B15F     MOV [W15-22], W2
000DBC  B81902     MUL.UU W3, W2, W2
000DBE  9FB7B2     MOV W2, [W15-26]
000DC0  9FB7C3     MOV W3, [W15-24]
000DC2  420183     ADD W4, W3, W3
000DC4  9FB7C3     MOV W3, [W15-24]
000DC6  97B23F     MOV [W15-26], W4
000DC8  97B2CF     MOV [W15-24], W5
000DCA  9FB7D4     MOV W4, [W15-22]
000DCC  9FB7E5     MOV W5, [W15-20]
000DD6  97ABEF     MOV [W15-36], W7
000DD8  53858C     SUB W7, W12, W11
000DE6  97A8EF     MOV [W15-36], W1
000DE8  40848C     ADD W1, W12, W9
000E0E  560261     SUB W12, #0x1, W4
000E10  5E82E0     SUBB W13, #0x0, W5
000E2C  560261     SUB W12, #0x1, W4
000E2E  5E82E0     SUBB W13, #0x0, W5
93:                          long  x=0,y=ry;
94:                          long  p=(ry*ry)-(rx*rx*ry)+((rx*rx)/4);
000BB4  B99A02     MUL.SS W3, W2, W4
000BB6  420204     ADD W4, W4, W4
000BB8  B81002     MUL.UU W2, W2, W0
000BBA  9FAFA0     MOV W0, [W15-44]
000BBC  9FAFB1     MOV W1, [W15-42]
000BBE  420081     ADD W4, W1, W1
000BC0  9FAFB1     MOV W1, [W15-42]
000BC2  97A92F     MOV [W15-44], W2
000BC4  97A9BF     MOV [W15-42], W3
000BC6  550202     SUB W10, W2, W4
000BC8  5D8283     SUBB W11, W3, W5
000BCA  B9AB0A     MUL.SS W5, W10, W6
000BCC  B9D804     MUL.SS W11, W4, W0
000BCE  400306     ADD W0, W6, W6
000BD0  B8220A     MUL.UU W4, W10, W4
000BD2  430285     ADD W6, W5, W5
000BD4  BE0302     MOV.D W2, W6
000BD6  510FE0     SUB W2, #0x0, [W15]
000BD8  598FE0     SUBB W3, #0x0, [W15]
000BDA  3D0002     BRA GE, 0xBE0
000BDC  410363     ADD W2, #0x3, W6
000BDE  4983E0     ADDC W3, #0x0, W7
000BE0  DD39CE     SL W7, #14, W3
000BE2  DE3342     LSR W6, #2, W6
000BE4  718306     IOR W3, W6, W6
000BE6  DEBBC2     ASR W7, #2, W7
000BE8  430404     ADD W6, W4, W8
000BEA  4B8485     ADDC W7, W5, W9
000BEC  9FB7B8     MOV W8, [W15-26]
000BEE  9FB7C9     MOV W9, [W15-24]
95:                          while((2*x*ry*ry)<(2*y*rx*rx)){
000BF0  B9DA0A     MUL.SS W11, W10, W4
000BF2  420204     ADD W4, W4, W4
000BF4  B8500A     MUL.UU W10, W10, W0
000BF6  9FA7D0     MOV W0, [W15-54]
000BF8  9FA7E1     MOV W1, [W15-52]
000BFA  420081     ADD W4, W1, W1
000BFC  9FA7E1     MOV W1, [W15-52]
000BFE  97A15F     MOV [W15-54], W2
000C00  97A1EF     MOV [W15-52], W3
000C02  410102     ADD W2, W2, W2
000C04  498183     ADDC W3, W3, W3
000C06  9FA792     MOV W2, [W15-62]
000C08  9FA7A3     MOV W3, [W15-60]
000C0A  97AA2F     MOV [W15-44], W4
000C0C  97AABF     MOV [W15-42], W5
000C0E  420204     ADD W4, W4, W4
000C10  4A8285     ADDC W5, W5, W5
000C12  9FB7D4     MOV W4, [W15-22]
000C14  9FB7E5     MOV W5, [W15-20]
000C32  200014     MOV #0x1, W4
000C34  200005     MOV #0x0, W5
000C36  9FB7F4     MOV W4, [W15-18]
000C38  9FBF85     MOV W5, [W15-16]
000C3A  B86660     MUL.UU W12, #0, W12
000C4C  370050     BRA 0xCEE
000CF6  97B3DF     MOV [W15-22], W7
000CF8  B9DA07     MUL.SS W11, W7, W4
000CFA  97B46F     MOV [W15-20], W8
000CFC  B9C30A     MUL.SS W8, W10, W6
000CFE  430304     ADD W6, W4, W6
000D00  97B4DF     MOV [W15-22], W9
000D02  B85209     MUL.UU W10, W9, W4
000D04  430285     ADD W6, W5, W5
000D06  520F8C     SUB W4, W12, [W15]
000D08  5A8F8D     SUBB W5, W13, [W15]
000D0A  3CFFA1     BRA GT, 0xC4E
000D0C  BE010A     MOV.D W10, W2
000D0E  9FB79A     MOV W10, [W15-30]
000D10  9FB7AB     MOV W11, [W15-28]
000D12  9FAFF0     MOV W0, [W15-34]
000D14  9FB781     MOV W1, [W15-32]
000D16  979D7F     MOV [W15-66], W10
000D18  97A58F     MOV [W15-64], W11
000D1A  BE0600     MOV.D W0, W12
96:                               plot(xc+x,yc-y,color);
000C4E  97A86F     MOV [W15-36], W0
000C50  50000A     SUB W0, W10, W0
000C52  9FAFF0     MOV W0, [W15-34]
000C5C  78010E     MOV W14, W2
000C5E  780080     MOV W0, W1
000C60  97B01F     MOV [W15-30], W0
000C62  07FEE6     RCALL plot
97:                               plot(xc-x,yc+y,color);
000C64  97A96F     MOV [W15-36], W2
000C66  450482     ADD W10, W2, W9
000C6C  78010E     MOV W14, W2
000C6E  BE0008     MOV.D W8, W0
000C70  07FEDF     RCALL plot
98:                               plot(xc+x,yc+y,color);
000C72  78010E     MOV W14, W2
000C74  780089     MOV W9, W1
000C76  97B01F     MOV [W15-30], W0
000C78  07FEDB     RCALL plot
99:                               plot(xc-x,yc-y,color);
000C7A  78010E     MOV W14, W2
000C7C  97A8FF     MOV [W15-34], W1
000C7E  780008     MOV W8, W0
000C80  07FED7     RCALL plot
100:                              if(p<0){
000C82  97B23F     MOV [W15-26], W4
000C84  97B2CF     MOV [W15-24], W5
000C86  520FE0     SUB W4, #0x0, [W15]
000C88  5A8FE0     SUBB W5, #0x0, [W15]
000C8A  3D000D     BRA GE, 0xCA6
101:                                  x=x+1;
102:                                  p=p+(2*ry*ry*x)+(ry*ry);
000C8C  97A45F     MOV [W15-54], W8
000C8E  97A4EF     MOV [W15-52], W9
000C90  440204     ADD W8, W4, W4
000C92  4C8285     ADDC W9, W5, W5
000C9C  420106     ADD W4, W6, W2
000C9E  4A8187     ADDC W5, W7, W3
000CA0  9FB7B2     MOV W2, [W15-26]
000CA2  9FB7C3     MOV W3, [W15-24]
000CA4  37001A     BRA 0xCDA
103:                              }else {
104:                                  x=x+1;
105:                                  y=y-1;
000CA6  550561     SUB W10, #0x1, W10
000CA8  5D85E0     SUBB W11, #0x0, W11
106:                                  p=p+(2*ry*ry*x+ry*ry)-(2*rx*rx*y);
000C16  2FFFE4     MOV #0xFFFE, W4
000C18  97AB3F     MOV [W15-42], W6
000C1A  B9B204     MUL.SS W6, W4, W4
000C1C  97ABAF     MOV [W15-44], W7
000C1E  520207     SUB W4, W7, W4
000C20  2FFFE5     MOV #0xFFFE, W5
000C22  97ACAF     MOV [W15-44], W9
000C24  B84C05     MUL.UU W9, W5, W8
000C26  9FAFC8     MOV W8, [W15-40]
000C28  9FAFD9     MOV W9, [W15-38]
000C2A  420489     ADD W4, W9, W9
000C2C  9FAFD9     MOV W9, [W15-38]
000CAA  97B23F     MOV [W15-26], W4
000CAC  97B2CF     MOV [W15-24], W5
000CAE  97A45F     MOV [W15-54], W8
000CB0  97A4EF     MOV [W15-52], W9
000CB2  440304     ADD W8, W4, W6
000CB4  4C8385     ADDC W9, W5, W7
000CB6  97ACCF     MOV [W15-40], W9
000CB8  B9DA09     MUL.SS W11, W9, W4
000CBA  97A95F     MOV [W15-38], W2
000CBC  B9900A     MUL.SS W2, W10, W0
000CBE  400004     ADD W0, W4, W0
000CC0  97A9CF     MOV [W15-40], W3
000CC2  B85203     MUL.UU W10, W3, W4
000CC4  400285     ADD W0, W5, W5
000CC6  420206     ADD W4, W6, W4
000CC8  4A8287     ADDC W5, W7, W5
000CD2  420006     ADD W4, W6, W0
000CD4  4A8087     ADDC W5, W7, W1
000CD6  9FB7B0     MOV W0, [W15-26]
000CD8  9FB7C1     MOV W1, [W15-24]
000CDA  97A17F     MOV [W15-50], W2
000CDC  97A98F     MOV [W15-48], W3
000CDE  41060C     ADD W2, W12, W12
000CE0  49868D     ADDC W3, W13, W13
000CE2  97B27F     MOV [W15-18], W4
000CE4  97BA8F     MOV [W15-16], W5
000CE6  420261     ADD W4, #0x1, W4
000CE8  4A82E0     ADDC W5, #0x0, W5
000CEA  9FB7F4     MOV W4, [W15-18]
000CEC  9FBF85     MOV W5, [W15-16]
107:                              }
108:                         }
109:                         p=((float)x+0.5)*((float)x+0.5)*ry*ry+(y-1)*(y-1)*rx*rx-rx*rx*ry*ry;
000D22  BE000A     MOV.D W10, W0
000D24  07FB47     RCALL 0x3B4
000D26  BE0400     MOV.D W0, W8
000D28  97B31F     MOV [W15-30], W6
000D2A  97B3AF     MOV [W15-28], W7
000D2C  530361     SUB W6, #0x1, W6
000D2E  5B83E0     SUBB W7, #0x0, W7
000D30  9FB7F6     MOV W6, [W15-18]
000D32  9FBF87     MOV W7, [W15-16]
000D34  BE000C     MOV.D W12, W0
000D36  07FB3E     RCALL 0x3B4
000D38  200002     MOV #0x0, W2
000D3A  23F003     MOV #0x3F00, W3
000D3C  07FABD     RCALL 0x2B8
000D3E  BE0100     MOV.D W0, W2
000D40  07FB8F     RCALL 0x460
000D42  BE0108     MOV.D W8, W2
000D44  07FB8D     RCALL 0x460
000D46  BE0100     MOV.D W0, W2
000D48  BE0008     MOV.D W8, W0
000D4A  07FB8A     RCALL 0x460
000D4C  BE0400     MOV.D W0, W8
000D4E  97BB8F     MOV [W15-16], W7
000D50  97B07F     MOV [W15-18], W0
000D52  B9BA00     MUL.SS W7, W0, W4
000D54  420204     ADD W4, W4, W4
000D56  97B0FF     MOV [W15-18], W1
000D58  9FB7D1     MOV W1, [W15-22]
000D5A  780101     MOV W1, W2
000D5C  B81002     MUL.UU W2, W2, W0
000D5E  420081     ADD W4, W1, W1
000D60  97A9AF     MOV [W15-44], W3
000D62  B98B03     MUL.SS W1, W3, W6
000D64  97A93F     MOV [W15-42], W2
000D66  B99200     MUL.SS W2, W0, W4
000D68  420206     ADD W4, W6, W4
000D6A  97AD2F     MOV [W15-44], W10
000D6C  B8000A     MUL.UU W0, W10, W0
000D6E  420081     ADD W4, W1, W1
000D70  07FB21     RCALL 0x3B4
000D72  BE0100     MOV.D W0, W2
000D74  BE0008     MOV.D W8, W0
000D76  07FAA0     RCALL 0x2B8
000D78  BE0400     MOV.D W0, W8
000D7A  97A9BF     MOV [W15-42], W3
000D7C  97A25F     MOV [W15-54], W4
000D7E  B99B04     MUL.SS W3, W4, W6
000D80  97A06F     MOV [W15-52], W0
000D82  97A8AF     MOV [W15-44], W1
000D84  B98201     MUL.SS W0, W1, W4
000D86  420206     ADD W4, W6, W4
000D88  97A15F     MOV [W15-54], W2
000D8A  B85002     MUL.UU W10, W2, W0
000D8C  420081     ADD W4, W1, W1
000D8E  07FB12     RCALL 0x3B4
000D90  BE0100     MOV.D W0, W2
000D92  BE0008     MOV.D W8, W0
000D94  07FA90     RCALL 0x2B6
000D96  07FAED     RCALL 0x372
000D98  BE0500     MOV.D W0, W10
000D9A  97B61F     MOV [W15-30], W12
000D9C  97B6AF     MOV [W15-28], W13
110:                         while(y>=0){
000D1C  510FE0     SUB W2, #0x0, [W15]
000D1E  598FE0     SUBB W3, #0x0, [W15]
000D20  3500B8     BRA LT, 0xE92
000E8C  520FE0     SUB W4, #0x0, [W15]
000E8E  5A8FE0     SUBB W5, #0x0, [W15]
000E90  3DFFA2     BRA GE, 0xDD6
111:                              plot(xc+x,yc-y,color);
000DDA  97AC7F     MOV [W15-34], W8
000DDC  97A81F     MOV [W15-46], W0
000DDE  440500     ADD W8, W0, W10
000DE0  78010E     MOV W14, W2
000DE2  BE000A     MOV.D W10, W0
000DE4  07FE25     RCALL plot
112:                              plot(xc-x,yc+y,color);
000DEA  97A91F     MOV [W15-46], W2
000DEC  510408     SUB W2, W8, W8
000DEE  78010E     MOV W14, W2
000DF0  BE0008     MOV.D W8, W0
000DF2  07FE1E     RCALL plot
113:                              plot(xc+x,yc+y,color);
000DF4  78010E     MOV W14, W2
000DF6  780089     MOV W9, W1
000DF8  78000A     MOV W10, W0
000DFA  07FE1A     RCALL plot
114:                              plot(xc-x,yc-y,color);
000DFC  78010E     MOV W14, W2
000DFE  78008B     MOV W11, W1
000E00  780008     MOV W8, W0
000E02  07FE16     RCALL plot
115:                              if(p>0){
000E04  97B27F     MOV [W15-18], W4
000E06  97BA8F     MOV [W15-16], W5
000E08  520FE0     SUB W4, #0x0, [W15]
000E0A  5A8FE0     SUBB W5, #0x0, [W15]
000E0C  34000F     BRA LE, 0xE2C
116:                                  y=y-1;
117:                                  p=p-(2*rx*rx*y)+(rx*rx);
000E12  97B47F     MOV [W15-18], W8
000E14  97BC8F     MOV [W15-16], W9
000E16  97A82F     MOV [W15-44], W0
000E18  97A8BF     MOV [W15-42], W1
000E1A  400308     ADD W0, W8, W6
000E1C  488389     ADDC W1, W9, W7
000E1E  97B15F     MOV [W15-22], W2
000E20  97B1EF     MOV [W15-20], W3
000E22  430102     ADD W6, W2, W2
000E24  4B8183     ADDC W7, W3, W3
000E26  9FB7F2     MOV W2, [W15-18]
000E28  9FBF83     MOV W3, [W15-16]
000E2A  370020     BRA 0xE6C
118:                              }else{
119:                                  y=y-1;
120:                                  x=x+1;
000E30  97AB7F     MOV [W15-34], W6
000E32  97B38F     MOV [W15-32], W7
000E34  430361     ADD W6, #0x1, W6
000E36  4B83E0     ADDC W7, #0x0, W7
000E38  9FAFF6     MOV W6, [W15-34]
000E3A  9FB787     MOV W7, [W15-32]
121:                                  p=p+(2*ry*ry*x)-(2*rx*rx*y)-(rx*rx);
000DCE  97A29F     MOV [W15-62], W5
000DD0  9FAFC5     MOV W5, [W15-40]
000DD2  9FB7FA     MOV W10, [W15-18]
000DD4  9FBF8B     MOV W11, [W15-16]
000E3C  97B47F     MOV [W15-18], W8
000E3E  97BC8F     MOV [W15-16], W9
000E40  97A82F     MOV [W15-44], W0
000E42  97A8BF     MOV [W15-42], W1
000E44  540100     SUB W8, W0, W2
000E46  5C8181     SUBB W9, W1, W3
000E48  97A3AF     MOV [W15-60], W7
000E4A  B9B806     MUL.SS W7, W6, W0
000E4C  97B40F     MOV [W15-32], W8
000E4E  97A49F     MOV [W15-62], W9
000E50  B9C309     MUL.SS W8, W9, W6
000E52  430000     ADD W6, W0, W0
000E54  97A8CF     MOV [W15-40], W1
000E56  97AC7F     MOV [W15-34], W8
000E58  B80B08     MUL.UU W1, W8, W6
000E5A  400387     ADD W0, W7, W7
000E5C  430302     ADD W6, W2, W6
000E5E  4B8383     ADDC W7, W3, W7
000E60  97B03F     MOV [W15-26], W0
000E62  97B0CF     MOV [W15-24], W1
000E64  430000     ADD W6, W0, W0
000E66  4B8081     ADDC W7, W1, W1
000E68  9FB7F0     MOV W0, [W15-18]
000E6A  9FBF81     MOV W1, [W15-16]
000E6C  560661     SUB W12, #0x1, W12
000E6E  5E86E0     SUBB W13, #0x0, W13
000E70  97B15F     MOV [W15-22], W2
000E72  97B1EF     MOV [W15-20], W3
000E74  97B31F     MOV [W15-30], W6
000E76  97B3AF     MOV [W15-28], W7
000E78  430102     ADD W6, W2, W2
000E7A  4B8183     ADDC W7, W3, W3
000E7C  9FB7D2     MOV W2, [W15-22]
000E7E  9FB7E3     MOV W3, [W15-20]
000E80  97B43F     MOV [W15-26], W8
000E82  97B4CF     MOV [W15-24], W9
000E84  430408     ADD W6, W8, W8
000E86  4B8489     ADDC W7, W9, W9
000E88  9FB7B8     MOV W8, [W15-26]
000E8A  9FB7C9     MOV W9, [W15-24]
122:                              }
123:                         }
124:               }//ellipse()
000E92  78074F     MOV [--W15], W14
000E94  BE064F     MOV.D [--W15], W12
000E96  BE054F     MOV.D [--W15], W10
000E98  BE044F     MOV.D [--W15], W8
000E9A  B1036F     SUB #0x36, W15
000E9C  060000     RETURN
125:               
126:               /*
127:                * points[]={x1,y1,x2,y2,x3,y3,...}
128:                * vertices est le nombre de points
129:                */
130:               void polygon(int points[], int vertices, int color){
000E9E  BE9F88     MOV.D W8, [W15++]
000EA0  BE9F8A     MOV.D W10, [W15++]
000EA2  781F8C     MOV W12, [W15++]
000EA4  780600     MOV W0, W12
000EA6  780582     MOV W2, W11
131:                   int i;
132:                   for(i=0;i<(2*vertices-2);i+=2){
000EA8  E90501     DEC W1, W10
000EAA  45050A     ADD W10, W10, W10
000EAC  EB0480     CLR W9
000EAE  550F89     SUB W10, W9, [W15]
000EB0  34000B     BRA LE, 0xEC8
000EB2  78040C     MOV W12, W8
000EC0  E88489     INC2 W9, W9
000EC2  440464     ADD W8, #0x4, W8
000EC4  550F89     SUB W10, W9, [W15]
000EC6  3CFFF6     BRA GT, 0xEB4
133:                       line(points[i],points[i+1],points[i+2],points[i+3],color);
000EB4  900128     MOV [W8+4], W2
000EB6  900098     MOV [W8+2], W1
000EB8  78020B     MOV W11, W4
000EBA  9001B8     MOV [W8+6], W3
000EBC  780018     MOV [W8], W0
000EBE  07FDE4     RCALL line
134:                   }
135:                   line(points[0],points[1],points[i],points[i+1],color);
000EC8  E80289     INC W9, W5
000ECA  428285     ADD W5, W5, W5
000ECC  448489     ADD W9, W9, W9
000ECE  90009C     MOV [W12+2], W1
000ED0  78020B     MOV W11, W4
000ED2  7A81EC     MOV [W12+W5], W3
000ED4  7C816C     MOV [W12+W9], W2
000ED6  78001C     MOV [W12], W0
000ED8  07FDD7     RCALL line
136:               }//polygon()
000EDA  78064F     MOV [--W15], W12
000EDC  BE054F     MOV.D [--W15], W10
000EDE  BE044F     MOV.D [--W15], W8
000EE0  060000     RETURN
137:               
138:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NTSC_FRAMES_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE+40)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAMES_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE+45)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8 // flag screen in retrace phase
60:                
61:                unsigned frames_per_second;
62:                static unsigned int frame_line_cntr=0; // count line in video frame
63:                volatile static unsigned long frame_cntr=0; // number of frame since reset
64:                volatile static unsigned int flags;
65:                
66:                
67:                char video_buffer[VPIXELS][BYTES_PER_LINE];
68:                int vsync, hsync, video_mode;
69:                
70:                void ntsc_init(){
71:                    VIDPR = NTSC_LINE_PERIOD;  // video timer PRx SFR
001868  203F85     MOV #0x3F8, W5
00186A  880865     MOV W5, PR2
72:                    VSYNCR= NTSC_HPULSE;       // video OCxR  SFR
00186C  2004B4     MOV #0x4B, W4
00186E  880C14     MOV W4, OC1R
73:                    VSYNCRS=NTSC_LINE_PERIOD;  // video OCxRS SFR
001870  880C05     MOV W5, OC1RS
74:                    VDLYR=NTSC_VIDEO_DELAY;     // video delay OCxR SFR
001872  200BE5     MOV #0xBE, W5
001874  880CA5     MOV W5, OC4R
75:                    VDLYRS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;  // video delay OCxRS SFR
001876  203E05     MOV #0x3E0, W5
001878  880C95     MOV W5, OC4RS
76:                    hsync=NTSC_HPULSE;
00187A  88F674     MOV W4, hsync
77:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
00187C  203AC4     MOV #0x3AC, W4
00187E  88F664     MOV W4, vsync
78:                    video_mode=NTSC_MODE;
001880  EF3EC8     CLR video_mode
79:                    frames_per_second=NTSC_FRAMES_PER_SECOND;
001882  2003C4     MOV #0x3C, W4
001884  88F654     MOV W4, frames_per_second
80:                }//f()
001886  060000     RETURN
81:                
82:                void pal_init(){
83:                    VIDPR = PAL_LINE_PERIOD;
001888  204005     MOV #0x400, W5
00188A  880865     MOV W5, PR2
84:                    VSYNCR= PAL_HPULSE;
00188C  2004B4     MOV #0x4B, W4
00188E  880C14     MOV W4, OC1R
85:                    VSYNCRS=PAL_LINE_PERIOD;
001890  880C05     MOV W5, OC1RS
86:                    VDLYR=PAL_VIDEO_DELAY;
001892  200C35     MOV #0xC3, W5
001894  880CA5     MOV W5, OC4R
87:                    VDLYRS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
001896  203E65     MOV #0x3E6, W5
001898  880C95     MOV W5, OC4RS
88:                    hsync=PAL_HPULSE;
00189A  88F674     MOV W4, hsync
89:                    vsync=PAL_LINE_PERIOD-PAL_HPULSE;
00189C  203B44     MOV #0x3B4, W4
00189E  88F664     MOV W4, vsync
90:                    video_mode=PAL_MODE;
0018A0  200014     MOV #0x1, W4
0018A2  88F644     MOV W4, video_mode
91:                    frames_per_second=PAL_FRAMES_PER_SECOND;
0018A4  200324     MOV #0x32, W4
0018A6  88F654     MOV W4, frames_per_second
92:                }//f()
0018A8  060000     RETURN
93:                
94:                void  video_init(){ // initialisation sorties NTSC
95:                    VIDTMR.TON=0; // désactivation TIMER2
0018AA  A9E111     BCLR 0x111, #7
96:                    if (P_VIDEO_MODE){
0018AC  801655     MOV PORTB, W5
0018AE  210004     MOV #0x1000, W4
0018B0  628204     AND W5, W4, W4
0018B2  320002     BRA Z, 0x18B8
97:                        ntsc_init();
0018B4  07FFD9     RCALL ntsc_init
0018B6  370001     BRA 0x18BA
98:                    }else{
99:                        pal_init();
0018B8  07FFE7     RCALL pal_init
100:                   }
101:                   //  video sync OC mode
102:                   VSYNCCON.OCM=5; // mode 5, timer 2
0018BA  800C24     MOV OC1CON, W4
0018BC  A00004     BSET W4, #0
0018BE  A11004     BCLR W4, #1
0018C0  A02004     BSET W4, #2
0018C2  880C24     MOV W4, OC1CON
103:                   //video delay change notification interrupt enable on that pin.
104:                   PIXIE=1;
0018C4  A8A062     BSET CNEN2, #5
105:                   // video sync interrupt enabling
106:                   VSYNCIF=0;
0018C6  A9E084     BCLR IFS0, #7
107:                   VSYNCIE=1;
0018C8  A8E094     BSET IEC0, #7
108:                   // SPIx configuration (pixels output)
109:                   PIXCON1.DISSCK=1;
0018CA  A88243     BSET 0x243, #4
110:                   PIXCON1.MSTEN=1;
0018CC  A8A242     BSET SPI1CON1, #5
111:                   PIXCON1.SPRE=5;
0018CE  801214     MOV SPI1CON1, W4
0018D0  A02004     BSET W4, #2
0018D2  A13004     BCLR W4, #3
0018D4  A04004     BSET W4, #4
0018D6  881214     MOV W4, SPI1CON1
112:                   PIXCON1.PPRE=3;
0018D8  200030     MOV #0x3, W0
0018DA  B72242     IOR SPI1CON1
113:                   PIXCON2.SPIBEN=1;  // enhanced buffer mode
0018DC  A80244     BSET SPI1CON2, #0
114:                   PIXSTAT.SPIEN=1;
0018DE  A8E241     BSET 0x241, #7
115:                   VIDTMR.TON=1;
0018E0  A8E111     BSET 0x111, #7
116:               }//horz_sync_init()
0018E2  060000     RETURN
117:               
118:               void  wait_n_frame(unsigned n){
119:               unsigned long f0;
120:                   f0=frame_cntr+n;
0018E4  80F6A4     MOV frame_cntr, W4
0018E6  80F6B5     MOV 0x1ED6, W5
0018E8  420000     ADD W4, W0, W0
0018EA  4A80E0     ADDC W5, #0x0, W1
121:                   while (frame_cntr<f0);
0018EC  80F6A4     MOV frame_cntr, W4
0018EE  80F6B5     MOV 0x1ED6, W5
0018F0  500F84     SUB W0, W4, [W15]
0018F2  588F85     SUBB W1, W5, [W15]
0018F4  3EFFFB     BRA GTU, 0x18EC
122:               }//f()
0018F6  060000     RETURN
123:               
124:               
125:               
126:               
127:               // video sync signal generation
128:               void __attribute__((interrupt,no_auto_psv,shadow)) _VSYNC_ISR(void){
0018F8  FEA000     PUSH.S
0018FA  BE9F84     MOV.D W4, [W15++]
129:                   frame_line_cntr++;
0018FC  80F684     MOV frame_line_cntr, W4
0018FE  E80204     INC W4, W4
001900  88F684     MOV W4, frame_line_cntr
130:                   switch (frame_line_cntr){
001902  200375     MOV #0x37, W5
001904  520F85     SUB W4, W5, [W15]
001906  320034     BRA Z, 0x1970
001908  3E0007     BRA GTU, 0x1918
00190A  520FE4     SUB W4, #0x4, [W15]
00190C  32001C     BRA Z, 0x1946
00190E  520FFE     SUB W4, #0x1E, [W15]
001910  320022     BRA Z, 0x1956
001912  520FE1     SUB W4, #0x1, [W15]
001914  3A004F     BRA NZ, 0x19B4
001916  37000F     BRA 0x1936
001918  201075     MOV #0x107, W5
00191A  520F85     SUB W4, W5, [W15]
00191C  320036     BRA Z, 0x198A
00191E  3E0004     BRA GTU, 0x1928
001920  5282F1     SUB W5, #0x11, W5
001922  520F85     SUB W4, W5, [W15]
001924  3A0047     BRA NZ, 0x19B4
001926  37001E     BRA 0x1964
001928  2010F5     MOV #0x10F, W5
00192A  520F85     SUB W4, W5, [W15]
00192C  320028     BRA Z, 0x197E
00192E  201395     MOV #0x139, W5
001930  520F85     SUB W4, W5, [W15]
001932  3A0040     BRA NZ, 0x19B4
001934  370035     BRA 0x19A0
131:                       case 1:
132:                           VSYNCR=vsync;
001936  F81ECC     PUSH vsync
001938  F90182     POP OC1R
133:                           VDLYCON.OCM=0;
00193A  800CB4     MOV OC4CON, W4
00193C  A10004     BCLR W4, #0
00193E  A11004     BCLR W4, #1
001940  A12004     BCLR W4, #2
001942  880CB4     MOV W4, OC4CON
134:                           break;
001944  370037     BRA 0x19B4
135:                       case 4:
136:                           VDLYCON.OCM=5;
001946  800CB4     MOV OC4CON, W4
001948  A00004     BSET W4, #0
00194A  A11004     BCLR W4, #1
00194C  A02004     BSET W4, #2
00194E  880CB4     MOV W4, OC4CON
137:                           VSYNCR=hsync;
001950  F81ECE     PUSH hsync
001952  F90182     POP OC1R
138:                           break;
001954  37002F     BRA 0x19B4
139:                       case NTSC_FIRST_VISIBLE:
140:                           if (video_mode==NTSC_MODE){
001956  80F644     MOV video_mode, W4
001958  520FE0     SUB W4, #0x0, [W15]
00195A  3A002C     BRA NZ, 0x19B4
141:                               VDLYIF=0;
00195C  A96086     BCLR IFS1, #3
142:                               VDLYIE=1;
00195E  A86096     BSET IEC1, #3
143:                               flags &= ~F_RETRACE;
001960  A97ED2     BCLR flags, #3
001962  370028     BRA 0x19B4
144:                           }
145:                           break;
146:                       case NTSC_LAST_VISIBLE:
147:                           if (video_mode==NTSC_MODE){
001964  80F644     MOV video_mode, W4
001966  520FE0     SUB W4, #0x0, [W15]
001968  3A0025     BRA NZ, 0x19B4
148:                               VDLYIE=0;
00196A  A96096     BCLR IEC1, #3
149:                               flags |= F_RETRACE;
00196C  A87ED2     BSET flags, #3
00196E  370022     BRA 0x19B4
150:                           }
151:                           break;
152:                       case PAL_FIRST_VISIBLE:
153:                           if (video_mode==PAL_MODE){
001970  80F644     MOV video_mode, W4
001972  520FE1     SUB W4, #0x1, [W15]
001974  3A001F     BRA NZ, 0x19B4
154:                               VDLYIF=0;
001976  A96086     BCLR IFS1, #3
155:                               VDLYIE=1;
001978  A86096     BSET IEC1, #3
156:                               flags &= ~F_RETRACE;
00197A  A97ED2     BCLR flags, #3
00197C  37001B     BRA 0x19B4
157:                           }
158:                           break;
159:                       case PAL_LAST_VISIBLE:
160:                           if (video_mode==PAL_MODE){
00197E  80F644     MOV video_mode, W4
001980  520FE1     SUB W4, #0x1, [W15]
001982  3A0018     BRA NZ, 0x19B4
161:                               VDLYIE=0;
001984  A96096     BCLR IEC1, #3
162:                               flags |= F_RETRACE;
001986  A87ED2     BSET flags, #3
001988  370015     BRA 0x19B4
163:                           }
164:                           break;
165:                       case NTSC_LINES_PER_FRAME+1:
166:                           if (video_mode==NTSC_MODE){
00198A  80F644     MOV video_mode, W4
00198C  520FE0     SUB W4, #0x0, [W15]
00198E  3A0012     BRA NZ, 0x19B4
167:                               frame_line_cntr=0;
001990  EF3ED0     CLR frame_line_cntr
168:                               frame_cntr++;
001992  80F6A4     MOV frame_cntr, W4
001994  80F6B5     MOV 0x1ED6, W5
001996  420261     ADD W4, #0x1, W4
001998  4A82E0     ADDC W5, #0x0, W5
00199A  88F6A4     MOV W4, frame_cntr
00199C  88F6B5     MOV W5, 0x1ED6
00199E  37000A     BRA 0x19B4
169:                           }
170:                           break;
171:                       case PAL_LINES_PER_FRAME+1:
172:                           if (video_mode==PAL_MODE){
0019A0  80F644     MOV video_mode, W4
0019A2  520FE1     SUB W4, #0x1, [W15]
0019A4  3A0007     BRA NZ, 0x19B4
173:                               frame_line_cntr=0;
0019A6  EF3ED0     CLR frame_line_cntr
174:                               frame_cntr++;
0019A8  80F6A4     MOV frame_cntr, W4
0019AA  80F6B5     MOV 0x1ED6, W5
0019AC  420261     ADD W4, #0x1, W4
0019AE  4A82E0     ADDC W5, #0x0, W5
0019B0  88F6A4     MOV W4, frame_cntr
0019B2  88F6B5     MOV W5, 0x1ED6
175:                           }
176:                           break;
177:                   }//switch
178:                   VSYNCIF=0;
0019B4  A9E084     BCLR IFS0, #7
179:               }// _VSYNC_ISR()
0019B6  BE024F     MOV.D [--W15], W4
0019B8  FE8000     POP.S
0019BA  064000     RETFIE
180:               
181:               void __attribute__((interrupt,no_auto_psv,shadow)) _VIDEO_OUT_ISR(void){
0019BC  FEA000     PUSH.S
0019BE  BE9F84     MOV.D W4, [W15++]
0019C0  BE9F86     MOV.D W6, [W15++]
0019D6  B9337B     MUL.SU W6, #27, W6
0019D8  207FF4     MOV #0x7FF, W4
0019DA  430304     ADD W6, W4, W6
182:                   int y,x;
183:                   if (PIXDLY_INP){
0019C2  AB22CB     BTST 0x2CB, #1
0019C4  320016     BRA Z, 0x19F2
184:                       if (video_mode==NTSC_MODE){
0019C6  80F644     MOV video_mode, W4
0019C8  520FE0     SUB W4, #0x0, [W15]
0019CA  3A0003     BRA NZ, 0x19D2
185:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE);
0019CC  80F686     MOV frame_line_cntr, W6
0019CE  53037E     SUB W6, #0x1E, W6
0019D0  370002     BRA 0x19D6
186:                       }else{
187:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE);
0019D2  80F686     MOV frame_line_cntr, W6
0019D4  B10376     SUB #0x37, W6
188:                       }
189:                       for (x=0;x<BYTES_PER_LINE;x++){
0019DC  EB0280     CLR W5
0019E6  E80285     INC W5, W5
0019E8  528FFB     SUB W5, #0x1B, [W15]
0019EA  3AFFF9     BRA NZ, 0x19DE
190:                           while (PIXSTAT.SPITBF);
0019DE  AB2240     BTST SPI1STAT, #1
0019E0  3AFFFE     BRA NZ, 0x19DE
191:                           PIXBUF=video_buffer[y][x];
0019E2  FB0256     SE [++W6], W4
0019E4  881244     MOV W4, SPI1BUF
192:                       }//for
193:                       while (PIXSTAT.SPITBF);
0019EC  AB2240     BTST SPI1STAT, #1
0019EE  3AFFFE     BRA NZ, 0x19EC
194:                       PIXBUF=0;
0019F0  EF2248     CLR SPI1BUF
195:                   }
196:                   VDLYIF=0;
0019F2  A96086     BCLR IFS1, #3
197:               }// _VIDEO_OUT_ISR
0019F4  BE034F     MOV.D [--W15], W6
0019F6  BE024F     MOV.D [--W15], W4
0019F8  FE8000     POP.S
0019FA  064000     RETFIE
198:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  216x216 pixels
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include "PICvision.h"
34:                
35:                
36:                void PICvision_init(void) {
37:                    HardwareConfig();
001C96  07FF68     RCALL HardwareConfig
38:                    timers_init(TICK_FREQ);
001C98  200640     MOV #0x64, W0
001C9A  07FCF9     RCALL timers_init
39:                    video_init();
001C9C  07FE06     RCALL video_init
40:                    sound_init(1000/TICK_FREQ);
001C9E  2000A0     MOV #0xA, W0
001CA0  07FEB9     RCALL sound_init
41:                }//f()
001CA2  060000     RETURN
42:                
43:                
