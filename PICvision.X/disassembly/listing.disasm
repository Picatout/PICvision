Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-03-04 22:14:00

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/timers.c  ---------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 *  NAME: timers.c
21:                 *  DATE CREATED: 2014-02-21
22:                 *  AUTHOR: Jacques Deschênes
23:                 *  DESCRIPTION: create timers with callback. TIMER1 is used as a system timer that
24:                 *               ticks at regular interval. The ISR of TIMER1 manage created timers.
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "timers.h"
29:                
30:                #define F_TMR_USED 1
31:                #define F_TMR_HALTED 2
32:                #define F_TMR_REPEAT 4
33:                #define TMR_RUNNING 1
34:                
35:                
36:                typedef struct timer_type{
37:                    unsigned status;    // slot used,  timer halted
38:                    unsigned delay;    // timer interval
39:                    unsigned countdown;
40:                    timer_handler_t *handler; // timer callback handler
41:                }timer_t;
42:                
43:                volatile static timer_t timers[MAX_TIMERS];
44:                volatile static unsigned long ticks;
45:                
46:                void timers_init(unsigned ticks_per_second){
00114C  BE9F88     MOV.D W8, [W15++]
00114E  781F8A     MOV W10, [W15++]
001150  780500     MOV W0, W10
47:                    unsigned long quotient;
48:                    unsigned prescale;
49:                    int i;
50:                    for (i=0;i<MAX_TIMERS;i++){
001152  EB0200     CLR W4
001164  E80204     INC W4, W4
001166  520FE8     SUB W4, #0x8, [W15]
001168  3AFFF8     BRA NZ, 0x115A
51:                        timers[i].status=0;
001154  21EDA1     MOV #0x1EDA, W1
001156  EB0300     CLR W6
00115A  DD22C3     SL W4, #3, W5
00115C  408385     ADD W1, W5, W7
00115E  780B86     MOV W6, [W7]
52:                        timers[i].handler=NULL;
001158  408066     ADD W1, #0x6, W0
001160  400285     ADD W0, W5, W5
001162  780A86     MOV W6, [W5]
53:                    }//for
54:                    ticks=0;
00116A  EF3ED6     CLR ticks
00116C  EF3ED8     CLR 0x1ED8
55:                
56:                    SYSTICKTMR.TON=0;  // disable systick timer
00116E  A9E105     BCLR 0x105, #7
57:                    SYSTICKTMR.TCS=0;  // use internal Tcy
001170  A92104     BCLR T1CON, #1
58:                    quotient = FCY/ticks_per_second;
001172  B85461     MUL.UU W10, #1, W8
001174  BE0108     MOV.D W8, W2
001176  224000     MOV #0x2400, W0
001178  200F41     MOV #0xF4, W1
00117A  07F999     RCALL 0x4AE
59:                    prescale=1;
001182  200014     MOV #0x1, W4
60:                    while (quotient>65535){
00117C  400FE1     ADD W0, #0x1, [W15]
00117E  588FE0     SUBB W1, #0x0, [W15]
001180  36000B     BRA LEU, 0x1198
001184  2FFFF6     MOV #0xFFFF, W6
001186  200007     MOV #0x0, W7
00118E  500F86     SUB W0, W6, [W15]
001190  588F87     SUBB W1, W7, [W15]
001192  3EFFFA     BRA GTU, 0x1188
61:                        quotient >>= 1;
001188  D10081     LSR W1, W1
00118A  D38000     RRC W0, W0
62:                        prescale <<= 1;
00118C  420204     ADD W4, W4, W4
63:                    }
64:                    if (prescale==1){
001194  520FE1     SUB W4, #0x1, [W15]
001196  3A0006     BRA NZ, 0x11A4
65:                        SYSTICKTMR.TCKPS=0;
001198  800824     MOV T1CON, W4
00119A  A14004     BCLR W4, #4
00119C  A15004     BCLR W4, #5
00119E  880824     MOV W4, T1CON
66:                        SYSTICKPR=quotient;
0011A0  880810     MOV W0, PR1
0011A2  370020     BRA 0x11E4
67:                    }else if (prescale<=8){
0011A4  520FE8     SUB W4, #0x8, [W15]
0011A6  3E000A     BRA GTU, 0x11BC
68:                        SYSTICKTMR.TCKPS=1;
0011A8  800824     MOV T1CON, W4
0011AA  A04004     BSET W4, #4
0011AC  A15004     BCLR W4, #5
0011AE  880824     MOV W4, T1CON
69:                        SYSTICKPR= FCY/8/ticks_per_second;
0011B0  BE0108     MOV.D W8, W2
0011B2  284800     MOV #0x8480, W0
0011B4  2001E1     MOV #0x1E, W1
0011B6  07F97B     RCALL 0x4AE
0011B8  880810     MOV W0, PR1
0011BA  370014     BRA 0x11E4
70:                    }else if (prescale<=64){
0011BC  200405     MOV #0x40, W5
0011BE  520F85     SUB W4, W5, [W15]
0011C0  3E000A     BRA GTU, 0x11D6
71:                        SYSTICKTMR.TCKPS=2;
0011C2  800824     MOV T1CON, W4
0011C4  A14004     BCLR W4, #4
0011C6  A05004     BSET W4, #5
0011C8  880824     MOV W4, T1CON
72:                        SYSTICKPR= FCY/64/ticks_per_second;
0011CA  BE0108     MOV.D W8, W2
0011CC  2D0900     MOV #0xD090, W0
0011CE  200031     MOV #0x3, W1
0011D0  07F96E     RCALL 0x4AE
0011D2  880810     MOV W0, PR1
0011D4  370007     BRA 0x11E4
73:                    }else{
74:                        SYSTICKTMR.TCKPS=3;
0011D6  200300     MOV #0x30, W0
0011D8  B72104     IOR T1CON
75:                        SYSTICKPR = FCY/256/ticks_per_second;
0011DA  2F4244     MOV #0xF424, W4
0011DC  090011     REPEAT #0x11
0011DE  D8820A     DIV.UW W4, W10
0011E0  780200     MOV W0, W4
0011E2  880814     MOV W4, PR1
76:                    }//if
77:                    SYSTICKIF=0; // reset interrupt flag
0011E4  A96084     BCLR IFS0, #3
78:                    SYSTICKIE=1; // enable interrupt on systick timer
0011E6  A86094     BSET IEC0, #3
79:                    SYSTICKTMR.TON = 1; // enable systick timer
0011E8  A8E105     BSET 0x105, #7
80:                }//f()
0011EA  78054F     MOV [--W15], W10
0011EC  BE044F     MOV.D [--W15], W8
0011EE  060000     RETURN
81:                
82:                int create_timer(unsigned delay, unsigned repeat, timer_handler_t *handler){
83:                    int i;
84:                    if (!handler) return -1;
0011F0  EB8200     SETM W4
0011F2  510FE0     SUB W2, #0x0, [W15]
0011F4  320020     BRA Z, 0x1236
85:                    for (i=0;i<MAX_TIMERS;i++){
0011FA  200014     MOV #0x1, W4
00122E  E80204     INC W4, W4
001230  520FE8     SUB W4, #0x8, [W15]
001232  3AFFE4     BRA NZ, 0x11FC
86:                        if (!(timers[i].status & F_TMR_USED)){
0011F6  AB1EDA     BTST timers, #0
0011F8  320007     BRA Z, 0x1208
0011FC  DD22C3     SL W4, #3, W5
0011FE  21EDA6     MOV #0x1EDA, W6
001200  7A82E6     MOV [W6+W5], W5
001202  6282E1     AND W5, #0x1, W5
001204  3A0014     BRA NZ, 0x122E
001206  370001     BRA 0x120A
001208  EB0200     CLR W4
87:                            timers[i].status = F_TMR_USED|F_TMR_HALTED;
00120A  DD22C3     SL W4, #3, W5
00120C  200037     MOV #0x3, W7
00120E  21EDA6     MOV #0x1EDA, W6
001210  7AB307     MOV W7, [W6+W5]
88:                            if (repeat==TIMER_REPEAT) {timers[i].status |= F_TMR_REPEAT;}
001212  508FE1     SUB W1, #0x1, [W15]
001214  3A0004     BRA NZ, 0x121E
001216  7A83E6     MOV [W6+W5], W7
001218  430285     ADD W6, W5, W5
00121A  A02007     BSET W7, #2
00121C  780A87     MOV W7, [W5]
89:                            timers[i].delay=delay;
00121E  DD22C3     SL W4, #3, W5
001220  21EDC6     MOV #0x1EDC, W6
001222  7AB300     MOV W0, [W6+W5]
90:                            timers[i].countdown=delay;
001224  E88306     INC2 W6, W6
001226  7AB300     MOV W0, [W6+W5]
91:                            timers[i].handler=handler;
001228  E88306     INC2 W6, W6
00122A  7AB302     MOV W2, [W6+W5]
92:                            return i;
00122C  370004     BRA 0x1236
93:                        }//if
94:                    }//for
95:                    return -1;
001234  EB8200     SETM W4
96:                }//f()
001236  780004     MOV W4, W0
001238  060000     RETURN
97:                
98:                void stop_timer(int timer_id){
99:                    if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
00123A  500FE7     SUB W0, #0x7, [W15]
00123C  3E000B     BRA GTU, 0x1254
001244  620261     AND W4, #0x1, W4
001246  320006     BRA Z, 0x1254
100:                        (timers[timer_id].status & F_TMR_USED)){
00123E  DD0243     SL W0, #3, W4
001240  21EDA5     MOV #0x1EDA, W5
001242  7A0265     MOV [W5+W4], W4
101:                       timers[timer_id].status |= F_TMR_HALTED;
001248  DD0043     SL W0, #3, W0
00124A  780205     MOV W5, W4
00124C  7802E4     MOV [W4+W0], W5
00124E  420000     ADD W4, W0, W0
001250  A01005     BSET W5, #1
001252  780805     MOV W5, [W0]
102:                   }//if
103:               }//f()
001254  060000     RETURN
104:               
105:               void start_timer(int timer_id){
106:                   if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
001256  500FE7     SUB W0, #0x7, [W15]
001258  3E000F     BRA GTU, 0x1278
001260  620261     AND W4, #0x1, W4
001262  32000A     BRA Z, 0x1278
107:                       (timers[timer_id].status & F_TMR_USED)){
00125A  DD0243     SL W0, #3, W4
00125C  21EDA5     MOV #0x1EDA, W5
00125E  7A0265     MOV [W5+W4], W4
108:                           timers[timer_id].countdown=timers[timer_id].delay;
001264  DD0043     SL W0, #3, W0
001266  E88300     INC2 W0, W6
001268  780205     MOV W5, W4
00126A  4282E4     ADD W5, #0x4, W5
00126C  7B0364     MOV [W4+W6], W6
00126E  783286     MOV W6, [W5+W0]
109:                           timers[timer_id].status &= ~F_TMR_HALTED;
001270  7802E4     MOV [W4+W0], W5
001272  420000     ADD W4, W0, W0
001274  A11005     BCLR W5, #1
001276  780805     MOV W5, [W0]
110:                   }//if
111:               }//f()
001278  060000     RETURN
112:               
113:               void update_timer(int timer_id, unsigned new_delay){
114:                   if ((timer_id>=0)&&(timer_id<=MAX_TIMERS)&&timers[timer_id].status){
00127A  500FE8     SUB W0, #0x8, [W15]
00127C  3E0008     BRA GTU, 0x128E
00127E  DD0243     SL W0, #3, W4
001280  21EDA5     MOV #0x1EDA, W5
001282  7A0265     MOV [W5+W4], W4
001284  520FE0     SUB W4, #0x0, [W15]
001286  320003     BRA Z, 0x128E
115:                       timers[timer_id].delay=new_delay;
001288  DD0043     SL W0, #3, W0
00128A  E88205     INC2 W5, W4
00128C  783201     MOV W1, [W4+W0]
116:                   }
117:               }//f()
00128E  060000     RETURN
118:               
119:               void destroy_timer(int timer_id){
120:                   if ((timer_id<0)||(timer_id>=MAX_TIMERS)) return;
001290  500FE7     SUB W0, #0x7, [W15]
001292  3E0008     BRA GTU, 0x12A4
121:                   timers[timer_id].status=0;
001294  DD0043     SL W0, #3, W0
001296  21EDA5     MOV #0x1EDA, W5
001298  428280     ADD W5, W0, W5
00129A  EB0200     CLR W4
00129C  780A84     MOV W4, [W5]
122:                   timers[timer_id].handler=NULL;
00129E  21EE05     MOV #0x1EE0, W5
0012A0  428000     ADD W5, W0, W0
0012A2  780804     MOV W4, [W0]
123:               }//f()
0012A4  060000     RETURN
124:               
125:               unsigned long sys_ticks(){
126:                   return ticks;
0012A6  80F6B0     MOV ticks, W0
0012A8  80F6C1     MOV 0x1ED8, W1
127:               }//f()
0012AA  060000     RETURN
128:               
129:               void __attribute__((interrupt,no_auto_psv)) _SYSTICK_ISR(void){
0012AC  F80036     PUSH RCOUNT
0012AE  BE9F80     MOV.D W0, [W15++]
0012B0  BE9F82     MOV.D W2, [W15++]
0012B2  BE9F84     MOV.D W4, [W15++]
0012B4  BE9F86     MOV.D W6, [W15++]
0012B6  BE9F88     MOV.D W8, [W15++]
0012B8  BE9F8A     MOV.D W10, [W15++]
130:                   int i;
131:                   ticks++;
0012BA  80F6B4     MOV ticks, W4
0012BC  80F6C5     MOV 0x1ED8, W5
0012BE  420261     ADD W4, #0x1, W4
0012C0  4A82E0     ADDC W5, #0x0, W5
0012C2  88F6B4     MOV W4, ticks
0012C4  88F6C5     MOV W5, 0x1ED8
132:                   for (i=0;i<MAX_TIMERS;i++){
0012C6  EB0400     CLR W8
00130E  E80408     INC W8, W8
001310  540FE8     SUB W8, #0x8, [W15]
001312  3AFFDB     BRA NZ, 0x12CA
133:                       if (((timers[i].status&(F_TMR_USED|F_TMR_HALTED))==TMR_RUNNING)){
0012CA  DD4243     SL W8, #3, W4
0012CC  21EDA5     MOV #0x1EDA, W5
0012CE  7A0265     MOV [W5+W4], W4
0012D0  620263     AND W4, #0x3, W4
0012D2  520FE1     SUB W4, #0x1, [W15]
0012D4  3A001C     BRA NZ, 0x130E
134:                           if (--timers[i].countdown==0){
0012C8  21EDE9     MOV #0x1EDE, W9
0012D6  DD4343     SL W8, #3, W6
0012D8  430264     ADD W6, #0x4, W4
0012DA  7A03E5     MOV [W5+W4], W7
0012DC  448306     ADD W9, W6, W6
0012DE  E90B07     DEC W7, [W6]
0012E0  7A0265     MOV [W5+W4], W4
0012E2  520FE0     SUB W4, #0x0, [W15]
0012E4  3A0014     BRA NZ, 0x130E
135:                               timers[i].handler();
0012E6  DD45C3     SL W8, #3, W11
0012E8  458266     ADD W11, #0x6, W4
0012EA  780505     MOV W5, W10
0012EC  7A026A     MOV [W10+W4], W4
0012EE  010004     CALL W4
136:                               if (timers[i].status & F_TMR_REPEAT) {
0012F0  7D826A     MOV [W10+W11], W4
0012F2  620264     AND W4, #0x4, W4
0012F4  320006     BRA Z, 0x1302
137:                                   timers[i].countdown=timers[i].delay;
0012F6  78020B     MOV W11, W4
0012F8  E88284     INC2 W4, W5
0012FA  78030A     MOV W10, W6
0012FC  7A8366     MOV [W6+W5], W6
0012FE  7A3486     MOV W6, [W9+W4]
001300  370006     BRA 0x130E
138:                               }else{
139:                                   timers[i].status |= F_TMR_HALTED;
001302  DD4243     SL W8, #3, W4
001304  21EDA5     MOV #0x1EDA, W5
001306  7A0365     MOV [W5+W4], W6
001308  428204     ADD W5, W4, W4
00130A  A01006     BSET W6, #1
00130C  780A06     MOV W6, [W4]
140:                               }
141:                           }//if
142:                       }
143:                   }//for
144:                   SYSTICKIF=0;
001314  A96084     BCLR IFS0, #3
145:               }// _SYSTICK_ISR()
001316  BE054F     MOV.D [--W15], W10
001318  BE044F     MOV.D [--W15], W8
00131A  BE034F     MOV.D [--W15], W6
00131C  BE024F     MOV.D [--W15], W4
00131E  BE014F     MOV.D [--W15], W2
001320  BE004F     MOV.D [--W15], W0
001322  F90036     POP RCOUNT
001324  064000     RETFIE
146:               
147:               
148:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/text_console.c  ---------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   text_console.h
21:                 * Author: jacques Deschênes
22:                 * Description: manage text writing in video_buffer
23:                 * Created on 28 février 2014, 10:04
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                #include "text_console.h"
29:                
30:                //static text_coord_t cursor_pos;
31:                
32:                //#define X_OFS  ((HPIXELS-CHAR_PER_LINE*CHAR_WIDTH)/2)  // x offset to cursor from screen edge
33:                //#define Y_OFS  ((VPIXELS-LINE_PER_SCREEN*CHAR_HEIGHT)/2) // y offset to cursor from screen edge
34:                
35:                // boolean flags
36:                #define CUR_SHOW 1  // cursor active
37:                #define CUR_VIS  2  // cursor state visible
38:                #define INV_VID  4  // invert video
39:                
40:                
41:                static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
42:                static unsigned char tab_width=TAB_WIDTH;
43:                static cursor_t cur_shape=CR_UNDER;
44:                static unsigned short flags=0;
45:                
46:                
47:                
48:                void scroll_up(void){
49:                    char *src, *dst;
50:                    dst = (char*)video_buffer;
51:                    src = (char*)video_buffer + CHAR_HEIGHT*BYTES_PER_LINE;
52:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
000DF2  215F02     MOV #0x15F0, W2
000DF4  208D81     MOV #0x8D8, W1
000DF6  208000     MOV #0x800, W0
000DF8  07FBA9     RCALL 0x54C
53:                    dst= (char*)video_buffer+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*BYTES_PER_LINE;
54:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
000DFA  21DF04     MOV #0x1DF0, W4
000DFC  0900D7     REPEAT #0xD7
000DFE  EB5A00     CLR.B [W4++]
55:                }//scroll_up();
000E00  060000     RETURN
56:                
57:                void scroll_down(void){
58:                    char *src, *dst;
59:                    src = (char*)video_buffer;
60:                    dst = (char*)video_buffer+CHAR_HEIGHT*BYTES_PER_LINE;
61:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
000E02  215F02     MOV #0x15F0, W2
000E04  208001     MOV #0x800, W1
000E06  200D80     MOV #0xD8, W0
000E08  400001     ADD W0, W1, W0
000E0A  07FBA0     RCALL 0x54C
62:                    dst=(char*)video_buffer;
63:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
000E0C  208004     MOV #0x800, W4
000E0E  0900D7     REPEAT #0xD7
000E10  EB5A00     CLR.B [W4++]
64:                }//scroll_down()
000E12  060000     RETURN
65:                
66:                
67:                void cursor_right(void){
68:                    cx += CHAR_WIDTH;
000E14  80F8F4     MOV cx, W4
000E16  420266     ADD W4, #0x6, W4
000E18  88F8F4     MOV W4, cx
69:                    if (cx>(CHAR_PER_LINE*CHAR_WIDTH)){
000E1A  200D25     MOV #0xD2, W5
000E1C  520F85     SUB W4, W5, [W15]
000E1E  36000A     BRA LEU, 0xE34
70:                        cx = 0;
000E20  EF3F1E     CLR cx
71:                        cy += CHAR_HEIGHT;
000E22  80F904     MOV cy, W4
000E24  420268     ADD W4, #0x8, W4
000E26  88F904     MOV W4, cy
72:                        if (cy>(LINE_PER_SCREEN*CHAR_HEIGHT)){
000E28  4282E6     ADD W5, #0x6, W5
000E2A  520F85     SUB W4, W5, [W15]
000E2C  360003     BRA LEU, 0xE34
73:                            scroll_up();
000E2E  07FFE1     RCALL scroll_up
74:                            cy -= CHAR_HEIGHT;
000E30  2FFF80     MOV #0xFFF8, W0
000E32  B43F20     ADD cy
75:                        }
76:                    }
77:                } // cursor_right()
000E34  060000     RETURN
78:                
79:                void cursor_left(void){
80:                    if (cx>=CHAR_WIDTH){
000E36  80F8F4     MOV cx, W4
000E38  520FE5     SUB W4, #0x5, [W15]
000E3A  360003     BRA LEU, 0xE42
81:                        cx -= CHAR_WIDTH;
000E3C  520266     SUB W4, #0x6, W4
000E3E  88F8F4     MOV W4, cx
000E40  370009     BRA 0xE54
82:                    }else{
83:                        cx = CHAR_WIDTH*(CHAR_PER_LINE-1);
000E42  200CC4     MOV #0xCC, W4
000E44  88F8F4     MOV W4, cx
84:                        if (cy>=CHAR_HEIGHT){
000E46  80F904     MOV cy, W4
000E48  520FE7     SUB W4, #0x7, [W15]
000E4A  360003     BRA LEU, 0xE52
85:                            cy -= CHAR_HEIGHT;
000E4C  520268     SUB W4, #0x8, W4
000E4E  88F904     MOV W4, cy
000E50  370001     BRA 0xE54
86:                        }else{
87:                            scroll_down();
000E52  07FFD7     RCALL scroll_down
88:                        }
89:                    }
90:                }// cursor_left()
000E54  060000     RETURN
91:                
92:                void cursor_up(void){
93:                    if (cy>=CHAR_HEIGHT){
000E56  80F904     MOV cy, W4
000E58  520FE7     SUB W4, #0x7, [W15]
000E5A  360003     BRA LEU, 0xE62
94:                        cy -= CHAR_HEIGHT;
000E5C  520268     SUB W4, #0x8, W4
000E5E  88F904     MOV W4, cy
000E60  370001     BRA 0xE64
95:                    }else{
96:                        scroll_down();
000E62  07FFCF     RCALL scroll_down
97:                    }
98:                }// cursor_up()
000E64  060000     RETURN
99:                
100:               void cursor_down(void){
101:                   if (cy<=(CHAR_HEIGHT*(LINE_PER_SCREEN-2))){
000E66  80F904     MOV cy, W4
000E68  200C85     MOV #0xC8, W5
000E6A  520F85     SUB W4, W5, [W15]
000E6C  3E0003     BRA GTU, 0xE74
102:                       cy += CHAR_HEIGHT;
000E6E  420268     ADD W4, #0x8, W4
000E70  88F904     MOV W4, cy
000E72  370001     BRA 0xE76
103:                   }else{
104:                       scroll_up();
000E74  07FFBE     RCALL scroll_up
105:                   }
106:               }//cursor_down()
000E76  060000     RETURN
107:               
108:               void crlf(void){
109:                   cx=0;
000E78  EF3F1E     CLR cx
110:                   if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
000E7A  80F904     MOV cy, W4
000E7C  200D05     MOV #0xD0, W5
000E7E  520F85     SUB W4, W5, [W15]
000E80  3A0002     BRA NZ, 0xE86
111:                       scroll_up();
000E82  07FFB7     RCALL scroll_up
000E84  370002     BRA 0xE8A
112:                   }else{
113:                       cy += CHAR_HEIGHT;
000E86  420268     ADD W4, #0x8, W4
000E88  88F904     MOV W4, cy
114:                   }
115:               }//crlf()
000E8A  060000     RETURN
116:               
117:               void put_char(char c){
000E8C  4787E6     ADD W15, #0x6, W15
000E8E  BE9F88     MOV.D W8, [W15++]
000E90  BE9F8A     MOV.D W10, [W15++]
000E92  BE9F8C     MOV.D W12, [W15++]
000E94  781F8E     MOV W14, [W15++]
000F0A  E80381     INC W1, W7
000F0C  B90A7B     MUL.SU W1, #27, W4
000F0E  780284     MOV W4, W5
000F10  428209     ADD W5, W9, W4
000F12  20800D     MOV #0x800, W13
000F14  42020D     ADD W4, W13, W4
000F18  DD3743     SL W6, #3, W14
000F1A  285B06     MOV #0x85B0, W6
000F1C  470306     ADD W14, W6, W6
000F1E  E80489     INC W9, W9
000F20  428289     ADD W5, W9, W5
000F22  42828D     ADD W5, W13, W5
000F24  4080E9     ADD W1, #0x9, W1
118:                   register int i,l,r,b,x,y;
119:                   x=cx;
000E96  80F8F3     MOV cx, W3
120:                   y=cy;
000E98  80F901     MOV cy, W1
121:                   switch (c){
000E9A  504FE9     SUB.B W0, #0x9, [W15]
000E9C  320007     BRA Z, 0xEAC
000E9E  504FED     SUB.B W0, #0xD, [W15]
000EA0  320003     BRA Z, 0xEA8
000EA2  504FE8     SUB.B W0, #0x8, [W15]
000EA4  3A001B     BRA NZ, 0xEDC
000EA6  370018     BRA 0xED8
122:                       case CR:
123:                           crlf();
000EA8  07FFE7     RCALL crlf
124:                           break;
000EAA  37006D     BRA 0xF86
125:                       case TAB:
126:                           cx += (cx%tab_width);
000EAC  21F2A4     MOV #0x1F2A, W4
000EAE  784214     MOV.B [W4], W4
000EB0  FB8204     ZE W4, W4
000EB2  BE9F80     MOV.D W0, [W15++]
000EB4  090011     REPEAT #0x11
000EB6  D88184     DIV.UW W3, W4
000EB8  780201     MOV W1, W4
000EBA  BE004F     MOV.D [--W15], W0
000EBC  420183     ADD W4, W3, W3
000EBE  88F8F3     MOV W3, cx
127:                           if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
000EC0  200D14     MOV #0xD1, W4
000EC2  518F84     SUB W3, W4, [W15]
000EC4  360060     BRA LEU, 0xF86
128:                               cx = 0;
000EC6  EF3F1E     CLR cx
129:                               if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
000EC8  E90204     DEC W4, W4
000ECA  508F84     SUB W1, W4, [W15]
000ECC  3A0002     BRA NZ, 0xED2
130:                                   scroll_up();
000ECE  07FF91     RCALL scroll_up
000ED0  37005A     BRA 0xF86
131:                               }else{
132:                                   cy += CHAR_HEIGHT;
000ED2  4080E8     ADD W1, #0x8, W1
000ED4  88F901     MOV W1, cy
000ED6  370057     BRA 0xF86
133:                               }
134:                           }
135:                           break;
136:                       case '\b':
137:                           cursor_left();
000ED8  07FFAE     RCALL cursor_left
138:                           break;
000EDA  370055     BRA 0xF86
139:                       default:
140:                           if ((c<32) || (c>=(FONT_SIZE+32))) break;
000EDC  504FFF     SUB.B W0, #0x1F, [W15]
000EDE  340053     BRA LE, 0xF86
141:                           c -=32;
000EE0  B3CE06     MOV #0xE0, W6
000EE2  404306     ADD.B W0, W6, W6
142:                           b=x>>3; // character position in video_buffer
000EE4  DE9CC3     ASR W3, #3, W9
143:                           r=0;
144:                           l=(8-CHAR_WIDTH)-(x&7); // shift inside this byte
000EE6  6181E7     AND W3, #0x7, W3
000EE8  1181E2     SUBR W3, #0x2, W3
145:                           if (l<0){
146:                               r=-l;
000EEA  DE9A4F     ASR W3, #15, W4
000EEC  EA0003     NEG W3, W0
000EEE  600004     AND W0, W4, W0
147:                           }
148:                           for (i=0;i<8;i++){
000F80  538F81     SUB W7, W1, [W15]
000F82  3AFFD1     BRA NZ, 0xF26
149:                               if (r){
000F26  500FE0     SUB W0, #0x0, [W15]
000F28  320018     BRA Z, 0xF5A
150:                                   if (flags & INV_VID){
000EF0  80F8D2     MOV flags, W2
000EF2  610164     AND W2, #0x4, W2
000F2A  510FE0     SUB W2, #0x0, [W15]
000F2C  32000B     BRA Z, 0xF44
151:                                       video_buffer[y][b] |= (0x3f>>r);
000EF4  2003FA     MOV #0x3F, W10
000EF6  DED600     ASR W10, W0, W12
000F36  764694     IOR.B W12, [W4], W13
152:                                       video_buffer[y][b] &=~(font6x8[(int)c][i]>>r);
000F2E  784696     MOV.B [W6], W13
000F30  FB848D     ZE W13, W9
000F32  DECF00     ASR W9, W0, W14
000F34  EAC70E     COM.B W14, W14
000F38  674A0D     AND.B W14, W13, [W4]
153:                                       video_buffer[y][b+1] |= (0x3f<<(8-r));
000EF8  100468     SUBR W0, #0x8, W8
000EFA  DD5588     SL W10, W8, W11
000F3E  75C695     IOR.B W11, [W5], W13
154:                                       video_buffer[y][b+1] &= ~(font6x8[(int)c][i]<<(8-r));
000F3A  DD4C88     SL W9, W8, W9
000F3C  EAC489     COM.B W9, W9
000F40  64CA8D     AND.B W9, W13, [W5]
000F42  37001A     BRA 0xF78
155:                                   }else{
156:                                       video_buffer[y][b] &= ~(0x3f>>r);
000EFC  EAC20C     COM.B W12, W4
000EFE  9FF784     MOV.B W4, [W15-16]
000F48  97F68F     MOV.B [W15-16], W13
000F4A  66C714     AND.B W13, [W4], W14
157:                                       video_buffer[y][b] |= font6x8[(int)c][i]>>r;
000F44  784716     MOV.B [W6], W14
000F46  FB848E     ZE W14, W9
000F4C  DECE80     ASR W9, W0, W13
000F4E  774A0D     IOR.B W14, W13, [W4]
158:                                       video_buffer[y][b+1] &= ~(0x3f<<(8-r));
000F00  EAC68B     COM.B W11, W13
000F02  9FEFFD     MOV.B W13, [W15-17]
000F50  97EF7F     MOV.B [W15-17], W14
000F52  674695     AND.B W14, [W5], W13
159:                                       video_buffer[y][b+1] |= font6x8[(int)c][i]<<(8-r);
000F54  DD4C88     SL W9, W8, W9
000F56  76CA89     IOR.B W13, W9, [W5]
000F58  37000F     BRA 0xF78
160:                                   }
161:                                   y++;
162:                               } else{
163:                                   if (flags & INV_VID){
000F5A  510FE0     SUB W2, #0x0, [W15]
000F5C  320007     BRA Z, 0xF6C
164:                                       video_buffer[y][b] |= (0x3f<<l);
000F04  DD5503     SL W10, W3, W10
000F66  754494     IOR.B W10, [W4], W9
165:                                       video_buffer[y++][b] &=~(font6x8[(int)c][i]<<l);
000F16  FB0306     SE W6, W6
000F5E  784496     MOV.B [W6], W9
000F60  FB8689     ZE W9, W13
000F62  DD6E83     SL W13, W3, W13
000F64  EAC68D     COM.B W13, W13
000F68  66CA09     AND.B W13, W9, [W4]
000F6A  370006     BRA 0xF78
166:                                   }else{
167:                                       video_buffer[y][b] &= ~(0x3f<<l);
000F06  EAC70A     COM.B W10, W14
000F08  9FEFEE     MOV.B W14, [W15-18]
000F6C  97EF6F     MOV.B [W15-18], W14
000F6E  674694     AND.B W14, [W4], W13
168:                                       video_buffer[y++][b] |= font6x8[(int)c][i]<<l;
000F70  784716     MOV.B [W6], W14
000F72  FB848E     ZE W14, W9
000F74  DD4C83     SL W9, W3, W9
000F76  76CA09     IOR.B W13, W9, [W4]
000F78  E80387     INC W7, W7
000F7A  42027B     ADD W4, #0x1B, W4
000F7C  E80306     INC W6, W6
000F7E  4282FB     ADD W5, #0x1B, W5
169:                                   }
170:                               }
171:                           }
172:                           cursor_right();
000F84  07FF47     RCALL cursor_right
173:                   }//switch(c)
174:               }//put_char()
000F86  78074F     MOV [--W15], W14
000F88  BE064F     MOV.D [--W15], W12
000F8A  BE054F     MOV.D [--W15], W10
000F8C  BE044F     MOV.D [--W15], W8
000F8E  B1006F     SUB #0x6, W15
000F90  060000     RETURN
175:               
176:               void clear_screen(){
177:                   memset(video_buffer,0,HPIXELS/8*VPIXELS);
000F92  208004     MOV #0x800, W4
000F94  0916C7     REPEAT #0x16C7
000F96  EB5A00     CLR.B [W4++]
178:                   cx=0;
000F98  EB0200     CLR W4
000F9A  88F8F4     MOV W4, cx
179:                   cy=0;
000F9C  88F904     MOV W4, cy
180:               } // clear_screen()
000F9E  060000     RETURN
181:               
182:               void print(const char *text){
000FA0  781F88     MOV W8, [W15++]
000FA2  780400     MOV W0, W8
183:                   while (*text){
000FA4  784018     MOV.B [W8], W0
000FA6  504FE0     SUB.B W0, #0x0, [W15]
000FA8  320004     BRA Z, 0xFB2
000FAC  784058     MOV.B [++W8], W0
000FAE  504FE0     SUB.B W0, #0x0, [W15]
000FB0  3AFFFC     BRA NZ, 0xFAA
184:                       put_char(*text++);
000FAA  07FF70     RCALL put_char
185:                   }
186:               }// print()
000FB2  78044F     MOV [--W15], W8
000FB4  060000     RETURN
187:               
188:               void print_hex(unsigned int hex, unsigned char width){
000FB6  FA000C     LNK #0xC
189:                   char c[12], *d;
190:                   int i;
191:                   c[11]=0;
000FB8  EB4200     CLR.B W4
000FBA  9FFFF4     MOV.B W4, [W15-1]
192:                   d= &c[10];
000FBE  E9820F     DEC2 W15, W4
193:                   for(i=width;i>=0||hex;i--){
000FBC  FB8301     ZE W1, W6
000FC0  37000C     BRA 0xFDA
000FD8  E90306     DEC W6, W6
000FDA  530FE0     SUB W6, #0x0, [W15]
000FDC  3DFFF2     BRA GE, 0xFC2
000FDE  500FE0     SUB W0, #0x0, [W15]
000FE0  3AFFF0     BRA NZ, 0xFC2
194:                       *d=(hex%16);
000FC2  6042EF     AND.B W0, #0xF, W5
000FC4  784A05     MOV.B W5, [W4]
195:                       if (*d<10)
000FC6  52CFE9     SUB.B W5, #0x9, [W15]
000FC8  3C0003     BRA GT, 0xFD0
196:                           *d += '0';
000FCA  B3C307     MOV #0x30, W7
000FCC  42CA07     ADD.B W5, W7, [W4]
000FCE  370002     BRA 0xFD4
197:                       else
198:                           *d += 'A'-10;
000FD0  B3C377     MOV #0x37, W7
000FD2  42CA07     ADD.B W5, W7, [W4]
199:                       hex /=16;
000FD4  DE0044     LSR W0, #4, W0
200:                       d--;
000FD6  E90204     DEC W4, W4
201:                   }
202:                   print(++d);
000FE2  E80004     INC W4, W0
000FE4  07FFDD     RCALL print
203:               } // print_hex()
000FE6  FA8000     ULNK
000FE8  060000     RETURN
204:               
205:               void print_int(int number, unsigned short width){ // imprime entier,width inclus le signe
000FEA  FA000E     LNK #0xE
001030  538005     SUB W7, W5, W0
001032  780207     MOV W7, W4
206:                   int sign=0, i;
000FF6  EB0100     CLR W2
207:                   char str[14], *d;
208:                   str[13]=0;
000FEC  EB4200     CLR.B W4
000FEE  9FFFF4     MOV.B W4, [W15-1]
000FF0  508FED     SUB W1, #0xD, [W15]
000FF2  360001     BRA LEU, 0xFF6
000FF4  2000D1     MOV #0xD, W1
209:                   d=&str[12];
001006  E9820F     DEC2 W15, W4
001020  E9838F     DEC2 W15, W7
210:                   if (width>13){width=13;}
211:                   if (number<0){
000FF8  500F82     SUB W0, W2, [W15]
000FFA  3D0002     BRA GE, 0x1000
212:                       sign=1;
000FFE  200012     MOV #0x1, W2
213:                       number = -number;
000FFC  EA0000     NEG W0, W0
214:                   }
215:                   //for (i=--width;i>=0||number;i--){
216:                   i=width;
001000  780281     MOV W1, W5
217:                   while (number>0){
001002  500FE0     SUB W0, #0x0, [W15]
001004  34000D     BRA LE, 0x1020
00101A  500FE0     SUB W0, #0x0, [W15]
00101C  3CFFF6     BRA GT, 0x100A
00101E  370001     BRA 0x1022
218:                      *d--=(number%10)+'0';
001008  2000A6     MOV #0xA, W6
00100A  780381     MOV W1, W7
00100C  090011     REPEAT #0x11
00100E  D80006     DIV.SW W0, W6
001010  FD0381     EXCH W1, W7
001012  B3C303     MOV #0x30, W3
001014  43D203     ADD.B W7, W3, [W4--]
001016  780384     MOV W4, W7
219:                       number /= 10;
220:                       i--;
001018  E90285     DEC W5, W5
221:                   }
222:                   if (i==width){
001022  508F85     SUB W1, W5, [W15]
001024  3A0003     BRA NZ, 0x102C
223:                       *d--='0';
001026  B3C304     MOV #0x30, W4
001028  785384     MOV.B W4, [W7--]
224:                       i--;
00102A  E90285     DEC W5, W5
225:                   }
226:                   while (i>0){
00102C  528FE0     SUB W5, #0x0, [W15]
00102E  340007     BRA LE, 0x103E
001038  520F80     SUB W4, W0, [W15]
00103A  3AFFFD     BRA NZ, 0x1036
00103C  538385     SUB W7, W5, W7
227:                       *d--=' ';
001034  B3C206     MOV #0x20, W6
001036  785206     MOV.B W6, [W4--]
228:                       i--;
229:                   }
230:                   if (sign){*d='-';}else{*d=' ';}
00103E  510FE0     SUB W2, #0x0, [W15]
001040  320003     BRA Z, 0x1048
001042  B3C2D4     MOV #0x2D, W4
001044  784B84     MOV.B W4, [W7]
001046  370002     BRA 0x104C
001048  B3C204     MOV #0x20, W4
00104A  784B84     MOV.B W4, [W7]
231:                   print(d);
00104C  780007     MOV W7, W0
00104E  07FFA8     RCALL print
232:               }// print_int()
001050  FA8000     ULNK
001052  060000     RETURN
233:               
234:               void set_tab_width(unsigned char width){
235:                   tab_width=width;
001054  B7FF2A     MOV.B WREG, tab_width
236:               }// set_tab_width()
001056  060000     RETURN
237:               
238:               void clear_eol(void){
001058  BE9F88     MOV.D W8, [W15++]
00105A  BE9F8A     MOV.D W10, [W15++]
239:                   int x,y;
240:                   x=cx;
00105C  80F8FA     MOV cx, W10
241:                   y=cy;
00105E  80F90B     MOV cy, W11
242:                   while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
001060  200C54     MOV #0xC5, W4
001062  550F84     SUB W10, W4, [W15]
001064  3E0007     BRA GTU, 0x1074
001068  780484     MOV W4, W9
00106E  80F8F4     MOV cx, W4
001070  520F89     SUB W4, W9, [W15]
001072  36FFFB     BRA LEU, 0x106A
243:                       put_char(32);
001066  B3C208     MOV #0x20, W8
00106A  784008     MOV.B W8, W0
00106C  07FF0F     RCALL put_char
244:                   }
245:                   put_char(32);
001074  B3C200     MOV #0x20, W0
001076  07FF0A     RCALL put_char
246:                   cx=x;
001078  88F8FA     MOV W10, cx
247:                   cy=y;
00107A  88F90B     MOV W11, cy
248:               }// clear_eol()
00107C  BE054F     MOV.D [--W15], W10
00107E  BE044F     MOV.D [--W15], W8
001080  060000     RETURN
249:               
250:               text_coord_t get_curpos(){
251:                   text_coord_t cpos;
252:                   cpos.x = cx/CHAR_WIDTH;
001082  80F8F5     MOV cx, W5
001084  200064     MOV #0x6, W4
001086  781F80     MOV W0, [W15++]
001088  090011     REPEAT #0x11
00108A  D88284     DIV.UW W5, W4
00108C  780200     MOV W0, W4
00108E  78004F     MOV [--W15], W0
001090  780804     MOV W4, [W0]
253:                   cpos.y = cy/CHAR_HEIGHT;
001092  80F904     MOV cy, W4
001094  DE2243     LSR W4, #3, W4
001096  980014     MOV W4, [W0+2]
254:                   return cpos;
255:               } // get_cursor_pos()
001098  060000     RETURN
256:               
257:               void set_curpos(unsigned short x, unsigned short y){// {x,y} character coord.
258:                   if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
00109A  200224     MOV #0x22, W4
00109C  500F84     SUB W0, W4, [W15]
00109E  3E0006     BRA GTU, 0x10AC
0010A0  508FFA     SUB W1, #0x1A, [W15]
0010A2  3E0004     BRA GTU, 0x10AC
259:                       return;
260:                   cx=x*CHAR_WIDTH;
0010A4  B90266     MUL.SU W0, #6, W4
0010A6  88F8F4     MOV W4, cx
261:                   cy=y*CHAR_HEIGHT;
0010A8  DD08C3     SL W1, #3, W1
0010AA  88F901     MOV W1, cy
262:               }//set_curpos()
0010AC  060000     RETURN
263:               
264:               void invert_char(void){// invert pixels of character at cursor position
0010AE  BE9F88     MOV.D W8, [W15++]
0010CA  E80287     INC W7, W5
0010CC  B93C7B     MUL.SU W7, #27, W8
0010CE  420008     ADD W4, W8, W0
0010D0  208004     MOV #0x800, W4
0010D2  400204     ADD W0, W4, W4
0010D4  4383EA     ADD W7, #0xA, W7
265:                   register int i,l,r,b,x,y;
266:                   x=cx;
0010B0  80F8F1     MOV cx, W1
267:                   y=cy;
0010B2  80F907     MOV cy, W7
268:                   b=x>>3;
0010B4  DE8A43     ASR W1, #3, W4
269:                   r=0;
270:                   l=(8-CHAR_WIDTH)-(x&7);
0010B6  6080E7     AND W1, #0x7, W1
0010B8  1080E2     SUBR W1, #0x2, W1
271:                   if (l<0){
272:                       r=-l;
0010BA  DE8ACF     ASR W1, #15, W5
0010BC  EA0301     NEG W1, W6
0010BE  630305     AND W6, W5, W6
273:                   }
274:                   for (i=9;i;i--){
0010EA  528F87     SUB W5, W7, [W15]
0010EC  3AFFF4     BRA NZ, 0x10D6
275:                       if (r){
0010D6  530FE0     SUB W6, #0x0, [W15]
0010D8  320005     BRA Z, 0x10E4
276:                           video_buffer[y][b] ^= (0x3f>>r);
0010C0  2003F5     MOV #0x3F, W5
0010C2  DEA986     ASR W5, W6, W3
0010DA  69CA14     XOR.B W3, [W4], [W4]
277:                           video_buffer[y][b+1] ^= (0x3f<<(8-r));
0010C4  130168     SUBR W6, #0x8, W2
0010C6  DD2902     SL W5, W2, W2
0010DC  904014     MOV.B [W4+1], W0
0010DE  684002     XOR.B W0, W2, W0
0010E0  984210     MOV.B W0, [W4+1]
0010E2  370001     BRA 0x10E6
278:                           y++;
279:                       } else{
280:                           video_buffer[y++][b] ^= (0x3f<<l);
0010C8  DD2881     SL W5, W1, W1
0010E4  68CA14     XOR.B W1, [W4], [W4]
0010E6  E80285     INC W5, W5
0010E8  42027B     ADD W4, #0x1B, W4
281:                       }
282:                   }
283:               }//invert_char()
0010EE  BE044F     MOV.D [--W15], W8
0010F0  060000     RETURN
284:               
285:               static void toggle_underscore(void){
286:                   register int l,r,b,x;
287:                   x=cx;
000DAA  80F8F4     MOV cx, W4
288:                   b=x>>5;
000DAC  DEA2C5     ASR W4, #5, W5
289:                   r=0;
290:                   l=(8-CHAR_WIDTH)-(x&7);
000DAE  620267     AND W4, #0x7, W4
000DB0  120262     SUBR W4, #0x2, W4
291:                   if (l<0){
000DB2  3B0014     BRA NN, 0xDDC
292:                       r=-l;
000DB4  EA0304     NEG W4, W6
293:                   }
294:                   if (r){
000DB6  320012     BRA Z, 0xDDC
295:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
000DB8  80F900     MOV cy, W0
000DBA  400067     ADD W0, #0x7, W0
000DBC  208004     MOV #0x800, W4
000DBE  B9007B     MUL.SU W0, #27, W0
000DC0  400085     ADD W0, W5, W1
000DC2  420101     ADD W4, W1, W2
000DC4  2003F7     MOV #0x3F, W7
000DC6  DEB986     ASR W7, W6, W3
000DC8  78C0E4     MOV.B [W4+W1], W1
000DCA  68C903     XOR.B W1, W3, [W2]
296:                       video_buffer[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<(8-r));
000DCC  E80285     INC W5, W5
000DCE  400285     ADD W0, W5, W5
000DD0  420005     ADD W4, W5, W0
000DD2  130368     SUBR W6, #0x8, W6
000DD4  DD3B86     SL W7, W6, W7
000DD6  7AC264     MOV.B [W4+W5], W4
000DD8  6A4807     XOR.B W4, W7, [W0]
000DDA  37000A     BRA 0xDF0
297:                   } else{
298:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
000DDC  80F900     MOV cy, W0
000DDE  400067     ADD W0, #0x7, W0
000DE0  208006     MOV #0x800, W6
000DE2  B9007B     MUL.SU W0, #27, W0
000DE4  428280     ADD W5, W0, W5
000DE6  430385     ADD W6, W5, W7
000DE8  2003F0     MOV #0x3F, W0
000DEA  DD0204     SL W0, W4, W4
000DEC  7AC2E6     MOV.B [W6+W5], W5
000DEE  6ACB84     XOR.B W5, W4, [W7]
299:                   }
300:               }//toggle_underscore()
000DF0  060000     RETURN
301:               
302:               void show_cursor(BOOL show){
0010F2  781F88     MOV W8, [W15++]
303:                   if (show){
0010F4  500FE0     SUB W0, #0x0, [W15]
0010F6  32000B     BRA Z, 0x110E
304:                       flags |= CUR_SHOW;
0010F8  80F8D4     MOV flags, W4
0010FA  A00004     BSET W4, #0
305:                       flags ^= CUR_VIS;
0010FC  A21004     BTG W4, #1
0010FE  88F8D4     MOV W4, flags
306:                       if (cur_shape==CR_BLOCK){
001100  80F8E4     MOV cur_shape, W4
001102  520FE1     SUB W4, #0x1, [W15]
001104  3A0002     BRA NZ, 0x110A
307:                           invert_char();
001106  07FFD3     RCALL invert_char
001108  37000E     BRA 0x1126
308:                       }else{
309:                           toggle_underscore();
00110A  07FE4F     RCALL toggle_underscore
00110C  37000C     BRA 0x1126
310:                       }
311:                   }else{
312:                       if (flags & CUR_VIS){
00110E  80F8D8     MOV flags, W8
001110  640262     AND W8, #0x2, W4
001112  320008     BRA Z, 0x1124
313:                           if (cur_shape==CR_BLOCK){
001114  80F8E4     MOV cur_shape, W4
001116  520FE1     SUB W4, #0x1, [W15]
001118  3A0002     BRA NZ, 0x111E
314:                               invert_char();
00111A  07FFC9     RCALL invert_char
00111C  370001     BRA 0x1120
315:                           }else{
316:                               toggle_underscore();
00111E  07FE45     RCALL toggle_underscore
317:                           }
318:                           flags &= ~CUR_VIS;
001120  A11008     BCLR W8, #1
001122  88F8D8     MOV W8, flags
319:                       }
320:                       flags &= ~CUR_SHOW;
001124  A91F1A     BCLR flags, #0
321:                   }
322:               
323:               }// show_cursor()
001126  78044F     MOV [--W15], W8
001128  060000     RETURN
324:               
325:               void set_cursor(cursor_t shape){
00112A  781F88     MOV W8, [W15++]
00112C  780400     MOV W0, W8
326:                   if (flags & CUR_VIS){
00112E  AB3F1A     BTST flags, #1
001130  320006     BRA Z, 0x113E
327:                       show_cursor(FALSE);
001132  EB0000     CLR W0
001134  07FFDE     RCALL show_cursor
328:                       cur_shape=shape;
001136  88F8E8     MOV W8, cur_shape
329:                       show_cursor(TRUE);
001138  200010     MOV #0x1, W0
00113A  07FFDB     RCALL show_cursor
00113C  370001     BRA 0x1140
330:                   }else{
331:                       cur_shape=shape;
00113E  88F8E8     MOV W8, cur_shape
332:                   }
333:               }// set_cursor()
001140  78044F     MOV [--W15], W8
001142  060000     RETURN
334:               
335:               
336:               void invert_video(){
337:                   flags |= INV_VID;
001144  A85F1A     BSET flags, #2
338:               }//invert_video()
001146  060000     RETURN
339:               
340:               void normal_video(){
341:                   flags &= ~INV_VID;
001148  A95F1A     BCLR flags, #2
342:               }//normal_video()
00114A  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/sound.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   sound.c
21:                 * Author: jacques Deschênes
22:                 * Description:  sound generation using PWM D.A.C.
23:                 * Created on 25 février 2014, 16:43
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include "sound.h"
28:                
29:                #define F_TONE  1  // tone playing flag
30:                #define F_TUNE  2  // flag tune playing
31:                #define F_WHITE 4  // white noise generation
32:                
33:                #define mTone_off() (AUDIOCON.OCM=0)
34:                #define mTone_on()  (AUDIOCON.OCM=5)
35:                
36:                
37:                volatile unsigned char fSound=0; // boolean flags
38:                volatile int tmrId;  // duratio timer identifier
39:                volatile unsigned int *tones_list;  // list of tones and interval for playing tune
40:                int tick_msec=10; // tick interval in milliseconds, default 10msec.
41:                
42:                void cb_tone(void){ // timer call back function
43:                    mTone_off();
0014B2  800C54     MOV OC2CON, W4
0014B4  A10004     BCLR W4, #0
0014B6  A11004     BCLR W4, #1
0014B8  A12004     BCLR W4, #2
0014BA  880C54     MOV W4, OC2CON
44:                    fSound &= ~(F_TONE|F_WHITE);
0014BC  21F225     MOV #0x1F22, W5
0014BE  784295     MOV.B [W5], W5
0014C0  B3CFA4     MOV #0xFA, W4
0014C2  62C204     AND.B W5, W4, W4
0014C4  780004     MOV W4, W0
0014C6  B7FF22     MOV.B WREG, fSound
45:                }// f()
0014C8  060000     RETURN
46:                
47:                void sound_init(int tick_time){
48:                    if (tick_time) tick_msec=tick_time;
0014CA  500FE0     SUB W0, #0x0, [W15]
0014CC  320001     BRA Z, 0x14D0
0014CE  88F920     MOV W0, tick_msec
49:                    tmrId=create_timer(1,TIMER_SINGLE,(timer_handler_t *)cb_tone);
0014D0  214B22     MOV #0x14B2, W2
0014D2  EB0080     CLR W1
0014D4  200010     MOV #0x1, W0
0014D6  07FE8C     RCALL create_timer
0014D8  88F930     MOV W0, tmrId
50:                    AUDIOCON.OCTSEL=1; // select OCx timer
0014DA  A8618A     BSET OC2CON, #3
51:                    AUDIOR=0;
0014DC  EF2188     CLR OC2R
52:                    AUDIOTMR.TON=0;
0014DE  A9E113     BCLR 0x113, #7
53:                    AUDIOTMR.TCKPS=1; // 1:8  // timer clock prescale divisor
0014E0  800894     MOV T3CON, W4
0014E2  A04004     BSET W4, #4
0014E4  A15004     BCLR W4, #5
0014E6  880894     MOV W4, T3CON
54:                }//f()
0014E8  060000     RETURN
55:                
56:                // play tone in background
57:                void tone(unsigned freq, // frequency in hertz
58:                          unsigned msec){ // duration in  milliseconds
0014EA  BE9F88     MOV.D W8, [W15++]
0014EC  781F8A     MOV W10, [W15++]
0014EE  780501     MOV W1, W10
59:                    //
60:                    mTone_off(); 
0014F0  800C54     MOV OC2CON, W4
0014F2  A10004     BCLR W4, #0
0014F4  A11004     BCLR W4, #1
0014F6  A12004     BCLR W4, #2
0014F8  880C54     MOV W4, OC2CON
61:                    AUDIORS=FCY/16/freq; // determine tone duty cycle
0014FA  B80461     MUL.UU W0, #1, W8
0014FC  BE0108     MOV.D W8, W2
0014FE  242400     MOV #0x4240, W0
001500  2000F1     MOV #0xF, W1
001502  07F7D5     RCALL 0x4AE
001504  880C30     MOV W0, OC2RS
62:                    AUDIOTMR.TON=0;
001506  A9E113     BCLR 0x113, #7
63:                    AUDIOPR=(FCY/8/freq)-1; // pwm period
001508  BE0108     MOV.D W8, W2
00150A  284800     MOV #0x8480, W0
00150C  2001E1     MOV #0x1E, W1
00150E  07F7CF     RCALL 0x4AE
001510  E90200     DEC W0, W4
001512  880874     MOV W4, PR3
64:                    fSound |=F_TONE;
001514  A81F22     BSET fSound, #0
65:                    mTone_on(); 
001516  800C54     MOV OC2CON, W4
001518  A00004     BSET W4, #0
00151A  A11004     BCLR W4, #1
00151C  A02004     BSET W4, #2
00151E  880C54     MOV W4, OC2CON
66:                    AUDIOTMR.TON=1;
001520  A8E113     BSET 0x113, #7
67:                    update_timer(tmrId,msec/tick_msec);
001522  80F930     MOV tmrId, W0
001524  80F924     MOV tick_msec, W4
001526  781F80     MOV W0, [W15++]
001528  090011     REPEAT #0x11
00152A  D88504     DIV.UW W10, W4
00152C  780080     MOV W0, W1
00152E  78004F     MOV [--W15], W0
001530  07FEA4     RCALL update_timer
68:                    start_timer(tmrId);
001532  80F930     MOV tmrId, W0
001534  07FE90     RCALL start_timer
69:                } //tone();
001536  78054F     MOV [--W15], W10
001538  BE044F     MOV.D [--W15], W8
00153A  060000     RETURN
70:                
71:                // play tune in background
72:                void tune(const unsigned *buffer){
73:                    tones_list=(unsigned *)buffer;
00153C  88F940     MOV W0, tones_list
74:                    if (*tones_list && *(tones_list+1)){
00153E  EB0200     CLR W4
001540  120F90     SUBR W4, [W0], [W15]
001542  32000C     BRA Z, 0x155C
001544  780200     MOV W0, W4
001546  EB0280     CLR W5
001548  128FD4     SUBR W5, [++W4], [W15]
00154A  320008     BRA Z, 0x155C
75:                        fSound |= F_TUNE;
00154C  A83F22     BSET fSound, #1
76:                        AUDIOIF=0;
00154E  A90085     BCLR 0x85, #0
77:                        AUDIOIE=1;
001550  A80095     BSET 0x95, #0
78:                        tone(*tones_list++,*tones_list++);
001552  780090     MOV [W0], W1
001554  88F944     MOV W4, tones_list
001556  780034     MOV [W4++], W0
001558  88F944     MOV W4, tones_list
00155A  07FFC7     RCALL tone
79:                    }
80:                }//tune()
00155C  060000     RETURN
81:                
82:                
83:                void white_noise(unsigned msec){
84:                    if (!fSound){
00155E  21F224     MOV #0x1F22, W4
001560  784214     MOV.B [W4], W4
001562  524FE0     SUB.B W4, #0x0, [W15]
001564  3A0010     BRA NZ, 0x1586
85:                        AUDIOTMR.TON=0;
001566  A9E113     BCLR 0x113, #7
86:                        AUDIOPR=(FCY/8/10000)-1; // pwm period
001568  200C74     MOV #0xC7, W4
00156A  880874     MOV W4, PR3
87:                        AUDIOTMR.TON=0;
00156C  A9E113     BCLR 0x113, #7
88:                        AUDIOIF=0;
00156E  A90085     BCLR 0x85, #0
89:                        AUDIOIE=1;
001570  A80095     BSET 0x95, #0
90:                        AUDIOTMR.TON=1;
001572  A8E113     BSET 0x113, #7
91:                        update_timer(tmrId,msec/tick_msec);
001574  80F934     MOV tmrId, W4
001576  80F925     MOV tick_msec, W5
001578  090011     REPEAT #0x11
00157A  D88005     DIV.UW W0, W5
00157C  FD0080     EXCH W0, W1
00157E  780004     MOV W4, W0
001580  07FE7C     RCALL update_timer
92:                        start_timer(tmrId);
001582  80F930     MOV tmrId, W0
001584  07FE68     RCALL start_timer
93:                    }
94:                    fSound |= F_WHITE;
001586  A85F22     BSET fSound, #2
95:                }// f()
001588  060000     RETURN
96:                
97:                void while_sound(){
98:                    while (fSound);
00158A  21F224     MOV #0x1F22, W4
00158C  784214     MOV.B [W4], W4
00158E  524FE0     SUB.B W4, #0x0, [W15]
001590  3AFFFC     BRA NZ, while_sound
99:                }// f()
001592  060000     RETURN
100:               
101:               // interrupt at end of tone cycle
102:               void __attribute__((interrupt, no_auto_psv))  _AUDIO_ISR(void){
001594  F80036     PUSH RCOUNT
001596  BE9F80     MOV.D W0, [W15++]
001598  BE9F82     MOV.D W2, [W15++]
00159A  BE9F84     MOV.D W4, [W15++]
00159C  BE9F86     MOV.D W6, [W15++]
103:                  unsigned int f,d;
104:                  if (fSound&F_WHITE){
00159E  21F224     MOV #0x1F22, W4
0015A0  784214     MOV.B [W4], W4
0015A2  620264     AND W4, #0x4, W4
0015A4  320007     BRA Z, 0x15B4
105:                      P_NOISE_OUT=rand()&1;
0015A6  07F7EA     RCALL 0x57C
0015A8  6002E1     AND W0, #0x1, W5
0015AA  DD2ACA     SL W5, #10, W5
0015AC  801664     MOV LATB, W4
0015AE  A1A004     BCLR W4, #10
0015B0  720205     IOR W4, W5, W4
0015B2  881664     MOV W4, LATB
106:                  }
107:                  if (!fSound) {
0015B4  21F224     MOV #0x1F22, W4
0015B6  784214     MOV.B [W4], W4
0015B8  524FE0     SUB.B W4, #0x0, [W15]
0015BA  3A0003     BRA NZ, 0x15C2
108:                      AUDIOIE=0;
0015BC  A90095     BCLR 0x95, #0
109:                      AUDIOTMR.TON=0;
0015BE  A9E113     BCLR 0x113, #7
0015C0  370027     BRA 0x1610
110:                  }else if (fSound==(fSound & F_TUNE)){
0015C2  21F225     MOV #0x1F22, W5
0015C4  784295     MOV.B [W5], W5
0015C6  21F224     MOV #0x1F22, W4
0015C8  784214     MOV.B [W4], W4
0015CA  FB8285     ZE W5, W5
0015CC  620262     AND W4, #0x2, W4
0015CE  528F84     SUB W5, W4, [W15]
0015D0  3A001F     BRA NZ, 0x1610
111:                      f=*tones_list++;
0015D2  80F944     MOV tones_list, W4
0015D4  780034     MOV [W4++], W0
0015D6  88F944     MOV W4, tones_list
112:                      d=*tones_list++;
0015D8  7800B4     MOV [W4++], W1
0015DA  88F944     MOV W4, tones_list
113:                      if (d){
0015DC  508FE0     SUB W1, #0x0, [W15]
0015DE  320015     BRA Z, 0x160A
114:                           if (f){
0015E0  500FE0     SUB W0, #0x0, [W15]
0015E2  320002     BRA Z, 0x15E8
115:                               tone(f,d);
0015E4  07FF82     RCALL tone
0015E6  370014     BRA 0x1610
116:                           }else{
117:                               update_timer(tmrId,d/tick_msec);
0015E8  80F930     MOV tmrId, W0
0015EA  80F924     MOV tick_msec, W4
0015EC  781F80     MOV W0, [W15++]
0015EE  090011     REPEAT #0x11
0015F0  D88084     DIV.UW W1, W4
0015F2  780080     MOV W0, W1
0015F4  78004F     MOV [--W15], W0
0015F6  07FE41     RCALL update_timer
118:                               start_timer(tmrId);
0015F8  80F930     MOV tmrId, W0
0015FA  07FE2D     RCALL start_timer
119:                               fSound |= F_TONE;
0015FC  A81F22     BSET fSound, #0
120:                               mTone_on();
0015FE  800C54     MOV OC2CON, W4
001600  A00004     BSET W4, #0
001602  A11004     BCLR W4, #1
001604  A02004     BSET W4, #2
001606  880C54     MOV W4, OC2CON
001608  370003     BRA 0x1610
121:                           }
122:                      }else{
123:                          fSound=0;
00160A  EF7F22     CLR.B fSound
124:                          AUDIOIE=0;
00160C  A90095     BCLR 0x95, #0
125:                          AUDIOTMR.TON=0;
00160E  A9E113     BCLR 0x113, #7
126:                      } // if
127:                  }
128:                  AUDIOIF=0;
001610  A90085     BCLR 0x85, #0
129:               }// _AUDIO_ISR
001612  BE034F     MOV.D [--W15], W6
001614  BE024F     MOV.D [--W15], W4
001616  BE014F     MOV.D [--W15], W2
001618  BE004F     MOV.D [--W15], W0
00161A  F90036     POP RCOUNT
00161C  064000     RETFIE
130:               
131:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snes_paddle.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snes_paddle.c
21:                 * Author: jacques Deschênes
22:                 * Description:  SNES gemepad interface
23:                 *              1) a pulse on paddle latch input store last switches state in shift register
24:                 *              2) each rising edge of clock signal shift one bit out, bit 0 first.
25:                 *                 bit 0 is at output after latch so there is only 15 shift to do.
26:                 * Created on 25 février 2014, 16:41
27:                 */
28:                
29:                #include <stdlib.h>
30:                #include "snes_paddle.h"
31:                //#include "TVout.h"
32:                
33:                
34:                
35:                // the loop execute in 4 Tcy
36:                #define mDelay(usec) __asm__("MOV #%0,W4\n NOP\n DEC W4,W4\n BRA NZ .-4"::"i"(usec))
37:                
38:                void latch(){
39:                    P_PDL_LATCH=1;
001698  A822CC     BSET LATB, #1
40:                    mDelay(CYCLES_PER_USEC/4);
00169A  200044     MOV #0x4, W4
00169C  000000     NOP
00169E  E90204     DEC W4, W4
0016A0  3AFFFD     BRA NZ, 0x169C
41:                    P_PDL_LATCH=0;
0016A2  A922CC     BCLR LATB, #1
42:                    mDelay(CYCLES_PER_USEC/4);
0016A4  200044     MOV #0x4, W4
0016A6  000000     NOP
0016A8  E90204     DEC W4, W4
0016AA  3AFFFD     BRA NZ, 0x16A6
43:                }//f()
0016AC  060000     RETURN
44:                
45:                void bit_shift(){
46:                    P_PDL_CLK=1;
0016AE  A802CC     BSET LATB, #0
47:                    mDelay(CYCLES_PER_USEC/4);
0016B0  200044     MOV #0x4, W4
0016B2  000000     NOP
0016B4  E90204     DEC W4, W4
0016B6  3AFFFD     BRA NZ, 0x16B2
48:                    P_PDL_CLK=0;
0016B8  A902CC     BCLR LATB, #0
49:                    mDelay(CYCLES_PER_USEC/4);
0016BA  200044     MOV #0x4, W4
0016BC  000000     NOP
0016BE  E90204     DEC W4, W4
0016C0  3AFFFD     BRA NZ, 0x16BC
50:                }// f()
0016C2  060000     RETURN
51:                
52:                unsigned read_paddle(int paddleId) {
0016C4  BE9F88     MOV.D W8, [W15++]
0016C6  BE9F8A     MOV.D W10, [W15++]
0016C8  BE9F8C     MOV.D W12, [W15++]
0016CA  780680     MOV W0, W13
53:                    unsigned i,pdata, p1,p2;
54:                    p1=0;
0016D0  780509     MOV W9, W10
55:                    p2=0;
0016CE  EB0480     CLR W9
56:                    latch(); // latch data in paddles shift register
0016CC  07FFE5     RCALL latch
57:                    // shift out is least significant bit first.
58:                    for (i=0;i<15;i++){ // SNES paddle have 16 bits shift register
0016D2  780409     MOV W9, W8
0016EC  E80408     INC W8, W8
0016EE  540FEF     SUB W8, #0xF, [W15]
0016F0  3AFFF3     BRA NZ, 0x16D8
59:                        pdata=PADDLES_DATA_PORT;
0016D8  801614     MOV PORTA, W4
60:                        p1 |= (pdata&PADDLE1)<<i;
0016DA  6202E1     AND W4, #0x1, W5
0016DC  DD2A88     SL W5, W8, W5
0016DE  750505     IOR W10, W5, W10
61:                        p2 |= (pdata&PADDLE2)?1<<i:0;
0016D4  EB0580     CLR W11
0016D6  20001C     MOV #0x1, W12
0016E0  620262     AND W4, #0x2, W4
0016E2  78028B     MOV W11, W5
0016E4  320001     BRA Z, 0x16E8
0016E6  DD6288     SL W12, W8, W5
0016E8  748485     IOR W9, W5, W9
62:                        bit_shift();
0016EA  07FFE1     RCALL bit_shift
63:                    }
64:                    return paddleId==1?(~p1)&0xfff:(~p2)&0xfff;
0016F2  568FE1     SUB W13, #0x1, [W15]
0016F4  3A0004     BRA NZ, 0x16FE
0016F6  EA800A     COM W10, W0
0016F8  20FFF4     MOV #0xFFF, W4
0016FA  600004     AND W0, W4, W0
0016FC  370003     BRA 0x1704
0016FE  EA8009     COM W9, W0
001700  20FFF4     MOV #0xFFF, W4
001702  600004     AND W0, W4, W0
65:                }//f()
001704  BE064F     MOV.D [--W15], W12
001706  BE054F     MOV.D [--W15], W10
001708  BE044F     MOV.D [--W15], W8
00170A  060000     RETURN
66:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/hardwareProfile.c  ------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   hardwareProfile.h
21:                 * Author: jacques Deschênes
22:                 * Description:  try to centralize  hardware specific.
23:                 * Created on 1 march 2014
24:                 */
25:                
26:                #include "hardwareProfile.h"
27:                
28:                void HardwareConfig(){
29:                    // peripheral to pin association.
30:                    PPSUnLock;
00161E  803A16     MOV OSCCON, W6
001620  B20BF6     AND #0xBF, W6
001622  200464     MOV #0x46, W4
001624  200575     MOV #0x57, W5
001626  207427     MOV #0x742, W7
001628  784B84     MOV.B W4, [W7]
00162A  784B85     MOV.B W5, [W7]
00162C  784B86     MOV.B W6, [W7]
31:                    PPSOutput(PPS_RP5,PPS_SDO1);   // video pixels output
00162E  803626     MOV RPOR2, W6
001630  2E0FF7     MOV #0xE0FF, W7
001632  630307     AND W6, W7, W6
001634  207000     MOV #0x700, W0
001636  730300     IOR W6, W0, W6
001638  883626     MOV W6, RPOR2
32:                    PPSOutput(PPS_RP6,PPS_OC4);  // video delay output
00163A  803630     MOV RPOR3, W0
00163C  2FFE06     MOV #0xFFE0, W6
00163E  600006     AND W0, W6, W0
001640  B30150     IOR #0x15, W0
001642  883630     MOV W0, RPOR3
33:                    PPSOutput(PPS_RP7,PPS_OC1);  // video sync output
001644  803630     MOV RPOR3, W0
001646  600387     AND W0, W7, W7
001648  212000     MOV #0x1200, W0
00164A  738380     IOR W7, W0, W7
00164C  883637     MOV W7, RPOR3
34:                    PPSOutput(PPS_RP8,PPS_OC2);  // audio output
00164E  803647     MOV RPOR4, W7
001650  638306     AND W7, W6, W6
001652  B30136     IOR #0x13, W6
001654  883646     MOV W6, RPOR4
35:                    PPSLock;
001656  803A16     MOV OSCCON, W6
001658  A06006     BSET W6, #6
00165A  207427     MOV #0x742, W7
00165C  784B84     MOV.B W4, [W7]
00165E  784B85     MOV.B W5, [W7]
001660  784B86     MOV.B W6, [W7]
36:                    // pins data direction
37:                    P_PIXEL_OUT_TRIS=0;     // video pixels output
001662  A9A2C8     BCLR TRISB, #5
38:                    P_VDLY_OUT_TRIS=0;     // video delay output
001664  A9C2C8     BCLR TRISB, #6
39:                    P_VSYNC_OUT_TRIS=0;     // video sync output
001666  A9E2C8     BCLR TRISB, #7
40:                    P_AUDIO_OUT_TRIS=0;     // audio output
001668  A902C9     BCLR 0x2C9, #0
41:                    P_NOISE_OUT_TRIS=0;     /// white noise output
00166A  A942C9     BCLR 0x2C9, #2
42:                    P_PIXDLY_IN_TRIS=1;     //input video pixels delay
00166C  A822C9     BSET 0x2C9, #1
43:                    P_VIDEO_MODE_TRIS=1;    //input NTSC/PAL select input
00166E  A882C9     BSET 0x2C9, #4
44:                    VIDMODE_ANDIS=1;   // disable ADC  on NTSC/PAL select input.
001670  A8832D     BSET 0x32D, #4
45:                    // paddles interface I/O setting
46:                    P_PDL1_DAT_TRIS=1;      // paddle 1 data as input
001672  A802C0     BSET TRISA, #0
47:                    P_PDL2_DAT_TRIS=1;      // paddle 2 data as input
001674  A822C0     BSET TRISA, #1
48:                    P_PDL_CLK_TRIS=0;       // paddles clock signal as output
001676  A902C8     BCLR TRISB, #0
49:                    P_PDL_LATCH_TRIS=0;     // paddles latch signal as output
001678  A922C8     BCLR TRISB, #1
50:                    P_PDL1_ANDIS=1;         // disable analog input
00167A  A8032C     BSET AD1PCFG, #0
51:                    P_PDL2_ANDIS=1;         // disable analog input
00167C  A8232C     BSET AD1PCFG, #1
52:                    // interrupts priorities
53:                    VSYNCIP=7;  // timer interrupt used for video output must have highest priority
00167E  270000     MOV #0x7000, W0
001680  B720A6     IOR IPC1
54:                    PIXIP=7;  // change notification interrupt used for video pixels must have highest priority
001682  B720AC     IOR IPC4
55:                    AUDIOIP=3; // audio output timer interrupt priority
001684  800544     MOV IPC2, W4
001686  B30034     IOR #0x3, W4
001688  A12004     BCLR W4, #2
00168A  880544     MOV W4, IPC2
56:                    SYSTICKIP=2; // system ticks timer interrupt priority
00168C  800524     MOV IPC0, W4
00168E  A1C004     BCLR W4, #12
001690  A0D004     BSET W4, #13
001692  A1E004     BCLR W4, #14
001694  880524     MOV W4, IPC0
57:                }//f()
001696  060000     RETURN
58:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/graphics.c  -------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   graphics.h
21:                 * Author: jacques Deschênes
22:                 * Description: Draw geometrics figures.
23:                 *      coordinates origin is screen top,left, x increase to right, y increase to bottom
24:                 * Created on 28 février 2014, 13:07
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "graphics.h"
29:                
30:                // draw a dot
31:                
32:                void plot(int x, int y, int color){
33:                    int h,ofs;
34:                    if ((y>=VPIXELS)||(x>=HPIXELS)) return; // bound check
0008F8  200D74     MOV #0xD7, W4
0008FA  508F84     SUB W1, W4, [W15]
0008FC  3C0028     BRA GT, 0x94E
0008FE  500F84     SUB W0, W4, [W15]
000900  3C0026     BRA GT, 0x94E
35:                    h= x/8;
000902  200084     MOV #0x8, W4
000904  781F81     MOV W1, [W15++]
000906  090011     REPEAT #0x11
000908  D80004     DIV.SW W0, W4
00090A  780201     MOV W1, W4
00090C  7800CF     MOV [--W15], W1
36:                    ofs = 7 - x%8;
00090E  1202E7     SUBR W4, #0x7, W5
37:                    if (color==INVERT)
000910  510FE2     SUB W2, #0x2, [W15]
000912  3A0009     BRA NZ, 0x926
38:                        video_buffer[y][h] ^= (1<<ofs);
000914  208006     MOV #0x800, W6
000916  B9097B     MUL.SU W1, #27, W2
000918  400082     ADD W0, W2, W1
00091A  430381     ADD W6, W1, W7
00091C  200014     MOV #0x1, W4
00091E  DD2285     SL W4, W5, W5
000920  78C266     MOV.B [W6+W1], W4
000922  6A4B85     XOR.B W4, W5, [W7]
000924  370014     BRA 0x94E
39:                    else if (color==WHITE)
000926  510FE1     SUB W2, #0x1, [W15]
000928  3A0009     BRA NZ, 0x93C
40:                        video_buffer[y][h]|= (1<<ofs);
00092A  208006     MOV #0x800, W6
00092C  B9097B     MUL.SU W1, #27, W2
00092E  400082     ADD W0, W2, W1
000930  430381     ADD W6, W1, W7
000932  200014     MOV #0x1, W4
000934  DD2285     SL W4, W5, W5
000936  78C266     MOV.B [W6+W1], W4
000938  724B85     IOR.B W4, W5, [W7]
00093A  370009     BRA 0x94E
41:                    else
42:                        video_buffer[y][h]&= ~(1<<ofs);
00093C  208006     MOV #0x800, W6
00093E  B9097B     MUL.SU W1, #27, W2
000940  400082     ADD W0, W2, W1
000942  430381     ADD W6, W1, W7
000944  200014     MOV #0x1, W4
000946  DD2285     SL W4, W5, W5
000948  EAC285     COM.B W5, W5
00094A  78C366     MOV.B [W6+W1], W6
00094C  62CB86     AND.B W5, W6, [W7]
43:                } // plot()
00094E  060000     RETURN
44:                
45:                // dessine une droite en utilisant l'algorithme de Bresenham
46:                void line(int x1, int y1, int x2, int y2, int color){
000950  4787EA     ADD W15, #0xA, W15
000952  BE9F88     MOV.D W8, [W15++]
000954  BE9F8A     MOV.D W10, [W15++]
000956  BE9F8C     MOV.D W12, [W15++]
000958  781F8E     MOV W14, [W15++]
00095A  780400     MOV W0, W8
00095C  780501     MOV W1, W10
00095E  780582     MOV W2, W11
000960  9FB7F3     MOV W3, [W15-18]
000962  780604     MOV W4, W12
000978  448408     ADD W9, W8, W8
00097A  370004     BRA 0x984
00098E  540209     SUB W8, W9, W4
0009A4  44850A     ADD W9, W10, W10
0009B0  550209     SUB W10, W9, W4
47:                    int deltax,deltay;
48:                    plot(x1,y1,color);
000964  78010C     MOV W12, W2
000966  78008A     MOV W10, W1
000968  780008     MOV W8, W0
00096A  07FFC6     RCALL plot
49:                    if (y1==y2){// cas particulier ligne horizontale
00096C  97B27F     MOV [W15-18], W4
00096E  550F84     SUB W10, W4, [W15]
000970  3A0012     BRA NZ, 0x996
50:                        deltax= x1<x2?1:-1;
000972  540F8B     SUB W8, W11, [W15]
000974  3D0003     BRA GE, 0x97C
000976  200019     MOV #0x1, W9
00097C  EB8480     SETM W9
51:                        while (x1!=x2){
00097E  540F8B     SUB W8, W11, [W15]
000980  3AFFFB     BRA NZ, 0x978
000982  37004B     BRA 0xA1A
000990  558F84     SUB W11, W4, [W15]
000992  3AFFF8     BRA NZ, 0x984
000994  370042     BRA 0xA1A
52:                            x1 += deltax;
53:                            plot(x1,y1,color);
000984  78010C     MOV W12, W2
000986  78008A     MOV W10, W1
000988  780008     MOV W8, W0
00098A  07FFB6     RCALL plot
00098C  440409     ADD W8, W9, W8
54:                        }
55:                    }else if (x1==x2){ // cas particulier ligne verticale
000996  540F8B     SUB W8, W11, [W15]
000998  3A0010     BRA NZ, 0x9BA
56:                        deltay= y1<y2?1:-1;
00099A  EB8480     SETM W9
00099C  97B2FF     MOV [W15-18], W5
00099E  550F85     SUB W10, W5, [W15]
0009A0  3D0001     BRA GE, 0x9A4
0009A2  200019     MOV #0x1, W9
57:                        while (y1!=y2){
0009B2  97B2FF     MOV [W15-18], W5
0009B4  528F84     SUB W5, W4, [W15]
0009B6  3AFFF7     BRA NZ, 0x9A6
0009B8  370030     BRA 0xA1A
58:                            y1+=deltay;
59:                            plot(x1,y1,color);
0009A6  78010C     MOV W12, W2
0009A8  78008A     MOV W10, W1
0009AA  780008     MOV W8, W0
0009AC  07FFA5     RCALL plot
0009AE  450509     ADD W10, W9, W10
60:                        }
61:                    }else{
62:                        int sx,sy,err,e2;
63:                        deltax=abs(x2-x1);
0009BA  558708     SUB W11, W8, W14
0009BC  A7F00E     BTSC W14, #15
0009BE  EA070E     NEG W14, W14
64:                        deltay=abs(y2-y1);
0009C0  97B2FF     MOV [W15-18], W5
0009C2  52820A     SUB W5, W10, W4
0009C4  A7F004     BTSC W4, #15
0009C6  EA0204     NEG W4, W4
0009C8  9FBF84     MOV W4, [W15-16]
65:                        sx = x1<x2?1:-1;
0009CA  EB8200     SETM W4
0009CC  9FB7E4     MOV W4, [W15-20]
0009CE  540F8B     SUB W8, W11, [W15]
0009D0  3D0002     BRA GE, 0x9D6
0009D2  200015     MOV #0x1, W5
0009D4  9FB7E5     MOV W5, [W15-20]
66:                        sy = y1<y2?1:-1;
0009D6  EB8200     SETM W4
0009D8  9FB7D4     MOV W4, [W15-22]
0009DA  97B2FF     MOV [W15-18], W5
0009DC  550F85     SUB W10, W5, [W15]
0009DE  3D0002     BRA GE, 0x9E4
0009E0  200014     MOV #0x1, W4
0009E2  9FB7D4     MOV W4, [W15-22]
67:                        err=deltax-deltay;
0009E4  97BA8F     MOV [W15-16], W5
0009E6  570485     SUB W14, W5, W9
68:                        while (!((x1==x2) && (y1==y2))){
0009EC  78040B     MOV W11, W8
000A10  540F8B     SUB W8, W11, [W15]
000A12  3AFFED     BRA NZ, 0x9EE
000A14  97B2FF     MOV [W15-18], W5
000A16  550F85     SUB W10, W5, [W15]
000A18  3AFFE9     BRA NZ, 0x9EC
69:                            e2=err<<1;
0009EE  448209     ADD W9, W9, W4
70:                            if (e2>-deltay){
0009E8  EA0685     NEG W5, W13
0009EA  370001     BRA 0x9EE
0009F0  520F8D     SUB W4, W13, [W15]
0009F2  340005     BRA LE, 0x9FE
71:                               err -= deltay;
0009F4  97BA0F     MOV [W15-16], W4
0009F6  548484     SUB W9, W4, W9
72:                               x1 += sx;
0009F8  97B2EF     MOV [W15-20], W5
0009FA  440405     ADD W8, W5, W8
0009FC  370005     BRA 0xA08
73:                            }else if (e2<deltax){
0009FE  570F84     SUB W14, W4, [W15]
000A00  340003     BRA LE, 0xA08
74:                                err +=deltax;
000A02  44848E     ADD W9, W14, W9
75:                                y1 += sy;
000A04  97B25F     MOV [W15-22], W4
000A06  450504     ADD W10, W4, W10
76:                            }
77:                            plot(x1,y1,color);
000A08  78010C     MOV W12, W2
000A0A  78008A     MOV W10, W1
000A0C  780008     MOV W8, W0
000A0E  07FF74     RCALL plot
78:                        }
79:                    }
80:                } // line()
000A1A  78074F     MOV [--W15], W14
000A1C  BE064F     MOV.D [--W15], W12
000A1E  BE054F     MOV.D [--W15], W10
000A20  BE044F     MOV.D [--W15], W8
000A22  B100AF     SUB #0xA, W15
000A24  060000     RETURN
81:                
82:                void rectangle(int x1, int y1, int x2, int y2, int color){
000A26  BE9F88     MOV.D W8, [W15++]
000A28  BE9F8A     MOV.D W10, [W15++]
000A2A  781F8C     MOV W12, [W15++]
000A2C  780480     MOV W0, W9
000A2E  780401     MOV W1, W8
000A30  780502     MOV W2, W10
000A32  780603     MOV W3, W12
000A34  780584     MOV W4, W11
83:                    line(x1,y1,x1,y2,color);
000A36  780109     MOV W9, W2
000A38  780088     MOV W8, W1
000A3A  780009     MOV W9, W0
000A3C  07FF89     RCALL line
84:                    line(x2,y1,x2,y2,color);
000A3E  78020B     MOV W11, W4
000A40  78018C     MOV W12, W3
000A42  78010A     MOV W10, W2
000A44  780088     MOV W8, W1
000A46  78000A     MOV W10, W0
000A48  07FF83     RCALL line
85:                    line(x1,y1,x2,y1,color);
000A4A  78020B     MOV W11, W4
000A4C  780188     MOV W8, W3
000A4E  78010A     MOV W10, W2
000A50  780088     MOV W8, W1
000A52  780009     MOV W9, W0
000A54  07FF7D     RCALL line
86:                    line(x1,y2,x2,y2,color);
000A56  78020B     MOV W11, W4
000A58  78018C     MOV W12, W3
000A5A  78010A     MOV W10, W2
000A5C  78008C     MOV W12, W1
000A5E  780009     MOV W9, W0
000A60  07FF77     RCALL line
87:                }//rectangle()
000A62  78064F     MOV [--W15], W12
000A64  BE054F     MOV.D [--W15], W10
000A66  BE044F     MOV.D [--W15], W8
000A68  060000     RETURN
88:                
89:                /*  algorthme mid-point
90:                 * REF: http://www.hhhprogram.com/2013/05/draw-elipse-midpoint-elipse-algorithm.html
91:                 */
92:                void ellipse (int xc, int yc, long rx, long ry, int color){
000A6A  B0036F     ADD #0x36, W15
000A6C  BE9F88     MOV.D W8, [W15++]
000A6E  BE9F8A     MOV.D W10, [W15++]
000A70  BE9F8C     MOV.D W12, [W15++]
000A72  781F8E     MOV W14, [W15++]
000A74  9FAF90     MOV W0, [W15-46]
000A76  9FAFE1     MOV W1, [W15-36]
000A78  BE0504     MOV.D W4, W10
000A7A  780706     MOV W6, W14
000AF6  9FA7F2     MOV W2, [W15-50]
000AF8  9FAF83     MOV W3, [W15-48]
000B04  97AA9F     MOV [W15-46], W5
000B06  E90285     DEC W5, W5
000B08  9FA7C5     MOV W5, [W15-56]
000B0A  97AB1F     MOV [W15-46], W6
000B0C  E80306     INC W6, W6
000B0E  9FA7B6     MOV W6, [W15-58]
000B10  9F9FFA     MOV W10, [W15-66]
000B12  9FA78B     MOV W11, [W15-64]
000B1C  97B47F     MOV [W15-18], W8
000B1E  97A0CF     MOV [W15-56], W1
000B20  408088     ADD W1, W8, W1
000B22  9FB791     MOV W1, [W15-30]
000B30  97A1BF     MOV [W15-58], W3
000B32  518408     SUB W3, W8, W8
000B5C  97A07F     MOV [W15-50], W0
000B5E  97A88F     MOV [W15-48], W1
000B60  40030C     ADD W0, W12, W6
000B62  48838D     ADDC W1, W13, W7
000B92  97A47F     MOV [W15-50], W8
000B94  97AC8F     MOV [W15-48], W9
000B96  44030C     ADD W8, W12, W6
000B98  4C838D     ADDC W9, W13, W7
000BB6  97B37F     MOV [W15-18], W6
000BB8  97BB8F     MOV [W15-16], W7
000BBA  530061     SUB W6, #0x1, W0
000BBC  5B80E0     SUBB W7, #0x0, W1
000C66  97AA4F     MOV [W15-40], W4
000C68  97AADF     MOV [W15-38], W5
000C6A  120260     SUBR W4, #0x0, W4
000C6C  1A82E0     SUBBR W5, #0x0, W5
000C6E  9FB794     MOV W4, [W15-30]
000C70  9FB7A5     MOV W5, [W15-28]
000C72  97AADF     MOV [W15-38], W5
000C74  97B47F     MOV [W15-18], W8
000C76  B9AB08     MUL.SS W5, W8, W6
000C78  97BC8F     MOV [W15-16], W9
000C7A  97A84F     MOV [W15-40], W0
000C7C  B9CA00     MUL.SS W9, W0, W4
000C7E  420206     ADD W4, W6, W4
000C80  97A9CF     MOV [W15-40], W3
000C82  97B15F     MOV [W15-22], W2
000C84  B81902     MUL.UU W3, W2, W2
000C86  9FB7B2     MOV W2, [W15-26]
000C88  9FB7C3     MOV W3, [W15-24]
000C8A  420183     ADD W4, W3, W3
000C8C  9FB7C3     MOV W3, [W15-24]
000C8E  97B23F     MOV [W15-26], W4
000C90  97B2CF     MOV [W15-24], W5
000C92  9FB7D4     MOV W4, [W15-22]
000C94  9FB7E5     MOV W5, [W15-20]
000C9E  97ABEF     MOV [W15-36], W7
000CA0  53858C     SUB W7, W12, W11
000CAE  97A8EF     MOV [W15-36], W1
000CB0  40848C     ADD W1, W12, W9
000CD6  560261     SUB W12, #0x1, W4
000CD8  5E82E0     SUBB W13, #0x0, W5
000CF4  560261     SUB W12, #0x1, W4
000CF6  5E82E0     SUBB W13, #0x0, W5
93:                          long  x=0,y=ry;
94:                          long  p=(ry*ry)-(rx*rx*ry)+((rx*rx)/4);
000A7C  B99A02     MUL.SS W3, W2, W4
000A7E  420204     ADD W4, W4, W4
000A80  B81002     MUL.UU W2, W2, W0
000A82  9FAFA0     MOV W0, [W15-44]
000A84  9FAFB1     MOV W1, [W15-42]
000A86  420081     ADD W4, W1, W1
000A88  9FAFB1     MOV W1, [W15-42]
000A8A  97A92F     MOV [W15-44], W2
000A8C  97A9BF     MOV [W15-42], W3
000A8E  550202     SUB W10, W2, W4
000A90  5D8283     SUBB W11, W3, W5
000A92  B9AB0A     MUL.SS W5, W10, W6
000A94  B9D804     MUL.SS W11, W4, W0
000A96  400306     ADD W0, W6, W6
000A98  B8220A     MUL.UU W4, W10, W4
000A9A  430285     ADD W6, W5, W5
000A9C  BE0302     MOV.D W2, W6
000A9E  510FE0     SUB W2, #0x0, [W15]
000AA0  598FE0     SUBB W3, #0x0, [W15]
000AA2  3D0002     BRA GE, 0xAA8
000AA4  410363     ADD W2, #0x3, W6
000AA6  4983E0     ADDC W3, #0x0, W7
000AA8  DD39CE     SL W7, #14, W3
000AAA  DE3342     LSR W6, #2, W6
000AAC  718306     IOR W3, W6, W6
000AAE  DEBBC2     ASR W7, #2, W7
000AB0  430404     ADD W6, W4, W8
000AB2  4B8485     ADDC W7, W5, W9
000AB4  9FB7B8     MOV W8, [W15-26]
000AB6  9FB7C9     MOV W9, [W15-24]
95:                          while((2*x*ry*ry)<(2*y*rx*rx)){
000AB8  B9DA0A     MUL.SS W11, W10, W4
000ABA  420204     ADD W4, W4, W4
000ABC  B8500A     MUL.UU W10, W10, W0
000ABE  9FA7D0     MOV W0, [W15-54]
000AC0  9FA7E1     MOV W1, [W15-52]
000AC2  420081     ADD W4, W1, W1
000AC4  9FA7E1     MOV W1, [W15-52]
000AC6  97A15F     MOV [W15-54], W2
000AC8  97A1EF     MOV [W15-52], W3
000ACA  410102     ADD W2, W2, W2
000ACC  498183     ADDC W3, W3, W3
000ACE  9FA792     MOV W2, [W15-62]
000AD0  9FA7A3     MOV W3, [W15-60]
000AD2  97AA2F     MOV [W15-44], W4
000AD4  97AABF     MOV [W15-42], W5
000AD6  420204     ADD W4, W4, W4
000AD8  4A8285     ADDC W5, W5, W5
000ADA  9FB7D4     MOV W4, [W15-22]
000ADC  9FB7E5     MOV W5, [W15-20]
000AFA  200014     MOV #0x1, W4
000AFC  200005     MOV #0x0, W5
000AFE  9FB7F4     MOV W4, [W15-18]
000B00  9FBF85     MOV W5, [W15-16]
000B02  B86660     MUL.UU W12, #0, W12
000B14  370050     BRA 0xBB6
000BBE  97B3DF     MOV [W15-22], W7
000BC0  B9DA07     MUL.SS W11, W7, W4
000BC2  97B46F     MOV [W15-20], W8
000BC4  B9C30A     MUL.SS W8, W10, W6
000BC6  430304     ADD W6, W4, W6
000BC8  97B4DF     MOV [W15-22], W9
000BCA  B85209     MUL.UU W10, W9, W4
000BCC  430285     ADD W6, W5, W5
000BCE  520F8C     SUB W4, W12, [W15]
000BD0  5A8F8D     SUBB W5, W13, [W15]
000BD2  3CFFA1     BRA GT, 0xB16
000BD4  BE010A     MOV.D W10, W2
000BD6  9FB79A     MOV W10, [W15-30]
000BD8  9FB7AB     MOV W11, [W15-28]
000BDA  9FAFF0     MOV W0, [W15-34]
000BDC  9FB781     MOV W1, [W15-32]
000BDE  979D7F     MOV [W15-66], W10
000BE0  97A58F     MOV [W15-64], W11
000BE2  BE0600     MOV.D W0, W12
96:                               plot(xc+x,yc-y,color);
000B16  97A86F     MOV [W15-36], W0
000B18  50000A     SUB W0, W10, W0
000B1A  9FAFF0     MOV W0, [W15-34]
000B24  78010E     MOV W14, W2
000B26  780080     MOV W0, W1
000B28  97B01F     MOV [W15-30], W0
000B2A  07FEE6     RCALL plot
97:                               plot(xc-x,yc+y,color);
000B2C  97A96F     MOV [W15-36], W2
000B2E  450482     ADD W10, W2, W9
000B34  78010E     MOV W14, W2
000B36  BE0008     MOV.D W8, W0
000B38  07FEDF     RCALL plot
98:                               plot(xc+x,yc+y,color);
000B3A  78010E     MOV W14, W2
000B3C  780089     MOV W9, W1
000B3E  97B01F     MOV [W15-30], W0
000B40  07FEDB     RCALL plot
99:                               plot(xc-x,yc-y,color);
000B42  78010E     MOV W14, W2
000B44  97A8FF     MOV [W15-34], W1
000B46  780008     MOV W8, W0
000B48  07FED7     RCALL plot
100:                              if(p<0){
000B4A  97B23F     MOV [W15-26], W4
000B4C  97B2CF     MOV [W15-24], W5
000B4E  520FE0     SUB W4, #0x0, [W15]
000B50  5A8FE0     SUBB W5, #0x0, [W15]
000B52  3D000D     BRA GE, 0xB6E
101:                                  x=x+1;
102:                                  p=p+(2*ry*ry*x)+(ry*ry);
000B54  97A45F     MOV [W15-54], W8
000B56  97A4EF     MOV [W15-52], W9
000B58  440204     ADD W8, W4, W4
000B5A  4C8285     ADDC W9, W5, W5
000B64  420106     ADD W4, W6, W2
000B66  4A8187     ADDC W5, W7, W3
000B68  9FB7B2     MOV W2, [W15-26]
000B6A  9FB7C3     MOV W3, [W15-24]
000B6C  37001A     BRA 0xBA2
103:                              }else {
104:                                  x=x+1;
105:                                  y=y-1;
000B6E  550561     SUB W10, #0x1, W10
000B70  5D85E0     SUBB W11, #0x0, W11
106:                                  p=p+(2*ry*ry*x+ry*ry)-(2*rx*rx*y);
000ADE  2FFFE4     MOV #0xFFFE, W4
000AE0  97AB3F     MOV [W15-42], W6
000AE2  B9B204     MUL.SS W6, W4, W4
000AE4  97ABAF     MOV [W15-44], W7
000AE6  520207     SUB W4, W7, W4
000AE8  2FFFE5     MOV #0xFFFE, W5
000AEA  97ACAF     MOV [W15-44], W9
000AEC  B84C05     MUL.UU W9, W5, W8
000AEE  9FAFC8     MOV W8, [W15-40]
000AF0  9FAFD9     MOV W9, [W15-38]
000AF2  420489     ADD W4, W9, W9
000AF4  9FAFD9     MOV W9, [W15-38]
000B72  97B23F     MOV [W15-26], W4
000B74  97B2CF     MOV [W15-24], W5
000B76  97A45F     MOV [W15-54], W8
000B78  97A4EF     MOV [W15-52], W9
000B7A  440304     ADD W8, W4, W6
000B7C  4C8385     ADDC W9, W5, W7
000B7E  97ACCF     MOV [W15-40], W9
000B80  B9DA09     MUL.SS W11, W9, W4
000B82  97A95F     MOV [W15-38], W2
000B84  B9900A     MUL.SS W2, W10, W0
000B86  400004     ADD W0, W4, W0
000B88  97A9CF     MOV [W15-40], W3
000B8A  B85203     MUL.UU W10, W3, W4
000B8C  400285     ADD W0, W5, W5
000B8E  420206     ADD W4, W6, W4
000B90  4A8287     ADDC W5, W7, W5
000B9A  420006     ADD W4, W6, W0
000B9C  4A8087     ADDC W5, W7, W1
000B9E  9FB7B0     MOV W0, [W15-26]
000BA0  9FB7C1     MOV W1, [W15-24]
000BA2  97A17F     MOV [W15-50], W2
000BA4  97A98F     MOV [W15-48], W3
000BA6  41060C     ADD W2, W12, W12
000BA8  49868D     ADDC W3, W13, W13
000BAA  97B27F     MOV [W15-18], W4
000BAC  97BA8F     MOV [W15-16], W5
000BAE  420261     ADD W4, #0x1, W4
000BB0  4A82E0     ADDC W5, #0x0, W5
000BB2  9FB7F4     MOV W4, [W15-18]
000BB4  9FBF85     MOV W5, [W15-16]
107:                              }
108:                         }
109:                         p=((float)x+0.5)*((float)x+0.5)*ry*ry+(y-1)*(y-1)*rx*rx-rx*rx*ry*ry;
000BEA  BE000A     MOV.D W10, W0
000BEC  07FBD6     RCALL 0x39A
000BEE  BE0400     MOV.D W0, W8
000BF0  97B31F     MOV [W15-30], W6
000BF2  97B3AF     MOV [W15-28], W7
000BF4  530361     SUB W6, #0x1, W6
000BF6  5B83E0     SUBB W7, #0x0, W7
000BF8  9FB7F6     MOV W6, [W15-18]
000BFA  9FBF87     MOV W7, [W15-16]
000BFC  BE000C     MOV.D W12, W0
000BFE  07FBCD     RCALL 0x39A
000C00  200002     MOV #0x0, W2
000C02  23F003     MOV #0x3F00, W3
000C04  07FB4C     RCALL 0x29E
000C06  BE0100     MOV.D W0, W2
000C08  07FC1E     RCALL 0x446
000C0A  BE0108     MOV.D W8, W2
000C0C  07FC1C     RCALL 0x446
000C0E  BE0100     MOV.D W0, W2
000C10  BE0008     MOV.D W8, W0
000C12  07FC19     RCALL 0x446
000C14  BE0400     MOV.D W0, W8
000C16  97BB8F     MOV [W15-16], W7
000C18  97B07F     MOV [W15-18], W0
000C1A  B9BA00     MUL.SS W7, W0, W4
000C1C  420204     ADD W4, W4, W4
000C1E  97B0FF     MOV [W15-18], W1
000C20  9FB7D1     MOV W1, [W15-22]
000C22  780101     MOV W1, W2
000C24  B81002     MUL.UU W2, W2, W0
000C26  420081     ADD W4, W1, W1
000C28  97A9AF     MOV [W15-44], W3
000C2A  B98B03     MUL.SS W1, W3, W6
000C2C  97A93F     MOV [W15-42], W2
000C2E  B99200     MUL.SS W2, W0, W4
000C30  420206     ADD W4, W6, W4
000C32  97AD2F     MOV [W15-44], W10
000C34  B8000A     MUL.UU W0, W10, W0
000C36  420081     ADD W4, W1, W1
000C38  07FBB0     RCALL 0x39A
000C3A  BE0100     MOV.D W0, W2
000C3C  BE0008     MOV.D W8, W0
000C3E  07FB2F     RCALL 0x29E
000C40  BE0400     MOV.D W0, W8
000C42  97A9BF     MOV [W15-42], W3
000C44  97A25F     MOV [W15-54], W4
000C46  B99B04     MUL.SS W3, W4, W6
000C48  97A06F     MOV [W15-52], W0
000C4A  97A8AF     MOV [W15-44], W1
000C4C  B98201     MUL.SS W0, W1, W4
000C4E  420206     ADD W4, W6, W4
000C50  97A15F     MOV [W15-54], W2
000C52  B85002     MUL.UU W10, W2, W0
000C54  420081     ADD W4, W1, W1
000C56  07FBA1     RCALL 0x39A
000C58  BE0100     MOV.D W0, W2
000C5A  BE0008     MOV.D W8, W0
000C5C  07FB1F     RCALL 0x29C
000C5E  07FB7C     RCALL 0x358
000C60  BE0500     MOV.D W0, W10
000C62  97B61F     MOV [W15-30], W12
000C64  97B6AF     MOV [W15-28], W13
110:                         while(y>=0){
000BE4  510FE0     SUB W2, #0x0, [W15]
000BE6  598FE0     SUBB W3, #0x0, [W15]
000BE8  3500B8     BRA LT, 0xD5A
000D54  520FE0     SUB W4, #0x0, [W15]
000D56  5A8FE0     SUBB W5, #0x0, [W15]
000D58  3DFFA2     BRA GE, 0xC9E
111:                              plot(xc+x,yc-y,color);
000CA2  97AC7F     MOV [W15-34], W8
000CA4  97A81F     MOV [W15-46], W0
000CA6  440500     ADD W8, W0, W10
000CA8  78010E     MOV W14, W2
000CAA  BE000A     MOV.D W10, W0
000CAC  07FE25     RCALL plot
112:                              plot(xc-x,yc+y,color);
000CB2  97A91F     MOV [W15-46], W2
000CB4  510408     SUB W2, W8, W8
000CB6  78010E     MOV W14, W2
000CB8  BE0008     MOV.D W8, W0
000CBA  07FE1E     RCALL plot
113:                              plot(xc+x,yc+y,color);
000CBC  78010E     MOV W14, W2
000CBE  780089     MOV W9, W1
000CC0  78000A     MOV W10, W0
000CC2  07FE1A     RCALL plot
114:                              plot(xc-x,yc-y,color);
000CC4  78010E     MOV W14, W2
000CC6  78008B     MOV W11, W1
000CC8  780008     MOV W8, W0
000CCA  07FE16     RCALL plot
115:                              if(p>0){
000CCC  97B27F     MOV [W15-18], W4
000CCE  97BA8F     MOV [W15-16], W5
000CD0  520FE0     SUB W4, #0x0, [W15]
000CD2  5A8FE0     SUBB W5, #0x0, [W15]
000CD4  34000F     BRA LE, 0xCF4
116:                                  y=y-1;
117:                                  p=p-(2*rx*rx*y)+(rx*rx);
000CDA  97B47F     MOV [W15-18], W8
000CDC  97BC8F     MOV [W15-16], W9
000CDE  97A82F     MOV [W15-44], W0
000CE0  97A8BF     MOV [W15-42], W1
000CE2  400308     ADD W0, W8, W6
000CE4  488389     ADDC W1, W9, W7
000CE6  97B15F     MOV [W15-22], W2
000CE8  97B1EF     MOV [W15-20], W3
000CEA  430102     ADD W6, W2, W2
000CEC  4B8183     ADDC W7, W3, W3
000CEE  9FB7F2     MOV W2, [W15-18]
000CF0  9FBF83     MOV W3, [W15-16]
000CF2  370020     BRA 0xD34
118:                              }else{
119:                                  y=y-1;
120:                                  x=x+1;
000CF8  97AB7F     MOV [W15-34], W6
000CFA  97B38F     MOV [W15-32], W7
000CFC  430361     ADD W6, #0x1, W6
000CFE  4B83E0     ADDC W7, #0x0, W7
000D00  9FAFF6     MOV W6, [W15-34]
000D02  9FB787     MOV W7, [W15-32]
121:                                  p=p+(2*ry*ry*x)-(2*rx*rx*y)-(rx*rx);
000C96  97A29F     MOV [W15-62], W5
000C98  9FAFC5     MOV W5, [W15-40]
000C9A  9FB7FA     MOV W10, [W15-18]
000C9C  9FBF8B     MOV W11, [W15-16]
000D04  97B47F     MOV [W15-18], W8
000D06  97BC8F     MOV [W15-16], W9
000D08  97A82F     MOV [W15-44], W0
000D0A  97A8BF     MOV [W15-42], W1
000D0C  540100     SUB W8, W0, W2
000D0E  5C8181     SUBB W9, W1, W3
000D10  97A3AF     MOV [W15-60], W7
000D12  B9B806     MUL.SS W7, W6, W0
000D14  97B40F     MOV [W15-32], W8
000D16  97A49F     MOV [W15-62], W9
000D18  B9C309     MUL.SS W8, W9, W6
000D1A  430000     ADD W6, W0, W0
000D1C  97A8CF     MOV [W15-40], W1
000D1E  97AC7F     MOV [W15-34], W8
000D20  B80B08     MUL.UU W1, W8, W6
000D22  400387     ADD W0, W7, W7
000D24  430302     ADD W6, W2, W6
000D26  4B8383     ADDC W7, W3, W7
000D28  97B03F     MOV [W15-26], W0
000D2A  97B0CF     MOV [W15-24], W1
000D2C  430000     ADD W6, W0, W0
000D2E  4B8081     ADDC W7, W1, W1
000D30  9FB7F0     MOV W0, [W15-18]
000D32  9FBF81     MOV W1, [W15-16]
000D34  560661     SUB W12, #0x1, W12
000D36  5E86E0     SUBB W13, #0x0, W13
000D38  97B15F     MOV [W15-22], W2
000D3A  97B1EF     MOV [W15-20], W3
000D3C  97B31F     MOV [W15-30], W6
000D3E  97B3AF     MOV [W15-28], W7
000D40  430102     ADD W6, W2, W2
000D42  4B8183     ADDC W7, W3, W3
000D44  9FB7D2     MOV W2, [W15-22]
000D46  9FB7E3     MOV W3, [W15-20]
000D48  97B43F     MOV [W15-26], W8
000D4A  97B4CF     MOV [W15-24], W9
000D4C  430408     ADD W6, W8, W8
000D4E  4B8489     ADDC W7, W9, W9
000D50  9FB7B8     MOV W8, [W15-26]
000D52  9FB7C9     MOV W9, [W15-24]
122:                              }
123:                         }
124:               }//ellipse()
000D5A  78074F     MOV [--W15], W14
000D5C  BE064F     MOV.D [--W15], W12
000D5E  BE054F     MOV.D [--W15], W10
000D60  BE044F     MOV.D [--W15], W8
000D62  B1036F     SUB #0x36, W15
000D64  060000     RETURN
125:               
126:               /*
127:                * points[]={x1,y1,x2,y2,x3,y3,...}
128:                * vertices est le nombre de points
129:                */
130:               void polygon(int points[], int vertices, int color){
000D66  BE9F88     MOV.D W8, [W15++]
000D68  BE9F8A     MOV.D W10, [W15++]
000D6A  781F8C     MOV W12, [W15++]
000D6C  780600     MOV W0, W12
000D6E  780582     MOV W2, W11
131:                   int i;
132:                   for(i=0;i<(2*vertices-2);i+=2){
000D70  E90501     DEC W1, W10
000D72  45050A     ADD W10, W10, W10
000D74  EB0480     CLR W9
000D76  550F89     SUB W10, W9, [W15]
000D78  34000B     BRA LE, 0xD90
000D7A  78040C     MOV W12, W8
000D88  E88489     INC2 W9, W9
000D8A  440464     ADD W8, #0x4, W8
000D8C  550F89     SUB W10, W9, [W15]
000D8E  3CFFF6     BRA GT, 0xD7C
133:                       line(points[i],points[i+1],points[i+2],points[i+3],color);
000D7C  900128     MOV [W8+4], W2
000D7E  900098     MOV [W8+2], W1
000D80  78020B     MOV W11, W4
000D82  9001B8     MOV [W8+6], W3
000D84  780018     MOV [W8], W0
000D86  07FDE4     RCALL line
134:                   }
135:                   line(points[0],points[1],points[i],points[i+1],color);
000D90  E80289     INC W9, W5
000D92  428285     ADD W5, W5, W5
000D94  448489     ADD W9, W9, W9
000D96  90009C     MOV [W12+2], W1
000D98  78020B     MOV W11, W4
000D9A  7A81EC     MOV [W12+W5], W3
000D9C  7C816C     MOV [W12+W9], W2
000D9E  78001C     MOV [W12], W0
000DA0  07FDD7     RCALL line
136:               }//polygon()
000DA2  78064F     MOV [--W15], W12
000DA4  BE054F     MOV.D [--W15], W10
000DA6  BE044F     MOV.D [--W15], W8
000DA8  060000     RETURN
137:               
138:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NSTC_FRAME_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE+40)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAME_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE+45)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8 // flag screen in retrace phase
60:                
61:                
62:                static unsigned int frame_line_cntr=0; // count line in video frame
63:                volatile static unsigned long frame_cntr=0; // number of frame since reset
64:                volatile static unsigned int flags;
65:                
66:                
67:                char video_buffer[VPIXELS][BYTES_PER_LINE];
68:                int vsync, hsync, video_mode;
69:                
70:                void ntsc_init(){
71:                    VIDPR = NTSC_LINE_PERIOD;  // video timer PRx SFR
001326  203F85     MOV #0x3F8, W5
001328  880865     MOV W5, PR2
72:                    VSYNCR= NTSC_HPULSE;       // video OCxR  SFR
00132A  2004B4     MOV #0x4B, W4
00132C  880C14     MOV W4, OC1R
73:                    VSYNCRS=NTSC_LINE_PERIOD;  // video OCxRS SFR
00132E  880C05     MOV W5, OC1RS
74:                    VDLYR=NTSC_VIDEO_DELAY;     // video delay OCxR SFR
001330  200BE5     MOV #0xBE, W5
001332  880CA5     MOV W5, OC4R
75:                    VDLYRS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;  // video delay OCxRS SFR
001334  203E05     MOV #0x3E0, W5
001336  880C95     MOV W5, OC4RS
76:                    hsync=NTSC_HPULSE;
001338  88F654     MOV W4, hsync
77:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
00133A  203AC4     MOV #0x3AC, W4
00133C  88F644     MOV W4, vsync
78:                    video_mode=NTSC_MODE;
00133E  EF3ECC     CLR video_mode
79:                }//f()
001340  060000     RETURN
80:                
81:                void pal_init(){
82:                    VIDPR = PAL_LINE_PERIOD;
001342  204005     MOV #0x400, W5
001344  880865     MOV W5, PR2
83:                    VSYNCR= PAL_HPULSE;
001346  2004B4     MOV #0x4B, W4
001348  880C14     MOV W4, OC1R
84:                    VSYNCRS=PAL_LINE_PERIOD;
00134A  880C05     MOV W5, OC1RS
85:                    VDLYR=PAL_VIDEO_DELAY;
00134C  200C35     MOV #0xC3, W5
00134E  880CA5     MOV W5, OC4R
86:                    VDLYRS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
001350  203E65     MOV #0x3E6, W5
001352  880C95     MOV W5, OC4RS
87:                    hsync=PAL_HPULSE;
001354  88F654     MOV W4, hsync
88:                    vsync=PAL_LINE_PERIOD-PAL_HPULSE;
001356  203B44     MOV #0x3B4, W4
001358  88F644     MOV W4, vsync
89:                    video_mode=PAL_MODE;
00135A  200014     MOV #0x1, W4
00135C  88F664     MOV W4, video_mode
90:                }//f()
00135E  060000     RETURN
91:                
92:                void  video_init(){ // initialisation sorties NTSC
93:                    VIDTMR.TON=0; // désactivation TIMER2
001360  A9E111     BCLR 0x111, #7
94:                    if (P_VIDEO_MODE){
001362  801655     MOV PORTB, W5
001364  210004     MOV #0x1000, W4
001366  628204     AND W5, W4, W4
001368  320002     BRA Z, 0x136E
95:                        ntsc_init();
00136A  07FFDD     RCALL ntsc_init
00136C  370001     BRA 0x1370
96:                    }else{
97:                        pal_init();
00136E  07FFE9     RCALL pal_init
98:                    }
99:                    //  video sync OC mode
100:                   VSYNCCON.OCM=5; // mode 5, timer 2
001370  800C24     MOV OC1CON, W4
001372  A00004     BSET W4, #0
001374  A11004     BCLR W4, #1
001376  A02004     BSET W4, #2
001378  880C24     MOV W4, OC1CON
101:                   //video delay change notification interrupt enable on that pin.
102:                   PIXIE=1;
00137A  A8A062     BSET CNEN2, #5
103:                   // video sync interrupt enabling
104:                   VSYNCIF=0;
00137C  A9E084     BCLR IFS0, #7
105:                   VSYNCIE=1;
00137E  A8E094     BSET IEC0, #7
106:                   // SPIx configuration (pixels output)
107:                   PIXCON1.DISSCK=1;
001380  A88243     BSET 0x243, #4
108:                   PIXCON1.MSTEN=1;
001382  A8A242     BSET SPI1CON1, #5
109:                   PIXCON1.SPRE=5;
001384  801214     MOV SPI1CON1, W4
001386  A02004     BSET W4, #2
001388  A13004     BCLR W4, #3
00138A  A04004     BSET W4, #4
00138C  881214     MOV W4, SPI1CON1
110:                   PIXCON1.PPRE=3;
00138E  200030     MOV #0x3, W0
001390  B72242     IOR SPI1CON1
111:                   PIXCON2.SPIBEN=1;  // enhanced buffer mode
001392  A80244     BSET SPI1CON2, #0
112:                   PIXSTAT.SPIEN=1;
001394  A8E241     BSET 0x241, #7
113:                   VIDTMR.TON=1;
001396  A8E111     BSET 0x111, #7
114:               }//horz_sync_init()
001398  060000     RETURN
115:               
116:               void  wait_n_frame(unsigned n){
117:               unsigned long f0;
118:                   f0=frame_cntr+n;
00139A  80F694     MOV frame_cntr, W4
00139C  80F6A5     MOV 0x1ED4, W5
00139E  420000     ADD W4, W0, W0
0013A0  4A80E0     ADDC W5, #0x0, W1
119:                   while (frame_cntr<f0);
0013A2  80F694     MOV frame_cntr, W4
0013A4  80F6A5     MOV 0x1ED4, W5
0013A6  500F84     SUB W0, W4, [W15]
0013A8  588F85     SUBB W1, W5, [W15]
0013AA  3EFFFB     BRA GTU, 0x13A2
120:               }//f()
0013AC  060000     RETURN
121:               
122:               
123:               
124:               
125:               // video sync signal generation
126:               void __attribute__((interrupt,no_auto_psv,shadow)) _VSYNC_ISR(void){
0013AE  FEA000     PUSH.S
0013B0  BE9F84     MOV.D W4, [W15++]
127:                   frame_line_cntr++;
0013B2  80F674     MOV frame_line_cntr, W4
0013B4  E80204     INC W4, W4
0013B6  88F674     MOV W4, frame_line_cntr
128:                   switch (frame_line_cntr){
0013B8  200375     MOV #0x37, W5
0013BA  520F85     SUB W4, W5, [W15]
0013BC  320034     BRA Z, 0x1426
0013BE  3E0007     BRA GTU, 0x13CE
0013C0  520FE4     SUB W4, #0x4, [W15]
0013C2  32001C     BRA Z, 0x13FC
0013C4  520FFE     SUB W4, #0x1E, [W15]
0013C6  320022     BRA Z, 0x140C
0013C8  520FE1     SUB W4, #0x1, [W15]
0013CA  3A004F     BRA NZ, 0x146A
0013CC  37000F     BRA 0x13EC
0013CE  201075     MOV #0x107, W5
0013D0  520F85     SUB W4, W5, [W15]
0013D2  320036     BRA Z, 0x1440
0013D4  3E0004     BRA GTU, 0x13DE
0013D6  5282F1     SUB W5, #0x11, W5
0013D8  520F85     SUB W4, W5, [W15]
0013DA  3A0047     BRA NZ, 0x146A
0013DC  37001E     BRA 0x141A
0013DE  2010F5     MOV #0x10F, W5
0013E0  520F85     SUB W4, W5, [W15]
0013E2  320028     BRA Z, 0x1434
0013E4  201395     MOV #0x139, W5
0013E6  520F85     SUB W4, W5, [W15]
0013E8  3A0040     BRA NZ, 0x146A
0013EA  370035     BRA 0x1456
129:                       case 1:
130:                           VSYNCR=vsync;
0013EC  F81EC8     PUSH vsync
0013EE  F90182     POP OC1R
131:                           VDLYCON.OCM=0;
0013F0  800CB4     MOV OC4CON, W4
0013F2  A10004     BCLR W4, #0
0013F4  A11004     BCLR W4, #1
0013F6  A12004     BCLR W4, #2
0013F8  880CB4     MOV W4, OC4CON
132:                           break;
0013FA  370037     BRA 0x146A
133:                       case 4:
134:                           VDLYCON.OCM=5;
0013FC  800CB4     MOV OC4CON, W4
0013FE  A00004     BSET W4, #0
001400  A11004     BCLR W4, #1
001402  A02004     BSET W4, #2
001404  880CB4     MOV W4, OC4CON
135:                           VSYNCR=hsync;
001406  F81ECA     PUSH hsync
001408  F90182     POP OC1R
136:                           break;
00140A  37002F     BRA 0x146A
137:                       case NTSC_FIRST_VISIBLE:
138:                           if (video_mode==NTSC_MODE){
00140C  80F664     MOV video_mode, W4
00140E  520FE0     SUB W4, #0x0, [W15]
001410  3A002C     BRA NZ, 0x146A
139:                               VDLYIF=0;
001412  A96086     BCLR IFS1, #3
140:                               VDLYIE=1;
001414  A86096     BSET IEC1, #3
141:                               flags &= ~F_RETRACE;
001416  A97ED0     BCLR flags, #3
001418  370028     BRA 0x146A
142:                           }
143:                           break;
144:                       case NTSC_LAST_VISIBLE:
145:                           if (video_mode==NTSC_MODE){
00141A  80F664     MOV video_mode, W4
00141C  520FE0     SUB W4, #0x0, [W15]
00141E  3A0025     BRA NZ, 0x146A
146:                               VDLYIE=0;
001420  A96096     BCLR IEC1, #3
147:                               flags |= F_RETRACE;
001422  A87ED0     BSET flags, #3
001424  370022     BRA 0x146A
148:                           }
149:                           break;
150:                       case PAL_FIRST_VISIBLE:
151:                           if (video_mode==PAL_MODE){
001426  80F664     MOV video_mode, W4
001428  520FE1     SUB W4, #0x1, [W15]
00142A  3A001F     BRA NZ, 0x146A
152:                               VDLYIF=0;
00142C  A96086     BCLR IFS1, #3
153:                               VDLYIE=1;
00142E  A86096     BSET IEC1, #3
154:                               flags &= ~F_RETRACE;
001430  A97ED0     BCLR flags, #3
001432  37001B     BRA 0x146A
155:                           }
156:                           break;
157:                       case PAL_LAST_VISIBLE:
158:                           if (video_mode==PAL_MODE){
001434  80F664     MOV video_mode, W4
001436  520FE1     SUB W4, #0x1, [W15]
001438  3A0018     BRA NZ, 0x146A
159:                               VDLYIE=0;
00143A  A96096     BCLR IEC1, #3
160:                               flags |= F_RETRACE;
00143C  A87ED0     BSET flags, #3
00143E  370015     BRA 0x146A
161:                           }
162:                           break;
163:                       case NTSC_LINES_PER_FRAME+1:
164:                           if (video_mode==NTSC_MODE){
001440  80F664     MOV video_mode, W4
001442  520FE0     SUB W4, #0x0, [W15]
001444  3A0012     BRA NZ, 0x146A
165:                               frame_line_cntr=0;
001446  EF3ECE     CLR frame_line_cntr
166:                               frame_cntr++;
001448  80F694     MOV frame_cntr, W4
00144A  80F6A5     MOV 0x1ED4, W5
00144C  420261     ADD W4, #0x1, W4
00144E  4A82E0     ADDC W5, #0x0, W5
001450  88F694     MOV W4, frame_cntr
001452  88F6A5     MOV W5, 0x1ED4
001454  37000A     BRA 0x146A
167:                           }
168:                           break;
169:                       case PAL_LINES_PER_FRAME+1:
170:                           if (video_mode==PAL_MODE){
001456  80F664     MOV video_mode, W4
001458  520FE1     SUB W4, #0x1, [W15]
00145A  3A0007     BRA NZ, 0x146A
171:                               frame_line_cntr=0;
00145C  EF3ECE     CLR frame_line_cntr
172:                               frame_cntr++;
00145E  80F694     MOV frame_cntr, W4
001460  80F6A5     MOV 0x1ED4, W5
001462  420261     ADD W4, #0x1, W4
001464  4A82E0     ADDC W5, #0x0, W5
001466  88F694     MOV W4, frame_cntr
001468  88F6A5     MOV W5, 0x1ED4
173:                           }
174:                           break;
175:                   }//switch
176:                   VSYNCIF=0;
00146A  A9E084     BCLR IFS0, #7
177:               }// _VSYNC_ISR()
00146C  BE024F     MOV.D [--W15], W4
00146E  FE8000     POP.S
001470  064000     RETFIE
178:               
179:               void __attribute__((interrupt,no_auto_psv,shadow)) _VIDEO_OUT_ISR(void){
001472  FEA000     PUSH.S
001474  BE9F84     MOV.D W4, [W15++]
001476  BE9F86     MOV.D W6, [W15++]
00148C  B9337B     MUL.SU W6, #27, W6
00148E  207FF4     MOV #0x7FF, W4
001490  430304     ADD W6, W4, W6
180:                   int y,x;
181:                   if (PIXDLY_INP){
001478  AB22CB     BTST 0x2CB, #1
00147A  320016     BRA Z, 0x14A8
182:                       if (video_mode==NTSC_MODE){
00147C  80F664     MOV video_mode, W4
00147E  520FE0     SUB W4, #0x0, [W15]
001480  3A0003     BRA NZ, 0x1488
183:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE);
001482  80F676     MOV frame_line_cntr, W6
001484  53037E     SUB W6, #0x1E, W6
001486  370002     BRA 0x148C
184:                       }else{
185:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE);
001488  80F676     MOV frame_line_cntr, W6
00148A  B10376     SUB #0x37, W6
186:                       }
187:                       for (x=0;x<BYTES_PER_LINE;x++){
001492  EB0280     CLR W5
00149C  E80285     INC W5, W5
00149E  528FFB     SUB W5, #0x1B, [W15]
0014A0  3AFFF9     BRA NZ, 0x1494
188:                           while (PIXSTAT.SPITBF);
001494  AB2240     BTST SPI1STAT, #1
001496  3AFFFE     BRA NZ, 0x1494
189:                           PIXBUF=video_buffer[y][x];
001498  FB0256     SE [++W6], W4
00149A  881244     MOV W4, SPI1BUF
190:                       }//for
191:                       while (PIXSTAT.SPITBF);
0014A2  AB2240     BTST SPI1STAT, #1
0014A4  3AFFFE     BRA NZ, 0x14A2
192:                       PIXBUF=0;
0014A6  EF2248     CLR SPI1BUF
193:                   }
194:                   VDLYIF=0;
0014A8  A96086     BCLR IFS1, #3
195:               }// _VIDEO_OUT_ISR
0014AA  BE034F     MOV.D [--W15], W6
0014AC  BE024F     MOV.D [--W15], W4
0014AE  FE8000     POP.S
0014B0  064000     RETFIE
196:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  216x216 pixels
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include <stdio.h>
34:                #include <stdlib.h>
35:                #include <time.h>
36:                
37:                
38:                #include "hardwareProfile.h"
39:                #include "TVout.h"
40:                #include "text_console.h"
41:                #include "graphics.h"
42:                #include "sound.h"
43:                #include "snes_paddle.h"
44:                
45:                // PIC24FJ64GA002 Configuration Bit Settings
46:                // CONFIG2
47:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
48:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
49:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
50:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
51:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
52:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
53:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
54:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
55:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
56:                
57:                // CONFIG1
58:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
59:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
60:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
61:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
62:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
63:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
64:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
65:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
66:                
67:                
68:                const char msg[]="bouncing ring demo.";
69:                const unsigned scale[]={523,500,587,500,659,500,698,500,784,500,880,500,988,500,1046,500,0,0};
70:                int main(void) {
00173E  BE9F88     MOV.D W8, [W15++]
71:                    int y,x,dx,dy, rebound=0;
72:                    unsigned p;
73:                    HardwareConfig();
001740  07FF6E     RCALL HardwareConfig
74:                    timers_init(TICK_FREQ);
001742  200640     MOV #0x64, W0
001744  07FD03     RCALL timers_init
75:                    video_init();
001746  07FE0C     RCALL video_init
76:                    sound_init(10);
001748  2000A0     MOV #0xA, W0
00174A  07FEBF     RCALL sound_init
77:                    while (1){
78:                        wait_n_frame(2);
00174C  200028     MOV #0x2, W8
001750  780008     MOV W8, W0
001752  07FE23     RCALL wait_n_frame
79:                        p=read_paddle(PADDLE1);
00174E  200019     MOV #0x1, W9
001754  780009     MOV W9, W0
001756  07FFB6     RCALL read_paddle
80:                        if (p){
001758  500FE0     SUB W0, #0x0, [W15]
00175A  32FFFA     BRA Z, 0x1750
81:                            print_hex(p,3);
00175C  B3C031     MOV #0x3, W1
00175E  07FC2B     RCALL print_hex
82:                            crlf();
001760  07FB8B     RCALL crlf
001762  37FFF6     BRA 0x1750
83:                        }
84:                    }
85:                    tune(scale);
86:                    print(msg);
87:                    rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
88:                    y=108;
89:                    x=100;
90:                    ellipse(x,y,10,10,WHITE);
91:                    dx=0;
92:                    dy=0;
93:                    srand(time(0));
94:                    while (!(dx&&dy)){
95:                        dx=rand()%4-1;
96:                        dy=rand()%4-1;
97:                    }
98:                    while (1){
99:                        wait_n_frame(1);
100:                       ellipse(x,y,10,10,BLACK);
101:                       x +=dx;
102:                       if (x<=10){
103:                           x=11;
104:                           dx=-dx;
105:                           rebound=1;
106:                       }else if (x>=HPIXELS-12){
107:                           x=HPIXELS-12;
108:                           dx=-dx;
109:                           rebound=1;
110:                       }
111:                       y +=dy;
112:                       if (y<=CHAR_HEIGHT+10){
113:                           y=CHAR_HEIGHT+11;
114:                           dy = -dy;
115:                           rebound=1;
116:                       }else if (y>=VPIXELS-12){
117:                           y=VPIXELS-12;
118:                           dy=-dy;
119:                           rebound=1;
120:                       }
121:                       if (rebound){
122:                           white_noise(20);
123:                           rebound=0;
124:                       }
125:                       ellipse(x,y,10,10,WHITE);
126:               
127:                   }//while
128:                   return (EXIT_SUCCESS);
129:               }//main()
130:               
131:               
