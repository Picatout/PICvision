Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-03-18 22:43:33

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/timers.c  ---------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 *  NAME: timers.c
21:                 *  DATE CREATED: 2014-02-21
22:                 *  AUTHOR: Jacques Deschênes
23:                 *  DESCRIPTION: create timers with callback. TIMER1 is used as a system timer that
24:                 *               ticks at regular interval. The ISR of TIMER1 manage created timers.
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "timers.h"
29:                
30:                #define F_TMR_USED 1
31:                #define F_TMR_HALTED 2
32:                #define F_TMR_REPEAT 4
33:                #define TMR_RUNNING 1
34:                
35:                
36:                typedef struct timer_type{
37:                    unsigned status;    // slot used,  timer halted
38:                    unsigned delay;    // timer interval
39:                    unsigned countdown;
40:                    timer_handler_t *handler; // timer callback handler
41:                }timer_t;
42:                
43:                volatile static timer_t timers[MAX_TIMERS];
44:                volatile static unsigned long ticks;
45:                
46:                void timers_init(unsigned ticks_per_second){
002186  BE9F88     MOV.D W8, [W15++]
002188  781F8A     MOV W10, [W15++]
00218A  780500     MOV W0, W10
47:                    unsigned long quotient;
48:                    unsigned prescale;
49:                    int i;
50:                    for (i=0;i<MAX_TIMERS;i++){
00218C  EB0200     CLR W4
00219E  E80204     INC W4, W4
0021A0  520FE8     SUB W4, #0x8, [W15]
0021A2  3AFFF8     BRA NZ, 0x2194
51:                        timers[i].status=0;
00218E  21FAA1     MOV #0x1FAA, W1
002190  EB0300     CLR W6
002194  DD22C3     SL W4, #3, W5
002196  408385     ADD W1, W5, W7
002198  780B86     MOV W6, [W7]
52:                        timers[i].handler=NULL;
002192  408066     ADD W1, #0x6, W0
00219A  400285     ADD W0, W5, W5
00219C  780A86     MOV W6, [W5]
53:                    }//for
54:                    ticks=0;
0021A4  EF3FA6     CLR ticks
0021A6  EF3FA8     CLR 0x1FA8
55:                
56:                    SYSTICKTMR.TON=0;  // disable systick timer
0021A8  A9E105     BCLR 0x105, #7
57:                    SYSTICKTMR.TCS=0;  // use internal Tcy
0021AA  A92104     BCLR T1CON, #1
58:                    quotient = FCY/ticks_per_second;
0021AC  B85461     MUL.UU W10, #1, W8
0021AE  BE0108     MOV.D W8, W2
0021B0  224000     MOV #0x2400, W0
0021B2  200F41     MOV #0xF4, W1
0021B4  07F189     RCALL 0x4C8
59:                    prescale=1;
0021BC  200014     MOV #0x1, W4
60:                    while (quotient>65535){
0021B6  400FE1     ADD W0, #0x1, [W15]
0021B8  588FE0     SUBB W1, #0x0, [W15]
0021BA  36000B     BRA LEU, 0x21D2
0021BE  2FFFF6     MOV #0xFFFF, W6
0021C0  200007     MOV #0x0, W7
0021C8  500F86     SUB W0, W6, [W15]
0021CA  588F87     SUBB W1, W7, [W15]
0021CC  3EFFFA     BRA GTU, 0x21C2
61:                        quotient >>= 1;
0021C2  D10081     LSR W1, W1
0021C4  D38000     RRC W0, W0
62:                        prescale <<= 1;
0021C6  420204     ADD W4, W4, W4
63:                    }
64:                    if (prescale==1){
0021CE  520FE1     SUB W4, #0x1, [W15]
0021D0  3A0006     BRA NZ, 0x21DE
65:                        SYSTICKTMR.TCKPS=0;
0021D2  800824     MOV T1CON, W4
0021D4  A14004     BCLR W4, #4
0021D6  A15004     BCLR W4, #5
0021D8  880824     MOV W4, T1CON
66:                        SYSTICKPR=quotient;
0021DA  880810     MOV W0, PR1
0021DC  370020     BRA 0x221E
67:                    }else if (prescale<=8){
0021DE  520FE8     SUB W4, #0x8, [W15]
0021E0  3E000A     BRA GTU, 0x21F6
68:                        SYSTICKTMR.TCKPS=1;
0021E2  800824     MOV T1CON, W4
0021E4  A04004     BSET W4, #4
0021E6  A15004     BCLR W4, #5
0021E8  880824     MOV W4, T1CON
69:                        SYSTICKPR= FCY/8/ticks_per_second;
0021EA  BE0108     MOV.D W8, W2
0021EC  284800     MOV #0x8480, W0
0021EE  2001E1     MOV #0x1E, W1
0021F0  07F16B     RCALL 0x4C8
0021F2  880810     MOV W0, PR1
0021F4  370014     BRA 0x221E
70:                    }else if (prescale<=64){
0021F6  200405     MOV #0x40, W5
0021F8  520F85     SUB W4, W5, [W15]
0021FA  3E000A     BRA GTU, 0x2210
71:                        SYSTICKTMR.TCKPS=2;
0021FC  800824     MOV T1CON, W4
0021FE  A14004     BCLR W4, #4
002200  A05004     BSET W4, #5
002202  880824     MOV W4, T1CON
72:                        SYSTICKPR= FCY/64/ticks_per_second;
002204  BE0108     MOV.D W8, W2
002206  2D0900     MOV #0xD090, W0
002208  200031     MOV #0x3, W1
00220A  07F15E     RCALL 0x4C8
00220C  880810     MOV W0, PR1
00220E  370007     BRA 0x221E
73:                    }else{
74:                        SYSTICKTMR.TCKPS=3;
002210  200300     MOV #0x30, W0
002212  B72104     IOR T1CON
75:                        SYSTICKPR = FCY/256/ticks_per_second;
002214  2F4244     MOV #0xF424, W4
002216  090011     REPEAT #0x11
002218  D8820A     DIV.UW W4, W10
00221A  780200     MOV W0, W4
00221C  880814     MOV W4, PR1
76:                    }//if
77:                    SYSTICKIF=0; // reset interrupt flag
00221E  A96084     BCLR IFS0, #3
78:                    SYSTICKIE=1; // enable interrupt on systick timer
002220  A86094     BSET IEC0, #3
79:                    SYSTICKTMR.TON = 1; // enable systick timer
002222  A8E105     BSET 0x105, #7
80:                }//f()
002224  78054F     MOV [--W15], W10
002226  BE044F     MOV.D [--W15], W8
002228  060000     RETURN
81:                
82:                int create_timer(unsigned delay, unsigned repeat, timer_handler_t *handler){
83:                    int i;
84:                    if (!handler) return -1;
00222A  EB8200     SETM W4
00222C  510FE0     SUB W2, #0x0, [W15]
00222E  320020     BRA Z, 0x2270
85:                    for (i=0;i<MAX_TIMERS;i++){
002234  200014     MOV #0x1, W4
002268  E80204     INC W4, W4
00226A  520FE8     SUB W4, #0x8, [W15]
00226C  3AFFE4     BRA NZ, 0x2236
86:                        if (!(timers[i].status & F_TMR_USED)){
002230  AB1FAA     BTST timers, #0
002232  320007     BRA Z, 0x2242
002236  DD22C3     SL W4, #3, W5
002238  21FAA6     MOV #0x1FAA, W6
00223A  7A82E6     MOV [W6+W5], W5
00223C  6282E1     AND W5, #0x1, W5
00223E  3A0014     BRA NZ, 0x2268
002240  370001     BRA 0x2244
002242  EB0200     CLR W4
87:                            timers[i].status = F_TMR_USED|F_TMR_HALTED;
002244  DD22C3     SL W4, #3, W5
002246  200037     MOV #0x3, W7
002248  21FAA6     MOV #0x1FAA, W6
00224A  7AB307     MOV W7, [W6+W5]
88:                            if (repeat==TIMER_REPEAT) {timers[i].status |= F_TMR_REPEAT;}
00224C  508FE1     SUB W1, #0x1, [W15]
00224E  3A0004     BRA NZ, 0x2258
002250  7A83E6     MOV [W6+W5], W7
002252  430285     ADD W6, W5, W5
002254  A02007     BSET W7, #2
002256  780A87     MOV W7, [W5]
89:                            timers[i].delay=delay;
002258  DD22C3     SL W4, #3, W5
00225A  21FAC6     MOV #0x1FAC, W6
00225C  7AB300     MOV W0, [W6+W5]
90:                            timers[i].countdown=delay;
00225E  E88306     INC2 W6, W6
002260  7AB300     MOV W0, [W6+W5]
91:                            timers[i].handler=handler;
002262  E88306     INC2 W6, W6
002264  7AB302     MOV W2, [W6+W5]
92:                            return i;
002266  370004     BRA 0x2270
93:                        }//if
94:                    }//for
95:                    return -1;
00226E  EB8200     SETM W4
96:                }//f()
002270  780004     MOV W4, W0
002272  060000     RETURN
97:                
98:                void stop_timer(int timer_id){
99:                    if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
002274  500FE7     SUB W0, #0x7, [W15]
002276  3E000B     BRA GTU, 0x228E
00227E  620261     AND W4, #0x1, W4
002280  320006     BRA Z, 0x228E
100:                        (timers[timer_id].status & F_TMR_USED)){
002278  DD0243     SL W0, #3, W4
00227A  21FAA5     MOV #0x1FAA, W5
00227C  7A0265     MOV [W5+W4], W4
101:                       timers[timer_id].status |= F_TMR_HALTED;
002282  DD0043     SL W0, #3, W0
002284  780205     MOV W5, W4
002286  7802E4     MOV [W4+W0], W5
002288  420000     ADD W4, W0, W0
00228A  A01005     BSET W5, #1
00228C  780805     MOV W5, [W0]
102:                   }//if
103:               }//f()
00228E  060000     RETURN
104:               
105:               void start_timer(int timer_id){
106:                   if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
002290  500FE7     SUB W0, #0x7, [W15]
002292  3E000F     BRA GTU, 0x22B2
00229A  620261     AND W4, #0x1, W4
00229C  32000A     BRA Z, 0x22B2
107:                       (timers[timer_id].status & F_TMR_USED)){
002294  DD0243     SL W0, #3, W4
002296  21FAA5     MOV #0x1FAA, W5
002298  7A0265     MOV [W5+W4], W4
108:                           timers[timer_id].countdown=timers[timer_id].delay;
00229E  DD0043     SL W0, #3, W0
0022A0  E88300     INC2 W0, W6
0022A2  780205     MOV W5, W4
0022A4  4282E4     ADD W5, #0x4, W5
0022A6  7B0364     MOV [W4+W6], W6
0022A8  783286     MOV W6, [W5+W0]
109:                           timers[timer_id].status &= ~F_TMR_HALTED;
0022AA  7802E4     MOV [W4+W0], W5
0022AC  420000     ADD W4, W0, W0
0022AE  A11005     BCLR W5, #1
0022B0  780805     MOV W5, [W0]
110:                   }//if
111:               }//f()
0022B2  060000     RETURN
112:               
113:               void update_timer(int timer_id, unsigned new_delay){
114:                   if ((timer_id>=0)&&(timer_id<=MAX_TIMERS)&&timers[timer_id].status){
0022B4  500FE8     SUB W0, #0x8, [W15]
0022B6  3E0008     BRA GTU, 0x22C8
0022B8  DD0243     SL W0, #3, W4
0022BA  21FAA5     MOV #0x1FAA, W5
0022BC  7A0265     MOV [W5+W4], W4
0022BE  520FE0     SUB W4, #0x0, [W15]
0022C0  320003     BRA Z, 0x22C8
115:                       timers[timer_id].delay=new_delay;
0022C2  DD0043     SL W0, #3, W0
0022C4  E88205     INC2 W5, W4
0022C6  783201     MOV W1, [W4+W0]
116:                   }
117:               }//f()
0022C8  060000     RETURN
118:               
119:               void destroy_timer(int timer_id){
120:                   if ((timer_id<0)||(timer_id>=MAX_TIMERS)) return;
0022CA  500FE7     SUB W0, #0x7, [W15]
0022CC  3E0008     BRA GTU, 0x22DE
121:                   timers[timer_id].status=0;
0022CE  DD0043     SL W0, #3, W0
0022D0  21FAA5     MOV #0x1FAA, W5
0022D2  428280     ADD W5, W0, W5
0022D4  EB0200     CLR W4
0022D6  780A84     MOV W4, [W5]
122:                   timers[timer_id].handler=NULL;
0022D8  21FB05     MOV #0x1FB0, W5
0022DA  428000     ADD W5, W0, W0
0022DC  780804     MOV W4, [W0]
123:               }//f()
0022DE  060000     RETURN
124:               
125:               unsigned long sys_ticks(){
126:                   return ticks;
0022E0  80FD30     MOV ticks, W0
0022E2  80FD41     MOV 0x1FA8, W1
127:               }//f()
0022E4  060000     RETURN
128:               
129:               void __attribute__((interrupt,no_auto_psv)) _SYSTICK_ISR(void){
0022E6  F80036     PUSH RCOUNT
0022E8  BE9F80     MOV.D W0, [W15++]
0022EA  BE9F82     MOV.D W2, [W15++]
0022EC  BE9F84     MOV.D W4, [W15++]
0022EE  BE9F86     MOV.D W6, [W15++]
0022F0  BE9F88     MOV.D W8, [W15++]
0022F2  BE9F8A     MOV.D W10, [W15++]
130:                   int i;
131:                   ticks++;
0022F4  80FD34     MOV ticks, W4
0022F6  80FD45     MOV 0x1FA8, W5
0022F8  420261     ADD W4, #0x1, W4
0022FA  4A82E0     ADDC W5, #0x0, W5
0022FC  88FD34     MOV W4, ticks
0022FE  88FD45     MOV W5, 0x1FA8
132:                   for (i=0;i<MAX_TIMERS;i++){
002300  EB0400     CLR W8
002348  E80408     INC W8, W8
00234A  540FE8     SUB W8, #0x8, [W15]
00234C  3AFFDB     BRA NZ, 0x2304
133:                       if (((timers[i].status&(F_TMR_USED|F_TMR_HALTED))==TMR_RUNNING)){
002304  DD4243     SL W8, #3, W4
002306  21FAA5     MOV #0x1FAA, W5
002308  7A0265     MOV [W5+W4], W4
00230A  620263     AND W4, #0x3, W4
00230C  520FE1     SUB W4, #0x1, [W15]
00230E  3A001C     BRA NZ, 0x2348
134:                           if (--timers[i].countdown==0){
002302  21FAE9     MOV #0x1FAE, W9
002310  DD4343     SL W8, #3, W6
002312  430264     ADD W6, #0x4, W4
002314  7A03E5     MOV [W5+W4], W7
002316  448306     ADD W9, W6, W6
002318  E90B07     DEC W7, [W6]
00231A  7A0265     MOV [W5+W4], W4
00231C  520FE0     SUB W4, #0x0, [W15]
00231E  3A0014     BRA NZ, 0x2348
135:                               timers[i].handler();
002320  DD45C3     SL W8, #3, W11
002322  458266     ADD W11, #0x6, W4
002324  780505     MOV W5, W10
002326  7A026A     MOV [W10+W4], W4
002328  010004     CALL W4
136:                               if (timers[i].status & F_TMR_REPEAT) {
00232A  7D826A     MOV [W10+W11], W4
00232C  620264     AND W4, #0x4, W4
00232E  320006     BRA Z, 0x233C
137:                                   timers[i].countdown=timers[i].delay;
002330  78020B     MOV W11, W4
002332  E88284     INC2 W4, W5
002334  78030A     MOV W10, W6
002336  7A8366     MOV [W6+W5], W6
002338  7A3486     MOV W6, [W9+W4]
00233A  370006     BRA 0x2348
138:                               }else{
139:                                   timers[i].status |= F_TMR_HALTED;
00233C  DD4243     SL W8, #3, W4
00233E  21FAA5     MOV #0x1FAA, W5
002340  7A0365     MOV [W5+W4], W6
002342  428204     ADD W5, W4, W4
002344  A01006     BSET W6, #1
002346  780A06     MOV W6, [W4]
140:                               }
141:                           }//if
142:                       }
143:                   }//for
144:                   SYSTICKIF=0;
00234E  A96084     BCLR IFS0, #3
145:               }// _SYSTICK_ISR()
002350  BE054F     MOV.D [--W15], W10
002352  BE044F     MOV.D [--W15], W8
002354  BE034F     MOV.D [--W15], W6
002356  BE024F     MOV.D [--W15], W4
002358  BE014F     MOV.D [--W15], W2
00235A  BE004F     MOV.D [--W15], W0
00235C  F90036     POP RCOUNT
00235E  064000     RETFIE
146:               
147:               
148:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/text_console.c  ---------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   text_console.h
21:                 * Author: jacques Deschênes
22:                 * Description: manage text writing in video_buffer
23:                 * Created on 28 février 2014, 10:04
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                #include "text_console.h"
29:                
30:                //static text_coord_t cursor_pos;
31:                
32:                //#define X_OFS  ((HPIXELS-CHAR_PER_LINE*CHAR_WIDTH)/2)  // x offset to cursor from screen edge
33:                //#define Y_OFS  ((VPIXELS-LINE_PER_SCREEN*CHAR_HEIGHT)/2) // y offset to cursor from screen edge
34:                
35:                // boolean flags
36:                #define CUR_SHOW 1  // cursor active
37:                #define CUR_VIS  2  // cursor state visible
38:                #define INV_VID  4  // invert video
39:                
40:                
41:                static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
42:                static unsigned char tab_width=TAB_WIDTH;
43:                static cursor_t cur_shape=CR_UNDER;
44:                static unsigned short flags=0;
45:                
46:                
47:                
48:                void scroll_up(void){
49:                    char *src, *dst;
50:                    dst = (char*)video_buffer;
51:                    src = (char*)video_buffer + CHAR_HEIGHT*BYTES_PER_LINE;
52:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001E2A  215F02     MOV #0x15F0, W2
001E2C  208D81     MOV #0x8D8, W1
001E2E  208000     MOV #0x800, W0
001E30  07F39A     RCALL 0x566
53:                    dst= (char*)video_buffer+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*BYTES_PER_LINE;
54:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
001E32  21DF04     MOV #0x1DF0, W4
001E34  0900D7     REPEAT #0xD7
001E36  EB5A00     CLR.B [W4++]
55:                }//scroll_up();
001E38  060000     RETURN
56:                
57:                void scroll_down(void){
58:                    char *src, *dst;
59:                    src = (char*)video_buffer;
60:                    dst = (char*)video_buffer+CHAR_HEIGHT*BYTES_PER_LINE;
61:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
001E3A  215F02     MOV #0x15F0, W2
001E3C  208001     MOV #0x800, W1
001E3E  200D80     MOV #0xD8, W0
001E40  400001     ADD W0, W1, W0
001E42  07F391     RCALL 0x566
62:                    dst=(char*)video_buffer;
63:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
001E44  208004     MOV #0x800, W4
001E46  0900D7     REPEAT #0xD7
001E48  EB5A00     CLR.B [W4++]
64:                }//scroll_down()
001E4A  060000     RETURN
65:                
66:                
67:                void cursor_right(void){
68:                    cx += CHAR_WIDTH;
001E4C  80FF74     MOV cx, W4
001E4E  420266     ADD W4, #0x6, W4
001E50  88FF74     MOV W4, cx
69:                    if (cx>(CHAR_PER_LINE*CHAR_WIDTH)){
001E52  200D25     MOV #0xD2, W5
001E54  520F85     SUB W4, W5, [W15]
001E56  36000A     BRA LEU, 0x1E6C
70:                        cx = 0;
001E58  EF3FEE     CLR cx
71:                        cy += CHAR_HEIGHT;
001E5A  80FF84     MOV cy, W4
001E5C  420268     ADD W4, #0x8, W4
001E5E  88FF84     MOV W4, cy
72:                        if (cy>(LINE_PER_SCREEN*CHAR_HEIGHT)){
001E60  4282E6     ADD W5, #0x6, W5
001E62  520F85     SUB W4, W5, [W15]
001E64  360003     BRA LEU, 0x1E6C
73:                            scroll_up();
001E66  07FFE1     RCALL scroll_up
74:                            cy -= CHAR_HEIGHT;
001E68  2FFF80     MOV #0xFFF8, W0
001E6A  B43FF0     ADD cy
75:                        }
76:                    }
77:                } // cursor_right()
001E6C  060000     RETURN
78:                
79:                void cursor_left(void){
80:                    if (cx>=CHAR_WIDTH){
001E6E  80FF74     MOV cx, W4
001E70  520FE5     SUB W4, #0x5, [W15]
001E72  360003     BRA LEU, 0x1E7A
81:                        cx -= CHAR_WIDTH;
001E74  520266     SUB W4, #0x6, W4
001E76  88FF74     MOV W4, cx
001E78  370009     BRA 0x1E8C
82:                    }else{
83:                        cx = CHAR_WIDTH*(CHAR_PER_LINE-1);
001E7A  200CC4     MOV #0xCC, W4
001E7C  88FF74     MOV W4, cx
84:                        if (cy>=CHAR_HEIGHT){
001E7E  80FF84     MOV cy, W4
001E80  520FE7     SUB W4, #0x7, [W15]
001E82  360003     BRA LEU, 0x1E8A
85:                            cy -= CHAR_HEIGHT;
001E84  520268     SUB W4, #0x8, W4
001E86  88FF84     MOV W4, cy
001E88  370001     BRA 0x1E8C
86:                        }else{
87:                            scroll_down();
001E8A  07FFD7     RCALL scroll_down
88:                        }
89:                    }
90:                }// cursor_left()
001E8C  060000     RETURN
91:                
92:                void cursor_up(void){
93:                    if (cy>=CHAR_HEIGHT){
001E8E  80FF84     MOV cy, W4
001E90  520FE7     SUB W4, #0x7, [W15]
001E92  360003     BRA LEU, 0x1E9A
94:                        cy -= CHAR_HEIGHT;
001E94  520268     SUB W4, #0x8, W4
001E96  88FF84     MOV W4, cy
001E98  370001     BRA 0x1E9C
95:                    }else{
96:                        scroll_down();
001E9A  07FFCF     RCALL scroll_down
97:                    }
98:                }// cursor_up()
001E9C  060000     RETURN
99:                
100:               void cursor_down(void){
101:                   if (cy<=(CHAR_HEIGHT*(LINE_PER_SCREEN-2))){
001E9E  80FF84     MOV cy, W4
001EA0  200C85     MOV #0xC8, W5
001EA2  520F85     SUB W4, W5, [W15]
001EA4  3E0003     BRA GTU, 0x1EAC
102:                       cy += CHAR_HEIGHT;
001EA6  420268     ADD W4, #0x8, W4
001EA8  88FF84     MOV W4, cy
001EAA  370001     BRA 0x1EAE
103:                   }else{
104:                       scroll_up();
001EAC  07FFBE     RCALL scroll_up
105:                   }
106:               }//cursor_down()
001EAE  060000     RETURN
107:               
108:               void crlf(void){
109:                   cx=0;
001EB0  EF3FEE     CLR cx
110:                   if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
001EB2  80FF84     MOV cy, W4
001EB4  200D05     MOV #0xD0, W5
001EB6  520F85     SUB W4, W5, [W15]
001EB8  3A0002     BRA NZ, 0x1EBE
111:                       scroll_up();
001EBA  07FFB7     RCALL scroll_up
001EBC  370002     BRA 0x1EC2
112:                   }else{
113:                       cy += CHAR_HEIGHT;
001EBE  420268     ADD W4, #0x8, W4
001EC0  88FF84     MOV W4, cy
114:                   }
115:               }//crlf()
001EC2  060000     RETURN
116:               
117:               void put_char(unsigned char c){
001EC4  4787E6     ADD W15, #0x6, W15
001EC6  BE9F88     MOV.D W8, [W15++]
001EC8  BE9F8A     MOV.D W10, [W15++]
001ECA  BE9F8C     MOV.D W12, [W15++]
001ECC  781F8E     MOV W14, [W15++]
001F44  E80389     INC W9, W7
001F46  B94A7B     MUL.SU W9, #27, W4
001F48  780284     MOV W4, W5
001F4A  42820D     ADD W5, W13, W4
001F4C  208000     MOV #0x800, W0
001F4E  420200     ADD W4, W0, W4
001F52  DD3743     SL W6, #3, W14
001F54  28D4A6     MOV #0x8D4A, W6
001F56  470306     ADD W14, W6, W6
001F58  E8068D     INC W13, W13
001F5A  42828D     ADD W5, W13, W5
001F5C  428280     ADD W5, W0, W5
001F5E  448069     ADD W9, #0x9, W0
118:                   register int i,l,r,b,x,y;
119:                   x=cx;
001ECE  80FF73     MOV cx, W3
120:                   y=cy;
001ED0  80FF89     MOV cy, W9
121:                   switch (c){
001ED2  504FE9     SUB.B W0, #0x9, [W15]
001ED4  320007     BRA Z, 0x1EE4
001ED6  504FED     SUB.B W0, #0xD, [W15]
001ED8  320003     BRA Z, 0x1EE0
001EDA  504FE8     SUB.B W0, #0x8, [W15]
001EDC  3A001B     BRA NZ, 0x1F14
001EDE  370018     BRA 0x1F10
122:                       case CR:
123:                           crlf();
001EE0  07FFE7     RCALL crlf
124:                           break;
001EE2  37006E     BRA 0x1FC0
125:                       case TAB:
126:                           cx += (cx%tab_width);
001EE4  21FFA4     MOV #0x1FFA, W4
001EE6  784214     MOV.B [W4], W4
001EE8  FB8204     ZE W4, W4
001EEA  BE9F80     MOV.D W0, [W15++]
001EEC  090011     REPEAT #0x11
001EEE  D88184     DIV.UW W3, W4
001EF0  780201     MOV W1, W4
001EF2  BE004F     MOV.D [--W15], W0
001EF4  420183     ADD W4, W3, W3
001EF6  88FF73     MOV W3, cx
127:                           if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
001EF8  200D14     MOV #0xD1, W4
001EFA  518F84     SUB W3, W4, [W15]
001EFC  360061     BRA LEU, 0x1FC0
128:                               cx = 0;
001EFE  EF3FEE     CLR cx
129:                               if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
001F00  E90204     DEC W4, W4
001F02  548F84     SUB W9, W4, [W15]
001F04  3A0002     BRA NZ, 0x1F0A
130:                                   scroll_up();
001F06  07FF91     RCALL scroll_up
001F08  37005B     BRA 0x1FC0
131:                               }else{
132:                                   cy += CHAR_HEIGHT;
001F0A  4484E8     ADD W9, #0x8, W9
001F0C  88FF89     MOV W9, cy
001F0E  370058     BRA 0x1FC0
133:                               }
134:                           }
135:                           break;
136:                       case '\b':
137:                           cursor_left();
001F10  07FFAE     RCALL cursor_left
138:                           break;
001F12  370056     BRA 0x1FC0
139:                       default:
140:                           if ((c<32) || (c>=(FONT_SIZE+32))) break;
001F14  B3CE06     MOV #0xE0, W6
001F16  404306     ADD.B W0, W6, W6
001F18  B3C6D4     MOV #0x6D, W4
001F1A  534F84     SUB.B W6, W4, [W15]
001F1C  3E0051     BRA GTU, 0x1FC0
141:                           c -=32;
142:                           b=x>>3; // character position in video_buffer
001F1E  DE9EC3     ASR W3, #3, W13
143:                           r=0;
144:                           l=(8-CHAR_WIDTH)-(x&7); // shift inside this byte
001F20  6181E7     AND W3, #0x7, W3
001F22  1181E2     SUBR W3, #0x2, W3
145:                           if (l<0){
146:                               r=-l;
001F24  DE9A4F     ASR W3, #15, W4
001F26  EA0083     NEG W3, W1
001F28  608084     AND W1, W4, W1
147:                           }
148:                           for (i=0;i<8;i++){
001FBA  538F80     SUB W7, W0, [W15]
001FBC  3AFFD1     BRA NZ, 0x1F60
149:                               if (r){
001F60  508FE0     SUB W1, #0x0, [W15]
001F62  320018     BRA Z, 0x1F94
150:                                   if (flags & INV_VID){
001F2A  80FF52     MOV flags, W2
001F2C  610164     AND W2, #0x4, W2
001F64  510FE0     SUB W2, #0x0, [W15]
001F66  32000B     BRA Z, 0x1F7E
151:                                       video_buffer[y][b] |= (0x3f>>r);
001F2E  2003FA     MOV #0x3F, W10
001F30  DED601     ASR W10, W1, W12
001F70  764694     IOR.B W12, [W4], W13
152:                                       video_buffer[y][b] &=~(font6x8[(int)c][i]>>r);
001F68  784696     MOV.B [W6], W13
001F6A  FB848D     ZE W13, W9
001F6C  DECF01     ASR W9, W1, W14
001F6E  EAC70E     COM.B W14, W14
001F72  674A0D     AND.B W14, W13, [W4]
153:                                       video_buffer[y][b+1] |= (0x3f<<(8-r));
001F32  108468     SUBR W1, #0x8, W8
001F34  DD5588     SL W10, W8, W11
001F78  75C695     IOR.B W11, [W5], W13
154:                                       video_buffer[y][b+1] &= ~(font6x8[(int)c][i]<<(8-r));
001F74  DD4C88     SL W9, W8, W9
001F76  EAC489     COM.B W9, W9
001F7A  64CA8D     AND.B W9, W13, [W5]
001F7C  37001A     BRA 0x1FB2
155:                                   }else{
156:                                       video_buffer[y][b] &= ~(0x3f>>r);
001F36  EAC20C     COM.B W12, W4
001F38  9FF784     MOV.B W4, [W15-16]
001F82  97F68F     MOV.B [W15-16], W13
001F84  66C714     AND.B W13, [W4], W14
157:                                       video_buffer[y][b] |= font6x8[(int)c][i]>>r;
001F7E  784716     MOV.B [W6], W14
001F80  FB848E     ZE W14, W9
001F86  DECE81     ASR W9, W1, W13
001F88  774A0D     IOR.B W14, W13, [W4]
158:                                       video_buffer[y][b+1] &= ~(0x3f<<(8-r));
001F3A  EAC70B     COM.B W11, W14
001F3C  9FEFFE     MOV.B W14, [W15-17]
001F8A  97EF7F     MOV.B [W15-17], W14
001F8C  674695     AND.B W14, [W5], W13
159:                                       video_buffer[y][b+1] |= font6x8[(int)c][i]<<(8-r);
001F8E  DD4C88     SL W9, W8, W9
001F90  76CA89     IOR.B W13, W9, [W5]
001F92  37000F     BRA 0x1FB2
160:                                   }
161:                                   y++;
162:                               } else{
163:                                   if (flags & INV_VID){
001F94  510FE0     SUB W2, #0x0, [W15]
001F96  320007     BRA Z, 0x1FA6
164:                                       video_buffer[y][b] |= (0x3f<<l);
001F3E  DD5503     SL W10, W3, W10
001FA0  754494     IOR.B W10, [W4], W9
165:                                       video_buffer[y++][b] &=~(font6x8[(int)c][i]<<l);
001F50  FB8306     ZE W6, W6
001F98  784496     MOV.B [W6], W9
001F9A  FB8689     ZE W9, W13
001F9C  DD6E83     SL W13, W3, W13
001F9E  EAC68D     COM.B W13, W13
001FA2  66CA09     AND.B W13, W9, [W4]
001FA4  370006     BRA 0x1FB2
166:                                   }else{
167:                                       video_buffer[y][b] &= ~(0x3f<<l);
001F40  EAC20A     COM.B W10, W4
001F42  9FEFE4     MOV.B W4, [W15-18]
001FA6  97EF6F     MOV.B [W15-18], W14
001FA8  674694     AND.B W14, [W4], W13
168:                                       video_buffer[y++][b] |= font6x8[(int)c][i]<<l;
001FAA  784716     MOV.B [W6], W14
001FAC  FB848E     ZE W14, W9
001FAE  DD4C83     SL W9, W3, W9
001FB0  76CA09     IOR.B W13, W9, [W4]
001FB2  E80387     INC W7, W7
001FB4  42027B     ADD W4, #0x1B, W4
001FB6  E80306     INC W6, W6
001FB8  4282FB     ADD W5, #0x1B, W5
169:                                   }
170:                               }
171:                           }
172:                           cursor_right();
001FBE  07FF46     RCALL cursor_right
173:                   }//switch(c)
174:               }//put_char()
001FC0  78074F     MOV [--W15], W14
001FC2  BE064F     MOV.D [--W15], W12
001FC4  BE054F     MOV.D [--W15], W10
001FC6  BE044F     MOV.D [--W15], W8
001FC8  B1006F     SUB #0x6, W15
001FCA  060000     RETURN
175:               
176:               void clear_screen(){
177:                   memset(video_buffer,0,HPIXELS/8*VPIXELS);
001FCC  208004     MOV #0x800, W4
001FCE  0916C7     REPEAT #0x16C7
001FD0  EB5A00     CLR.B [W4++]
178:                   cx=0;
001FD2  EB0200     CLR W4
001FD4  88FF74     MOV W4, cx
179:                   cy=0;
001FD6  88FF84     MOV W4, cy
180:               } // clear_screen()
001FD8  060000     RETURN
181:               
182:               void print(const char *text){
001FDA  781F88     MOV W8, [W15++]
001FDC  780400     MOV W0, W8
183:                   while (*text){
001FDE  784018     MOV.B [W8], W0
001FE0  504FE0     SUB.B W0, #0x0, [W15]
001FE2  320004     BRA Z, 0x1FEC
001FE6  784058     MOV.B [++W8], W0
001FE8  504FE0     SUB.B W0, #0x0, [W15]
001FEA  3AFFFC     BRA NZ, 0x1FE4
184:                       put_char(*text++);
001FE4  07FF6F     RCALL put_char
185:                   }
186:               }// print()
001FEC  78044F     MOV [--W15], W8
001FEE  060000     RETURN
187:               
188:               void print_hex(unsigned int hex, unsigned char width){
001FF0  FA000C     LNK #0xC
189:                   char c[12], *d;
190:                   int i;
191:                   c[11]=0;
001FF2  EB4200     CLR.B W4
001FF4  9FFFF4     MOV.B W4, [W15-1]
192:                   d= &c[10];
001FF8  E9820F     DEC2 W15, W4
193:                   for(i=width;i>=0||hex;i--){
001FF6  FB8301     ZE W1, W6
001FFA  37000C     BRA 0x2014
002012  E90306     DEC W6, W6
002014  530FE0     SUB W6, #0x0, [W15]
002016  3DFFF2     BRA GE, 0x1FFC
002018  500FE0     SUB W0, #0x0, [W15]
00201A  3AFFF0     BRA NZ, 0x1FFC
194:                       *d=(hex%16);
001FFC  6042EF     AND.B W0, #0xF, W5
001FFE  784A05     MOV.B W5, [W4]
195:                       if (*d<10)
002000  52CFE9     SUB.B W5, #0x9, [W15]
002002  3C0003     BRA GT, 0x200A
196:                           *d += '0';
002004  B3C307     MOV #0x30, W7
002006  42CA07     ADD.B W5, W7, [W4]
002008  370002     BRA 0x200E
197:                       else
198:                           *d += 'A'-10;
00200A  B3C377     MOV #0x37, W7
00200C  42CA07     ADD.B W5, W7, [W4]
199:                       hex /=16;
00200E  DE0044     LSR W0, #4, W0
200:                       d--;
002010  E90204     DEC W4, W4
201:                   }
202:                   print(++d);
00201C  E80004     INC W4, W0
00201E  07FFDD     RCALL print
203:               } // print_hex()
002020  FA8000     ULNK
002022  060000     RETURN
204:               
205:               void print_int(int number, unsigned short width){ // imprime entier,width inclus le signe
002024  FA000E     LNK #0xE
00206A  538005     SUB W7, W5, W0
00206C  780207     MOV W7, W4
206:                   int sign=0, i;
002030  EB0100     CLR W2
207:                   char str[14], *d;
208:                   str[13]=0;
002026  EB4200     CLR.B W4
002028  9FFFF4     MOV.B W4, [W15-1]
00202A  508FED     SUB W1, #0xD, [W15]
00202C  360001     BRA LEU, 0x2030
00202E  2000D1     MOV #0xD, W1
209:                   d=&str[12];
002040  E9820F     DEC2 W15, W4
00205A  E9838F     DEC2 W15, W7
210:                   if (width>13){width=13;}
211:                   if (number<0){
002032  500F82     SUB W0, W2, [W15]
002034  3D0002     BRA GE, 0x203A
212:                       sign=1;
002038  200012     MOV #0x1, W2
213:                       number = -number;
002036  EA0000     NEG W0, W0
214:                   }
215:                   //for (i=--width;i>=0||number;i--){
216:                   i=width;
00203A  780281     MOV W1, W5
217:                   while (number>0){
00203C  500FE0     SUB W0, #0x0, [W15]
00203E  34000D     BRA LE, 0x205A
002054  500FE0     SUB W0, #0x0, [W15]
002056  3CFFF6     BRA GT, 0x2044
002058  370001     BRA 0x205C
218:                      *d--=(number%10)+'0';
002042  2000A6     MOV #0xA, W6
002044  780381     MOV W1, W7
002046  090011     REPEAT #0x11
002048  D80006     DIV.SW W0, W6
00204A  FD0381     EXCH W1, W7
00204C  B3C303     MOV #0x30, W3
00204E  43D203     ADD.B W7, W3, [W4--]
002050  780384     MOV W4, W7
219:                       number /= 10;
220:                       i--;
002052  E90285     DEC W5, W5
221:                   }
222:                   if (i==width){
00205C  508F85     SUB W1, W5, [W15]
00205E  3A0003     BRA NZ, 0x2066
223:                       *d--='0';
002060  B3C304     MOV #0x30, W4
002062  785384     MOV.B W4, [W7--]
224:                       i--;
002064  E90285     DEC W5, W5
225:                   }
226:                   while (i>0){
002066  528FE0     SUB W5, #0x0, [W15]
002068  340007     BRA LE, 0x2078
002072  520F80     SUB W4, W0, [W15]
002074  3AFFFD     BRA NZ, 0x2070
002076  538385     SUB W7, W5, W7
227:                       *d--=' ';
00206E  B3C206     MOV #0x20, W6
002070  785206     MOV.B W6, [W4--]
228:                       i--;
229:                   }
230:                   if (sign){*d='-';}else{*d=' ';}
002078  510FE0     SUB W2, #0x0, [W15]
00207A  320003     BRA Z, 0x2082
00207C  B3C2D4     MOV #0x2D, W4
00207E  784B84     MOV.B W4, [W7]
002080  370002     BRA 0x2086
002082  B3C204     MOV #0x20, W4
002084  784B84     MOV.B W4, [W7]
231:                   print(d);
002086  780007     MOV W7, W0
002088  07FFA8     RCALL print
232:               }// print_int()
00208A  FA8000     ULNK
00208C  060000     RETURN
233:               
234:               void set_tab_width(unsigned char width){
235:                   tab_width=width;
00208E  B7FFFA     MOV.B WREG, tab_width
236:               }// set_tab_width()
002090  060000     RETURN
237:               
238:               void clear_eol(void){
002092  BE9F88     MOV.D W8, [W15++]
002094  BE9F8A     MOV.D W10, [W15++]
239:                   int x,y;
240:                   x=cx;
002096  80FF7A     MOV cx, W10
241:                   y=cy;
002098  80FF8B     MOV cy, W11
242:                   while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
00209A  200C54     MOV #0xC5, W4
00209C  550F84     SUB W10, W4, [W15]
00209E  3E0007     BRA GTU, 0x20AE
0020A2  780484     MOV W4, W9
0020A8  80FF74     MOV cx, W4
0020AA  520F89     SUB W4, W9, [W15]
0020AC  36FFFB     BRA LEU, 0x20A4
243:                       put_char(32);
0020A0  B3C208     MOV #0x20, W8
0020A4  784008     MOV.B W8, W0
0020A6  07FF0E     RCALL put_char
244:                   }
245:                   put_char(32);
0020AE  B3C200     MOV #0x20, W0
0020B0  07FF09     RCALL put_char
246:                   cx=x;
0020B2  88FF7A     MOV W10, cx
247:                   cy=y;
0020B4  88FF8B     MOV W11, cy
248:               }// clear_eol()
0020B6  BE054F     MOV.D [--W15], W10
0020B8  BE044F     MOV.D [--W15], W8
0020BA  060000     RETURN
249:               
250:               text_coord_t get_curpos(){
251:                   text_coord_t cpos;
252:                   cpos.x = cx/CHAR_WIDTH;
0020BC  80FF75     MOV cx, W5
0020BE  200064     MOV #0x6, W4
0020C0  781F80     MOV W0, [W15++]
0020C2  090011     REPEAT #0x11
0020C4  D88284     DIV.UW W5, W4
0020C6  780200     MOV W0, W4
0020C8  78004F     MOV [--W15], W0
0020CA  780804     MOV W4, [W0]
253:                   cpos.y = cy/CHAR_HEIGHT;
0020CC  80FF84     MOV cy, W4
0020CE  DE2243     LSR W4, #3, W4
0020D0  980014     MOV W4, [W0+2]
254:                   return cpos;
255:               } // get_cursor_pos()
0020D2  060000     RETURN
256:               
257:               void set_curpos(unsigned short x, unsigned short y){// {x,y} character coord.
258:                   if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
0020D4  200224     MOV #0x22, W4
0020D6  500F84     SUB W0, W4, [W15]
0020D8  3E0006     BRA GTU, 0x20E6
0020DA  508FFA     SUB W1, #0x1A, [W15]
0020DC  3E0004     BRA GTU, 0x20E6
259:                       return;
260:                   cx=x*CHAR_WIDTH;
0020DE  B90266     MUL.SU W0, #6, W4
0020E0  88FF74     MOV W4, cx
261:                   cy=y*CHAR_HEIGHT;
0020E2  DD08C3     SL W1, #3, W1
0020E4  88FF81     MOV W1, cy
262:               }//set_curpos()
0020E6  060000     RETURN
263:               
264:               void invert_char(void){// invert pixels of character at cursor position
0020E8  BE9F88     MOV.D W8, [W15++]
002104  E80287     INC W7, W5
002106  B93C7B     MUL.SU W7, #27, W8
002108  420008     ADD W4, W8, W0
00210A  208004     MOV #0x800, W4
00210C  400204     ADD W0, W4, W4
00210E  4383EA     ADD W7, #0xA, W7
265:                   register int i,l,r,b,x,y;
266:                   x=cx;
0020EA  80FF71     MOV cx, W1
267:                   y=cy;
0020EC  80FF87     MOV cy, W7
268:                   b=x>>3;
0020EE  DE8A43     ASR W1, #3, W4
269:                   r=0;
270:                   l=(8-CHAR_WIDTH)-(x&7);
0020F0  6080E7     AND W1, #0x7, W1
0020F2  1080E2     SUBR W1, #0x2, W1
271:                   if (l<0){
272:                       r=-l;
0020F4  DE8ACF     ASR W1, #15, W5
0020F6  EA0301     NEG W1, W6
0020F8  630305     AND W6, W5, W6
273:                   }
274:                   for (i=9;i;i--){
002124  528F87     SUB W5, W7, [W15]
002126  3AFFF4     BRA NZ, 0x2110
275:                       if (r){
002110  530FE0     SUB W6, #0x0, [W15]
002112  320005     BRA Z, 0x211E
276:                           video_buffer[y][b] ^= (0x3f>>r);
0020FA  2003F5     MOV #0x3F, W5
0020FC  DEA986     ASR W5, W6, W3
002114  69CA14     XOR.B W3, [W4], [W4]
277:                           video_buffer[y][b+1] ^= (0x3f<<(8-r));
0020FE  130168     SUBR W6, #0x8, W2
002100  DD2902     SL W5, W2, W2
002116  904014     MOV.B [W4+1], W0
002118  684002     XOR.B W0, W2, W0
00211A  984210     MOV.B W0, [W4+1]
00211C  370001     BRA 0x2120
278:                           y++;
279:                       } else{
280:                           video_buffer[y++][b] ^= (0x3f<<l);
002102  DD2881     SL W5, W1, W1
00211E  68CA14     XOR.B W1, [W4], [W4]
002120  E80285     INC W5, W5
002122  42027B     ADD W4, #0x1B, W4
281:                       }
282:                   }
283:               }//invert_char()
002128  BE044F     MOV.D [--W15], W8
00212A  060000     RETURN
284:               
285:               static void toggle_underscore(void){
286:                   register int l,r,b,x;
287:                   x=cx;
001DE2  80FF74     MOV cx, W4
288:                   b=x>>5;
001DE4  DEA2C5     ASR W4, #5, W5
289:                   r=0;
290:                   l=(8-CHAR_WIDTH)-(x&7);
001DE6  620267     AND W4, #0x7, W4
001DE8  120262     SUBR W4, #0x2, W4
291:                   if (l<0){
001DEA  3B0014     BRA NN, 0x1E14
292:                       r=-l;
001DEC  EA0304     NEG W4, W6
293:                   }
294:                   if (r){
001DEE  320012     BRA Z, 0x1E14
295:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
001DF0  80FF80     MOV cy, W0
001DF2  400067     ADD W0, #0x7, W0
001DF4  208004     MOV #0x800, W4
001DF6  B9007B     MUL.SU W0, #27, W0
001DF8  400085     ADD W0, W5, W1
001DFA  420101     ADD W4, W1, W2
001DFC  2003F7     MOV #0x3F, W7
001DFE  DEB986     ASR W7, W6, W3
001E00  78C0E4     MOV.B [W4+W1], W1
001E02  68C903     XOR.B W1, W3, [W2]
296:                       video_buffer[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<(8-r));
001E04  E80285     INC W5, W5
001E06  400285     ADD W0, W5, W5
001E08  420005     ADD W4, W5, W0
001E0A  130368     SUBR W6, #0x8, W6
001E0C  DD3B86     SL W7, W6, W7
001E0E  7AC264     MOV.B [W4+W5], W4
001E10  6A4807     XOR.B W4, W7, [W0]
001E12  37000A     BRA 0x1E28
297:                   } else{
298:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
001E14  80FF80     MOV cy, W0
001E16  400067     ADD W0, #0x7, W0
001E18  208006     MOV #0x800, W6
001E1A  B9007B     MUL.SU W0, #27, W0
001E1C  428280     ADD W5, W0, W5
001E1E  430385     ADD W6, W5, W7
001E20  2003F0     MOV #0x3F, W0
001E22  DD0204     SL W0, W4, W4
001E24  7AC2E6     MOV.B [W6+W5], W5
001E26  6ACB84     XOR.B W5, W4, [W7]
299:                   }
300:               }//toggle_underscore()
001E28  060000     RETURN
301:               
302:               void show_cursor(BOOL show){
00212C  781F88     MOV W8, [W15++]
303:                   if (show){
00212E  500FE0     SUB W0, #0x0, [W15]
002130  32000B     BRA Z, 0x2148
304:                       flags |= CUR_SHOW;
002132  80FF54     MOV flags, W4
002134  A00004     BSET W4, #0
305:                       flags ^= CUR_VIS;
002136  A21004     BTG W4, #1
002138  88FF54     MOV W4, flags
306:                       if (cur_shape==CR_BLOCK){
00213A  80FF64     MOV cur_shape, W4
00213C  520FE1     SUB W4, #0x1, [W15]
00213E  3A0002     BRA NZ, 0x2144
307:                           invert_char();
002140  07FFD3     RCALL invert_char
002142  37000E     BRA 0x2160
308:                       }else{
309:                           toggle_underscore();
002144  07FE4E     RCALL toggle_underscore
002146  37000C     BRA 0x2160
310:                       }
311:                   }else{
312:                       if (flags & CUR_VIS){
002148  80FF58     MOV flags, W8
00214A  640262     AND W8, #0x2, W4
00214C  320008     BRA Z, 0x215E
313:                           if (cur_shape==CR_BLOCK){
00214E  80FF64     MOV cur_shape, W4
002150  520FE1     SUB W4, #0x1, [W15]
002152  3A0002     BRA NZ, 0x2158
314:                               invert_char();
002154  07FFC9     RCALL invert_char
002156  370001     BRA 0x215A
315:                           }else{
316:                               toggle_underscore();
002158  07FE44     RCALL toggle_underscore
317:                           }
318:                           flags &= ~CUR_VIS;
00215A  A11008     BCLR W8, #1
00215C  88FF58     MOV W8, flags
319:                       }
320:                       flags &= ~CUR_SHOW;
00215E  A91FEA     BCLR flags, #0
321:                   }
322:               
323:               }// show_cursor()
002160  78044F     MOV [--W15], W8
002162  060000     RETURN
324:               
325:               void set_cursor(cursor_t shape){
002164  781F88     MOV W8, [W15++]
002166  780400     MOV W0, W8
326:                   if (flags & CUR_VIS){
002168  AB3FEA     BTST flags, #1
00216A  320006     BRA Z, 0x2178
327:                       show_cursor(FALSE);
00216C  EB0000     CLR W0
00216E  07FFDE     RCALL show_cursor
328:                       cur_shape=shape;
002170  88FF68     MOV W8, cur_shape
329:                       show_cursor(TRUE);
002172  200010     MOV #0x1, W0
002174  07FFDB     RCALL show_cursor
002176  370001     BRA 0x217A
330:                   }else{
331:                       cur_shape=shape;
002178  88FF68     MOV W8, cur_shape
332:                   }
333:               }// set_cursor()
00217A  78044F     MOV [--W15], W8
00217C  060000     RETURN
334:               
335:               
336:               void invert_video(){
337:                   flags |= INV_VID;
00217E  A85FEA     BSET flags, #2
338:               }//invert_video()
002180  060000     RETURN
339:               
340:               void normal_video(){
341:                   flags &= ~INV_VID;
002182  A95FEA     BCLR flags, #2
342:               }//normal_video()
002184  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/sound.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   sound.c
21:                 * Author: jacques Deschênes
22:                 * Description:  sound generation using PWM D.A.C.
23:                 * Created on 25 février 2014, 16:43
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include "sound.h"
28:                
29:                #define F_TONE  1  // tone playing flag
30:                #define F_TUNE  2  // flag tune playing
31:                #define F_WHITE 4  // white noise generation
32:                
33:                #define mTone_off() (AUDIOCON.OCM=0)
34:                #define mTone_on()  (AUDIOCON.OCM=5)
35:                
36:                
37:                volatile unsigned char fSound=0; // boolean flags
38:                volatile int tmrId;  // duratio timer identifier
39:                volatile unsigned int *tones_list;  // list of tones and interval for playing tune
40:                int tick_msec=10; // tick interval in milliseconds, default 10msec.
41:                
42:                void cb_tone(void){ // timer call back function
43:                    mTone_off();
0024FC  800C54     MOV OC2CON, W4
0024FE  A10004     BCLR W4, #0
002500  A11004     BCLR W4, #1
002502  A12004     BCLR W4, #2
002504  880C54     MOV W4, OC2CON
44:                    fSound &= ~(F_TONE|F_WHITE);
002506  21FF25     MOV #0x1FF2, W5
002508  784295     MOV.B [W5], W5
00250A  B3CFA4     MOV #0xFA, W4
00250C  62C204     AND.B W5, W4, W4
00250E  780004     MOV W4, W0
002510  B7FFF2     MOV.B WREG, fSound
45:                }// f()
002512  060000     RETURN
46:                
47:                void sound_init(int tick_time){
48:                    if (tick_time) tick_msec=tick_time;
002514  500FE0     SUB W0, #0x0, [W15]
002516  320001     BRA Z, 0x251A
002518  88FFA0     MOV W0, tick_msec
49:                    tmrId=create_timer(1,TIMER_SINGLE,(timer_handler_t *)cb_tone);
00251A  224FC2     MOV #0x24FC, W2
00251C  EB0080     CLR W1
00251E  200010     MOV #0x1, W0
002520  07FE84     RCALL create_timer
002522  88FFB0     MOV W0, tmrId
50:                    AUDIOCON.OCTSEL=1; // select OCx timer
002524  A8618A     BSET OC2CON, #3
51:                    AUDIOR=0;
002526  EF2188     CLR OC2R
52:                    AUDIOTMR.TON=0;
002528  A9E113     BCLR 0x113, #7
53:                    AUDIOTMR.TCKPS=1; // 1:8  // timer clock prescale divisor
00252A  800894     MOV T3CON, W4
00252C  A04004     BSET W4, #4
00252E  A15004     BCLR W4, #5
002530  880894     MOV W4, T3CON
54:                }//f()
002532  060000     RETURN
55:                
56:                // play tone in background
57:                void tone(unsigned freq, // frequency in hertz
58:                          unsigned msec){ // duration in  milliseconds
002534  BE9F88     MOV.D W8, [W15++]
002536  781F8A     MOV W10, [W15++]
002538  780501     MOV W1, W10
59:                    //
60:                    mTone_off(); 
00253A  800C54     MOV OC2CON, W4
00253C  A10004     BCLR W4, #0
00253E  A11004     BCLR W4, #1
002540  A12004     BCLR W4, #2
002542  880C54     MOV W4, OC2CON
61:                    AUDIORS=FCY/16/freq; // determine tone duty cycle
002544  B80461     MUL.UU W0, #1, W8
002546  BE0108     MOV.D W8, W2
002548  242400     MOV #0x4240, W0
00254A  2000F1     MOV #0xF, W1
00254C  07EFBD     RCALL 0x4C8
00254E  880C30     MOV W0, OC2RS
62:                    AUDIOTMR.TON=0;
002550  A9E113     BCLR 0x113, #7
63:                    AUDIOPR=(FCY/8/freq)-1; // pwm period
002552  BE0108     MOV.D W8, W2
002554  284800     MOV #0x8480, W0
002556  2001E1     MOV #0x1E, W1
002558  07EFB7     RCALL 0x4C8
00255A  E90200     DEC W0, W4
00255C  880874     MOV W4, PR3
64:                    fSound |=F_TONE;
00255E  A81FF2     BSET fSound, #0
65:                    mTone_on(); 
002560  800C54     MOV OC2CON, W4
002562  A00004     BSET W4, #0
002564  A11004     BCLR W4, #1
002566  A02004     BSET W4, #2
002568  880C54     MOV W4, OC2CON
66:                    AUDIOTMR.TON=1;
00256A  A8E113     BSET 0x113, #7
67:                    update_timer(tmrId,msec/tick_msec);
00256C  80FFB0     MOV tmrId, W0
00256E  80FFA4     MOV tick_msec, W4
002570  781F80     MOV W0, [W15++]
002572  090011     REPEAT #0x11
002574  D88504     DIV.UW W10, W4
002576  780080     MOV W0, W1
002578  78004F     MOV [--W15], W0
00257A  07FE9C     RCALL update_timer
68:                    start_timer(tmrId);
00257C  80FFB0     MOV tmrId, W0
00257E  07FE88     RCALL start_timer
69:                } //tone();
002580  78054F     MOV [--W15], W10
002582  BE044F     MOV.D [--W15], W8
002584  060000     RETURN
70:                
71:                // play tune in background
72:                void tune(const unsigned *buffer){
73:                    tones_list=(unsigned *)buffer;
002586  88FFC0     MOV W0, tones_list
74:                    if (*tones_list && *(tones_list+1)){
002588  EB0200     CLR W4
00258A  120F90     SUBR W4, [W0], [W15]
00258C  32000C     BRA Z, 0x25A6
00258E  780200     MOV W0, W4
002590  EB0280     CLR W5
002592  128FD4     SUBR W5, [++W4], [W15]
002594  320008     BRA Z, 0x25A6
75:                        fSound |= F_TUNE;
002596  A83FF2     BSET fSound, #1
76:                        AUDIOIF=0;
002598  A90085     BCLR 0x85, #0
77:                        AUDIOIE=1;
00259A  A80095     BSET 0x95, #0
78:                        tone(*tones_list++,*tones_list++);
00259C  780090     MOV [W0], W1
00259E  88FFC4     MOV W4, tones_list
0025A0  780034     MOV [W4++], W0
0025A2  88FFC4     MOV W4, tones_list
0025A4  07FFC7     RCALL tone
79:                    }
80:                }//tune()
0025A6  060000     RETURN
81:                
82:                
83:                void white_noise(unsigned msec){
84:                    if (!fSound){
0025A8  21FF24     MOV #0x1FF2, W4
0025AA  784214     MOV.B [W4], W4
0025AC  524FE0     SUB.B W4, #0x0, [W15]
0025AE  3A0010     BRA NZ, 0x25D0
85:                        AUDIOTMR.TON=0;
0025B0  A9E113     BCLR 0x113, #7
86:                        AUDIOPR=(FCY/8/10000)-1; // pwm period
0025B2  200C74     MOV #0xC7, W4
0025B4  880874     MOV W4, PR3
87:                        AUDIOTMR.TON=0;
0025B6  A9E113     BCLR 0x113, #7
88:                        AUDIOIF=0;
0025B8  A90085     BCLR 0x85, #0
89:                        AUDIOIE=1;
0025BA  A80095     BSET 0x95, #0
90:                        AUDIOTMR.TON=1;
0025BC  A8E113     BSET 0x113, #7
91:                        update_timer(tmrId,msec/tick_msec);
0025BE  80FFB4     MOV tmrId, W4
0025C0  80FFA5     MOV tick_msec, W5
0025C2  090011     REPEAT #0x11
0025C4  D88005     DIV.UW W0, W5
0025C6  FD0080     EXCH W0, W1
0025C8  780004     MOV W4, W0
0025CA  07FE74     RCALL update_timer
92:                        start_timer(tmrId);
0025CC  80FFB0     MOV tmrId, W0
0025CE  07FE60     RCALL start_timer
93:                    }
94:                    fSound |= F_WHITE;
0025D0  A85FF2     BSET fSound, #2
95:                }// f()
0025D2  060000     RETURN
96:                
97:                void while_sound(){
98:                    while (fSound);
0025D4  21FF24     MOV #0x1FF2, W4
0025D6  784214     MOV.B [W4], W4
0025D8  524FE0     SUB.B W4, #0x0, [W15]
0025DA  3AFFFC     BRA NZ, while_sound
99:                }// f()
0025DC  060000     RETURN
100:               
101:               // interrupt at end of tone cycle
102:               void __attribute__((interrupt, no_auto_psv))  _AUDIO_ISR(void){
0025DE  F80036     PUSH RCOUNT
0025E0  BE9F80     MOV.D W0, [W15++]
0025E2  BE9F82     MOV.D W2, [W15++]
0025E4  BE9F84     MOV.D W4, [W15++]
0025E6  BE9F86     MOV.D W6, [W15++]
103:                  unsigned int f,d;
104:                  if (fSound&F_WHITE){
0025E8  21FF24     MOV #0x1FF2, W4
0025EA  784214     MOV.B [W4], W4
0025EC  620264     AND W4, #0x4, W4
0025EE  320007     BRA Z, 0x25FE
105:                      P_NOISE_OUT=rand()&1;
0025F0  07EFD2     RCALL 0x596
0025F2  6002E1     AND W0, #0x1, W5
0025F4  DD2ACA     SL W5, #10, W5
0025F6  801664     MOV LATB, W4
0025F8  A1A004     BCLR W4, #10
0025FA  720205     IOR W4, W5, W4
0025FC  881664     MOV W4, LATB
106:                  }
107:                  if (!fSound) {
0025FE  21FF24     MOV #0x1FF2, W4
002600  784214     MOV.B [W4], W4
002602  524FE0     SUB.B W4, #0x0, [W15]
002604  3A0003     BRA NZ, 0x260C
108:                      AUDIOIE=0;
002606  A90095     BCLR 0x95, #0
109:                      AUDIOTMR.TON=0;
002608  A9E113     BCLR 0x113, #7
00260A  370027     BRA 0x265A
110:                  }else if (fSound==(fSound & F_TUNE)){
00260C  21FF25     MOV #0x1FF2, W5
00260E  784295     MOV.B [W5], W5
002610  21FF24     MOV #0x1FF2, W4
002612  784214     MOV.B [W4], W4
002614  FB8285     ZE W5, W5
002616  620262     AND W4, #0x2, W4
002618  528F84     SUB W5, W4, [W15]
00261A  3A001F     BRA NZ, 0x265A
111:                      f=*tones_list++;
00261C  80FFC4     MOV tones_list, W4
00261E  780034     MOV [W4++], W0
002620  88FFC4     MOV W4, tones_list
112:                      d=*tones_list++;
002622  7800B4     MOV [W4++], W1
002624  88FFC4     MOV W4, tones_list
113:                      if (d){
002626  508FE0     SUB W1, #0x0, [W15]
002628  320015     BRA Z, 0x2654
114:                           if (f){
00262A  500FE0     SUB W0, #0x0, [W15]
00262C  320002     BRA Z, 0x2632
115:                               tone(f,d);
00262E  07FF82     RCALL tone
002630  370014     BRA 0x265A
116:                           }else{
117:                               update_timer(tmrId,d/tick_msec);
002632  80FFB0     MOV tmrId, W0
002634  80FFA4     MOV tick_msec, W4
002636  781F80     MOV W0, [W15++]
002638  090011     REPEAT #0x11
00263A  D88084     DIV.UW W1, W4
00263C  780080     MOV W0, W1
00263E  78004F     MOV [--W15], W0
002640  07FE39     RCALL update_timer
118:                               start_timer(tmrId);
002642  80FFB0     MOV tmrId, W0
002644  07FE25     RCALL start_timer
119:                               fSound |= F_TONE;
002646  A81FF2     BSET fSound, #0
120:                               mTone_on();
002648  800C54     MOV OC2CON, W4
00264A  A00004     BSET W4, #0
00264C  A11004     BCLR W4, #1
00264E  A02004     BSET W4, #2
002650  880C54     MOV W4, OC2CON
002652  370003     BRA 0x265A
121:                           }
122:                      }else{
123:                          fSound=0;
002654  EF7FF2     CLR.B fSound
124:                          AUDIOIE=0;
002656  A90095     BCLR 0x95, #0
125:                          AUDIOTMR.TON=0;
002658  A9E113     BCLR 0x113, #7
126:                      } // if
127:                  }
128:                  AUDIOIF=0;
00265A  A90085     BCLR 0x85, #0
129:               }// _AUDIO_ISR
00265C  BE034F     MOV.D [--W15], W6
00265E  BE024F     MOV.D [--W15], W4
002660  BE014F     MOV.D [--W15], W2
002662  BE004F     MOV.D [--W15], W0
002664  F90036     POP RCOUNT
002666  064000     RETFIE
130:               
131:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snes_paddle.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snes_paddle.c
21:                 * Author: jacques Deschênes
22:                 * Description:  SNES gemepad interface
23:                 *              1) a pulse on paddle latch input store last switches state in shift register
24:                 *              2) each rising edge of clock signal shift one bit out, bit 0 first.
25:                 *                 bit 0 is at output after latch so there is only 15 shift to do.
26:                 * Created on 25 février 2014, 16:41
27:                 */
28:                
29:                #include <stdlib.h>
30:                #include "snes_paddle.h"
31:                //#include "TVout.h"
32:                
33:                
34:                
35:                // the loop execute in 4 Tcy
36:                #define mDelay(usec) asm(" MOV #%0, W4\n NOP\n DEC W4,W4\n BRA NZ .-4"::"i"(usec))
37:                
38:                void latch(){
39:                    P_PDL_LATCH=1;
002784  A822CC     BSET LATB, #1
40:                    mDelay(CYCLES_PER_USEC/4);
002786  200044     MOV #0x4, W4
002788  000000     NOP
00278A  E90204     DEC W4, W4
00278C  3AFFFD     BRA NZ, 0x2788
41:                    P_PDL_LATCH=0;
00278E  A922CC     BCLR LATB, #1
42:                    mDelay(CYCLES_PER_USEC/4);
002790  200044     MOV #0x4, W4
002792  000000     NOP
002794  E90204     DEC W4, W4
002796  3AFFFD     BRA NZ, 0x2792
43:                }//f()
002798  060000     RETURN
44:                
45:                void bit_shift(){
46:                    P_PDL_CLK=1;
00279A  A802CC     BSET LATB, #0
47:                    mDelay(CYCLES_PER_USEC/4);
00279C  200044     MOV #0x4, W4
00279E  000000     NOP
0027A0  E90204     DEC W4, W4
0027A2  3AFFFD     BRA NZ, 0x279E
48:                    P_PDL_CLK=0;
0027A4  A902CC     BCLR LATB, #0
49:                    mDelay(CYCLES_PER_USEC/4);
0027A6  200044     MOV #0x4, W4
0027A8  000000     NOP
0027AA  E90204     DEC W4, W4
0027AC  3AFFFD     BRA NZ, 0x27A8
50:                }// f()
0027AE  060000     RETURN
51:                
52:                unsigned read_paddle(int paddleId) {
0027B0  BE9F88     MOV.D W8, [W15++]
0027B2  BE9F8A     MOV.D W10, [W15++]
0027B4  BE9F8C     MOV.D W12, [W15++]
0027B6  780680     MOV W0, W13
53:                    unsigned i,pdata, p1,p2;
54:                    p1=0;
0027BC  780509     MOV W9, W10
55:                    p2=0;
0027BA  EB0480     CLR W9
56:                    latch(); // latch data in paddles shift register
0027B8  07FFE5     RCALL latch
57:                    // shift out is least significant bit first.
58:                    for (i=0;i<15;i++){ // SNES paddle have 16 bits shift register
0027BE  780409     MOV W9, W8
0027D8  E80408     INC W8, W8
0027DA  540FEF     SUB W8, #0xF, [W15]
0027DC  3AFFF3     BRA NZ, 0x27C4
59:                        pdata=PADDLES_DATA_PORT;
0027C4  801614     MOV PORTA, W4
60:                        p1 |= (pdata&PADDLE1)<<i;
0027C6  6202E1     AND W4, #0x1, W5
0027C8  DD2A88     SL W5, W8, W5
0027CA  750505     IOR W10, W5, W10
61:                        p2 |= (pdata&PADDLE2)?1<<i:0;
0027C0  EB0580     CLR W11
0027C2  20001C     MOV #0x1, W12
0027CC  620262     AND W4, #0x2, W4
0027CE  78028B     MOV W11, W5
0027D0  320001     BRA Z, 0x27D4
0027D2  DD6288     SL W12, W8, W5
0027D4  748485     IOR W9, W5, W9
62:                        bit_shift();
0027D6  07FFE1     RCALL bit_shift
63:                    }
64:                    return paddleId==1?(~p1)&0xfff:(~p2)&0xfff;
0027DE  568FE1     SUB W13, #0x1, [W15]
0027E0  3A0004     BRA NZ, 0x27EA
0027E2  EA800A     COM W10, W0
0027E4  20FFF4     MOV #0xFFF, W4
0027E6  600004     AND W0, W4, W0
0027E8  370003     BRA 0x27F0
0027EA  EA8009     COM W9, W0
0027EC  20FFF4     MOV #0xFFF, W4
0027EE  600004     AND W0, W4, W0
65:                }//f()
0027F0  BE064F     MOV.D [--W15], W12
0027F2  BE054F     MOV.D [--W15], W10
0027F4  BE044F     MOV.D [--W15], W8
0027F6  060000     RETURN
66:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/snake.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   snake.c
21:                 * Author: jacques Deschênes
22:                 * Description: snake game.
23:                 * Created on 5 mars 2014, 16:01
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <time.h>
28:                #include "PICvision.h"
29:                
30:                // PIC24FJ64GA002 Configuration Bit Settings
31:                // CONFIG2
32:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
33:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
34:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
35:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
36:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
37:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
38:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
39:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
40:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
41:                
42:                // CONFIG1
43:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
44:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
45:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
46:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
47:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
48:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
49:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
50:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
51:                
52:                typedef struct symbol{
53:                    unsigned char x;
54:                    unsigned char y;
55:                    char part;
56:                }symbol_t;
57:                
58:                #define SNAKE_MAX_LEN  64
59:                
60:                typedef struct snake_struct{
61:                    unsigned length;
62:                    unsigned calories;
63:                    unsigned lifespan;
64:                    unsigned short dx;
65:                    unsigned short dy;
66:                    symbol_t body[SNAKE_MAX_LEN];
67:                }snake_t;
68:                
69:                typedef struct msg_struct{
70:                    unsigned char x;
71:                    unsigned char y;
72:                    char *text;
73:                }msg_t;
74:                
75:                // snake some symbols
76:                #define RING  102+32
77:                #define HEAD_RIGHT  103+32
78:                #define HEAD_LEFT 104+32
79:                #define HEAD_UP  105+32
80:                #define HEAD_DOWN 106+32
81:                #define MOUSE 109+32
82:                
83:                #define BASE_METABOLISM 2   // calories lost per seconde
84:                #define MOUSE_CALORIES  20  // calories gain by eating mouse
85:                
86:                snake_t snake;
87:                
88:                symbol_t mouse;
89:                
90:                const msg_t msgCALORIES={0,0,"calories: "};
91:                const msg_t msgSECONDS={16,0,"lifespan: "};
92:                const msg_t msgGAME_OVER={6,13,"game over"};
93:                const msg_t msgSTART={8,20, "press START to begin"};
94:                const msg_t msgSTARVATION={6,14,"died of starvation"};
95:                const msg_t msgWALL_COLLIDE={6,14,"died of wall collision"};
96:                const msg_t msgTAIL_BITE={6,14,"died of tail bite."};
97:                
98:                void print_msg(const msg_t msg){
00191C  BE9F88     MOV.D W8, [W15++]
00191E  BE0400     MOV.D W0, W8
99:                    set_curpos(msg.x,msg.y);
001920  DE00C8     LSR W0, #8, W1
001922  FB8008     ZE W8, W0
001924  0703D7     RCALL set_curpos
100:                   print(msg.text);
001926  780009     MOV W9, W0
001928  070358     RCALL print
101:               }//f()
00192A  BE044F     MOV.D [--W15], W8
00192C  060000     RETURN
102:               
103:               void new_mouse(){
00192E  BE9F88     MOV.D W8, [W15++]
001930  781F8A     MOV W10, [W15++]
104:                   unsigned short i, collide,mouseX,mouseY;
105:                   collide=1;
106:                   while (collide){
107:                       mouseX=rand()%(CHAR_PER_LINE-3)+2;
001932  200209     MOV #0x20, W9
001936  07F62F     RCALL 0x596
001938  780401     MOV W1, W8
00193A  090011     REPEAT #0x11
00193C  D80009     DIV.SW W0, W9
00193E  FD0401     EXCH W1, W8
001940  E88408     INC2 W8, W8
108:                       mouseY=rand()%(LINE_PER_SCREEN-3)+2;
001942  07F629     RCALL 0x596
001944  200184     MOV #0x18, W4
001946  090011     REPEAT #0x11
001948  D80004     DIV.SW W0, W4
00194A  E88081     INC2 W1, W1
109:                       for (i=0;i<snake.length;i++){
001934  21EE2A     MOV #0x1EE2, W10
00194C  80F6C0     MOV snake, W0
00194E  500FE0     SUB W0, #0x0, [W15]
001950  320010     BRA Z, 0x1972
001952  78020A     MOV W10, W4
001954  EB0280     CLR W5
001966  E80285     INC W5, W5
001968  420263     ADD W4, #0x3, W4
00196A  528F80     SUB W5, W0, [W15]
00196C  39FFF4     BRA NC, 0x1956
110:                           if ((mouseX==snake.body[i].x)&&(mouseY==snake.body[i].y)) break;
001956  784114     MOV.B [W4], W2
001958  FB8302     ZE W2, W6
00195A  530F88     SUB W6, W8, [W15]
00195C  3A0004     BRA NZ, 0x1966
00195E  904314     MOV.B [W4+1], W6
001960  FB8306     ZE W6, W6
001962  530F81     SUB W6, W1, [W15]
001964  320004     BRA Z, 0x196E
111:                       }
112:                       if (i==snake.length) collide=0;
00196E  500F85     SUB W0, W5, [W15]
001970  3AFFE2     BRA NZ, 0x1936
113:                   }//while
114:                   mouse.x=mouseX;
001972  780008     MOV W8, W0
001974  B7FFA2     MOV.B WREG, mouse
115:                   mouse.y=mouseY;
001976  780001     MOV W1, W0
001978  B7FFA3     MOV.B WREG, 0x1FA3
116:                   set_curpos(mouse.x,mouse.y);
00197A  FB8081     ZE W1, W1
00197C  FB8008     ZE W8, W0
00197E  0703AA     RCALL set_curpos
117:                   put_char(mouse.part);
001980  BFDFA4     MOV.B 0x1FA4, WREG
001982  0702A0     RCALL put_char
118:               }//f()
001984  78054F     MOV [--W15], W10
001986  BE044F     MOV.D [--W15], W8
001988  060000     RETURN
119:               
120:               void hide_snake(){
00198A  BE9F88     MOV.D W8, [W15++]
00198C  781F8A     MOV W10, [W15++]
121:                   unsigned i;
122:                   for (i=0;i<snake.length;i++){
00198E  80F6C4     MOV snake, W4
001990  520FE0     SUB W4, #0x0, [W15]
001992  32000F     BRA Z, 0x19B2
001994  21EE38     MOV #0x1EE3, W8
001996  EB0480     CLR W9
0019A8  E80489     INC W9, W9
0019AA  440463     ADD W8, #0x3, W8
0019AC  80F6C4     MOV snake, W4
0019AE  520F89     SUB W4, W9, [W15]
0019B0  3EFFF4     BRA GTU, 0x199A
123:                       set_curpos(snake.body[i].x,snake.body[i].y);
00199A  784218     MOV.B [W8], W4
00199C  FB8084     ZE W4, W1
00199E  97F878     MOV.B [W8-1], W0
0019A0  FB8000     ZE W0, W0
0019A2  070398     RCALL set_curpos
124:                       put_char(SPACE);
001998  B3C20A     MOV #0x20, W10
0019A4  78400A     MOV.B W10, W0
0019A6  07028E     RCALL put_char
125:                   }
126:               }//f()
0019B2  78054F     MOV [--W15], W10
0019B4  BE044F     MOV.D [--W15], W8
0019B6  060000     RETURN
127:               
128:               void show_snake(){
0019B8  BE9F88     MOV.D W8, [W15++]
129:                   unsigned i;
130:                   for (i=0;i<snake.length;i++){
0019BA  80F6C4     MOV snake, W4
0019BC  520FE0     SUB W4, #0x0, [W15]
0019BE  32000E     BRA Z, 0x19DC
0019C0  21EE38     MOV #0x1EE3, W8
0019C2  EB0480     CLR W9
0019D2  E80489     INC W9, W9
0019D4  440463     ADD W8, #0x3, W8
0019D6  80F6C4     MOV snake, W4
0019D8  520F89     SUB W4, W9, [W15]
0019DA  3EFFF4     BRA GTU, 0x19C4
131:                       set_curpos(snake.body[i].x,snake.body[i].y);
0019C4  784218     MOV.B [W8], W4
0019C6  FB8084     ZE W4, W1
0019C8  97F878     MOV.B [W8-1], W0
0019CA  FB8000     ZE W0, W0
0019CC  070383     RCALL set_curpos
132:                       put_char(snake.body[i].part);
0019CE  904018     MOV.B [W8+1], W0
0019D0  070279     RCALL put_char
133:                       
134:                   }//for
135:               }//f()
0019DC  BE044F     MOV.D [--W15], W8
0019DE  060000     RETURN
136:               
137:               
138:               void wait_start_signal(){
0019E0  781F88     MOV W8, [W15++]
139:                   unsigned p;
140:                   p=0;
141:                   print_msg(msgSTART);
0019E2  849090     MOV 0x9212, W0
0019E4  8490A1     MOV 0x9214, W1
0019E6  07FF9A     RCALL print_msg
142:                   while (!(p&SNES_START)){
0019EE  600068     AND W0, #0x8, W0
0019F0  32FFFC     BRA Z, 0x19EA
143:                     p=read_paddle(PADDLE1);
0019E8  200018     MOV #0x1, W8
0019EA  780008     MOV W8, W0
0019EC  0706E1     RCALL read_paddle
144:                   }
145:               }//f()
0019F2  78044F     MOV [--W15], W8
0019F4  060000     RETURN
146:               
147:               void animate_death(){
0019F6  BE9F88     MOV.D W8, [W15++]
0019F8  BE9F8A     MOV.D W10, [W15++]
0019FA  781F8C     MOV W12, [W15++]
001A08  B94B63     MUL.SU W9, #3, W6
001A0A  21EE34     MOV #0x1EE3, W4
001A0C  430404     ADD W6, W4, W8
148:                   int i,freq;
149:                   show_snake();
0019FC  07FFDD     RCALL show_snake
150:                   freq=snake.length*200;
0019FE  80F6C4     MOV snake, W4
001A04  200C8A     MOV #0xC8, W10
001A06  B9A50A     MUL.SS W4, W10, W10
151:                   for (i=snake.length-1;i>=0;i--){
001A00  E90484     DEC W4, W9
001A02  330019     BRA N, 0x1A36
001A2E  E90489     DEC W9, W9
001A30  540463     SUB W8, #0x3, W8
001A32  548FE0     SUB W9, #0x0, [W15]
001A34  3DFFEE     BRA GE, 0x1A12
152:                       set_curpos(snake.body[i].x,snake.body[i].y);
001A12  784218     MOV.B [W8], W4
001A14  FB8084     ZE W4, W1
001A16  97F878     MOV.B [W8-1], W0
001A18  FB8000     ZE W0, W0
001A1A  07035C     RCALL set_curpos
153:                       put_char(32);
001A0E  B3C20B     MOV #0x20, W11
001A1C  78400B     MOV.B W11, W0
001A1E  070252     RCALL put_char
154:                       tone(freq,250);
001A10  200FAC     MOV #0xFA, W12
001A20  78008C     MOV W12, W1
001A22  78000A     MOV W10, W0
001A24  070587     RCALL tone
155:                       wait_n_frame(frames_per_second/4);
001A26  80F650     MOV frames_per_second, W0
001A28  DE0042     LSR W0, #2, W0
001A2A  0704D8     RCALL wait_n_frame
156:                       freq -= 100;
001A2C  B1064A     SUB #0x64, W10
157:                   }//for
158:               }//f()
001A36  78064F     MOV [--W15], W12
001A38  BE054F     MOV.D [--W15], W10
001A3A  BE044F     MOV.D [--W15], W8
001A3C  060000     RETURN
159:               
160:               // dead cause
161:               typedef enum DEATH {STARVATION,WALL_COLLISION,TAIL_BITE} death_t;
162:               
163:               unsigned char reset=0;
164:               void game_over(death_t cause){
001A3E  781F88     MOV W8, [W15++]
001A40  780400     MOV W0, W8
165:                   animate_death();
001A42  07FFD9     RCALL animate_death
166:                   print_msg(msgGAME_OVER);
001A44  848FC0     MOV 0x91F8, W0
001A46  848FD1     MOV 0x91FA, W1
001A48  07FF69     RCALL print_msg
167:                   switch (cause){
001A4A  540FE1     SUB W8, #0x1, [W15]
001A4C  320008     BRA Z, 0x1A5E
001A4E  390003     BRA NC, 0x1A56
001A50  540FE2     SUB W8, #0x2, [W15]
001A52  3A000C     BRA NZ, 0x1A6C
001A54  370008     BRA 0x1A66
168:                       case STARVATION:
169:                           print_msg(msgSTARVATION);
001A56  849150     MOV 0x922A, W0
001A58  849161     MOV 0x922C, W1
001A5A  07FF60     RCALL print_msg
170:                           break;
001A5C  370007     BRA 0x1A6C
171:                       case WALL_COLLISION:
172:                           print_msg(msgWALL_COLLIDE);
001A5E  849230     MOV 0x9246, W0
001A60  849241     MOV 0x9248, W1
001A62  07FF5C     RCALL print_msg
173:                           break;
001A64  370003     BRA 0x1A6C
174:                       case TAIL_BITE:
175:                           print_msg(msgTAIL_BITE);
001A66  8492F0     MOV 0x925E, W0
001A68  849301     MOV 0x9260, W1
001A6A  07FF58     RCALL print_msg
176:                           break;
177:                   }//switch
178:                   reset=1;
001A6C  B3C014     MOV #0x1, W4
001A6E  FD0200     EXCH W0, W4
001A70  B7FFFC     MOV.B WREG, reset
001A72  FD0200     EXCH W0, W4
179:                   wait_start_signal();
001A74  07FFB5     RCALL wait_start_signal
180:               }//f()
001A76  78044F     MOV [--W15], W8
001A78  060000     RETURN
181:               
182:               void add_calories(unsigned short gain){
183:                   snake.calories+=gain;
001A7A  B43EDA     ADD 0x1EDA
184:                   print_msg(msgCALORIES);
001A7C  848ED0     MOV 0x91DA, W0
001A7E  848EE1     MOV 0x91DC, W1
001A80  07FF4D     RCALL print_msg
185:                   print_int(snake.calories,1);
001A82  200011     MOV #0x1, W1
001A84  80F6D0     MOV 0x1EDA, W0
001A86  0702CE     RCALL print_int
186:               }//f()
001A88  060000     RETURN
187:               
188:               
189:               void burn_calories(unsigned short lost){
190:                   unsigned newLength;
191:                   if (lost < BASE_METABOLISM) lost=BASE_METABOLISM;
001A8A  500FE1     SUB W0, #0x1, [W15]
001A8C  3E0001     BRA GTU, 0x1A90
001A8E  200020     MOV #0x2, W0
192:                   snake.calories -= lost;
001A90  B53EDA     SUB 0x1EDA
193:                   if (snake.calories<0) snake.calories=0;
194:                   print_msg(msgCALORIES);
001A92  848ED0     MOV 0x91DA, W0
001A94  848EE1     MOV 0x91DC, W1
001A96  07FF42     RCALL print_msg
195:                   clear_eol();
001A98  0702FC     RCALL clear_eol
196:                   print_int(snake.calories,1);
001A9A  200011     MOV #0x1, W1
001A9C  80F6D0     MOV 0x1EDA, W0
001A9E  0702C2     RCALL print_int
197:                   print_msg(msgSECONDS);
001AA0  848F50     MOV 0x91EA, W0
001AA2  848F61     MOV 0x91EC, W1
001AA4  07FF3B     RCALL print_msg
198:                   print_int(snake.lifespan,1);
001AA6  200011     MOV #0x1, W1
001AA8  80F6E0     MOV 0x1EDC, W0
001AAA  0702BC     RCALL print_int
199:                   hide_snake();
001AAC  07FF6E     RCALL hide_snake
200:                   newLength=snake.calories/MOUSE_CALORIES+1;
001AAE  80F6D4     MOV 0x1EDA, W4
001AB4  200145     MOV #0x14, W5
001AB6  BE9F80     MOV.D W0, [W15++]
001AB8  090011     REPEAT #0x11
001ABA  D88205     DIV.UW W4, W5
001ABC  780200     MOV W0, W4
001ABE  BE004F     MOV.D [--W15], W0
201:                   if (snake.calories){
001AB0  520FE0     SUB W4, #0x0, [W15]
001AB2  32000A     BRA Z, 0x1AC8
202:                       snake.length=newLength+1;
001AC0  E88204     INC2 W4, W4
001AC2  88F6C4     MOV W4, snake
203:                       show_snake();
001AC4  07FF79     RCALL show_snake
001AC6  370002     BRA 0x1ACC
204:                   } else{
205:                       game_over(STARVATION);
001AC8  EB0000     CLR W0
001ACA  07FFB9     RCALL game_over
206:                       return;
207:                   }
208:               }//f()
001ACC  060000     RETURN
209:               
210:               void check_if_got_mouse(){
211:                   if ((mouse.x==snake.body[0].x) && (mouse.y==snake.body[0].y)){
001ACE  21EE24     MOV #0x1EE2, W4
001AD0  784214     MOV.B [W4], W4
001AD2  21FA25     MOV #0x1FA2, W5
001AD4  784295     MOV.B [W5], W5
001AD6  52CF84     SUB.B W5, W4, [W15]
001AD8  3A006A     BRA NZ, 0x1BAE
001ADA  21EE34     MOV #0x1EE3, W4
001ADC  784214     MOV.B [W4], W4
001ADE  21FA35     MOV #0x1FA3, W5
001AE0  784295     MOV.B [W5], W5
001AE2  52CF84     SUB.B W5, W4, [W15]
001AE4  3A0064     BRA NZ, 0x1BAE
212:                       add_calories(MOUSE_CALORIES);
001AE6  200140     MOV #0x14, W0
001AE8  07FFC8     RCALL add_calories
213:                       snake.length++;
001AEA  80F6C4     MOV snake, W4
001AEC  E80284     INC W4, W5
001AEE  88F6C5     MOV W5, snake
214:                       snake.body[snake.length-1].part=RING;
001AF0  B92363     MUL.SU W4, #3, W6
001AF2  B3C861     MOV #0x86, W1
001AF4  21EE40     MOV #0x1EE4, W0
001AF6  7B7001     MOV.B W1, [W0+W6]
215:                       if (snake.dx){
001AF8  80F6F6     MOV 0x1EDE, W6
001AFA  530FE0     SUB W6, #0x0, [W15]
001AFC  32002D     BRA Z, 0x1B58
216:                           if (snake.body[snake.length-2].y==snake.body[0].y){
001AFE  E98285     DEC2 W5, W5
001B00  B92863     MUL.SU W5, #3, W0
001B02  21EE27     MOV #0x1EE2, W7
001B04  400387     ADD W0, W7, W7
001B06  904017     MOV.B [W7+1], W0
001B08  21EE37     MOV #0x1EE3, W7
001B0A  784397     MOV.B [W7], W7
001B0C  504F87     SUB.B W0, W7, [W15]
001B0E  3A000C     BRA NZ, 0x1B28
217:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x-snake.dx;
001B10  B92063     MUL.SU W4, #3, W0
001B12  21EE24     MOV #0x1EE2, W4
001B14  420200     ADD W4, W0, W4
001B16  B92863     MUL.SU W5, #3, W0
001B18  4002EA     ADD W0, #0xA, W5
001B1A  21ED87     MOV #0x1ED8, W7
001B1C  7AC067     MOV.B [W7+W5], W0
001B1E  504A06     SUB.B W0, W6, [W4]
218:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
001B20  438285     ADD W7, W5, W5
001B22  904295     MOV.B [W5+1], W5
001B24  984215     MOV.B W5, [W4+1]
001B26  370042     BRA 0x1BAC
219:                           }else{
220:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001B28  B92063     MUL.SU W4, #3, W0
001B2A  B92B63     MUL.SU W5, #3, W6
001B2C  4302EA     ADD W6, #0xA, W5
001B2E  21ED86     MOV #0x1ED8, W6
001B30  4303EA     ADD W6, #0xA, W7
001B32  7AC166     MOV.B [W6+W5], W2
001B34  787382     MOV.B W2, [W7+W0]
221:                               if (snake.body[0].y>snake.body[snake.length-2].y){
001B36  430285     ADD W6, W5, W5
001B38  904295     MOV.B [W5+1], W5
001B3A  21EE36     MOV #0x1EE3, W6
001B3C  784316     MOV.B [W6], W6
001B3E  534F85     SUB.B W6, W5, [W15]
001B40  360005     BRA LEU, 0x1B4C
222:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y-1;
001B42  21EE24     MOV #0x1EE2, W4
001B44  420200     ADD W4, W0, W4
001B46  E94285     DEC.B W5, W5
001B48  984215     MOV.B W5, [W4+1]
001B4A  370030     BRA 0x1BAC
223:                               }else{
224:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y+1;
001B4C  B92363     MUL.SU W4, #3, W6
001B4E  21EE24     MOV #0x1EE2, W4
001B50  420206     ADD W4, W6, W4
001B52  E84285     INC.B W5, W5
001B54  984215     MOV.B W5, [W4+1]
001B56  37002A     BRA 0x1BAC
225:                               }//if
226:                           }//if
227:                       }else {
228:                           if (snake.body[snake.length-2].x==snake.body[0].x){
001B58  E98285     DEC2 W5, W5
001B5A  B92B63     MUL.SU W5, #3, W6
001B5C  43036A     ADD W6, #0xA, W6
001B5E  21ED87     MOV #0x1ED8, W7
001B60  7B43E7     MOV.B [W7+W6], W7
001B62  21EE26     MOV #0x1EE2, W6
001B64  784316     MOV.B [W6], W6
001B66  53CF86     SUB.B W7, W6, [W15]
001B68  3A000C     BRA NZ, 0x1B82
229:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001B6A  B92063     MUL.SU W4, #3, W0
001B6C  21EE24     MOV #0x1EE2, W4
001B6E  420200     ADD W4, W0, W4
001B70  784A07     MOV.B W7, [W4]
230:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y-snake.dy;
001B72  B92863     MUL.SU W5, #3, W0
001B74  21EE26     MOV #0x1EE2, W6
001B76  400286     ADD W0, W6, W5
001B78  904315     MOV.B [W5+1], W6
001B7A  80F705     MOV 0x1EE0, W5
001B7C  534285     SUB.B W6, W5, W5
001B7E  984215     MOV.B W5, [W4+1]
001B80  370015     BRA 0x1BAC
231:                           }else{
232:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
001B82  B92063     MUL.SU W4, #3, W0
001B84  21EE27     MOV #0x1EE2, W7
001B86  438000     ADD W7, W0, W0
001B88  B92963     MUL.SU W5, #3, W2
001B8A  4102EA     ADD W2, #0xA, W5
001B8C  21ED87     MOV #0x1ED8, W7
001B8E  438085     ADD W7, W5, W1
001B90  904091     MOV.B [W1+1], W1
001B92  984011     MOV.B W1, [W0+1]
233:                               if (snake.body[0].x>snake.body[snake.length-2].x){
001B94  7AC2E7     MOV.B [W7+W5], W5
001B96  534F85     SUB.B W6, W5, [W15]
001B98  360005     BRA LEU, 0x1BA4
234:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x-1;
001B9A  B92363     MUL.SU W4, #3, W6
001B9C  21EE24     MOV #0x1EE2, W4
001B9E  420206     ADD W4, W6, W4
001BA0  E94A05     DEC.B W5, [W4]
001BA2  370004     BRA 0x1BAC
235:                               }else{
236:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x+1;
001BA4  B92363     MUL.SU W4, #3, W6
001BA6  21EE24     MOV #0x1EE2, W4
001BA8  420206     ADD W4, W6, W4
001BAA  E84A05     INC.B W5, [W4]
237:                               }//if
238:                           }//if
239:               
240:                       }//if
241:                       new_mouse();
001BAC  07FEC0     RCALL new_mouse
242:                   }
243:               }//f()
001BAE  060000     RETURN
244:               
245:               int bit_himself(){
246:                   int i;
247:                   for (i=1;i<snake.length;i++){
001BB0  80F6C7     MOV snake, W7
001BB4  538FE1     SUB W7, #0x1, [W15]
001BB6  360011     BRA LEU, 0x1BDA
001BC0  200015     MOV #0x1, W5
001BCC  E80285     INC W5, W5
001BCE  420263     ADD W4, #0x3, W4
001BD0  538F85     SUB W7, W5, [W15]
001BD2  3EFFF7     BRA GTU, 0x1BC2
248:                       if ((snake.body[0].x==snake.body[i].x) &&(snake.body[0].y==snake.body[i].y)){
001BB8  BFDEE2     MOV.B 0x1EE2, WREG
001BBA  21EE31     MOV #0x1EE3, W1
001BBC  784091     MOV.B [W1], W1
001BBE  21EE54     MOV #0x1EE5, W4
001BC2  504F94     SUB.B W0, [W4], [W15]
001BC4  3A0003     BRA NZ, 0x1BCC
001BC6  904314     MOV.B [W4+1], W6
001BC8  50CF86     SUB.B W1, W6, [W15]
001BCA  320006     BRA Z, 0x1BD8
249:                           return 1;
001BD8  200010     MOV #0x1, W0
250:                       }
251:                   }
252:                   return 0;
001BB2  EB0000     CLR W0
001BD4  EB0000     CLR W0
001BD6  370001     BRA 0x1BDA
253:               }//f()
001BDA  060000     RETURN
254:               
255:               void move_snake(){
001BF2  B92363     MUL.SU W4, #3, W6
001BF4  21EE24     MOV #0x1EE2, W4
001BF6  430204     ADD W6, W4, W4
001BF8  21EDF5     MOV #0x1EDF, W5
256:                   unsigned i;
257:                   if (!(snake.dx || snake.dy)) return;
001BDC  80F6F4     MOV 0x1EDE, W4
001BDE  520FE0     SUB W4, #0x0, [W15]
001BE0  3A0003     BRA NZ, 0x1BE8
001BE2  80F704     MOV 0x1EE0, W4
001BE4  520FE0     SUB W4, #0x0, [W15]
001BE6  32002F     BRA Z, 0x1C46
258:                   hide_snake();
001BE8  07FED0     RCALL hide_snake
259:                   for (i=snake.length-1;i;i--){
001BEA  80F6C4     MOV snake, W4
001BEC  520FE1     SUB W4, #0x1, [W15]
001BEE  32000C     BRA Z, 0x1C08
001C04  520F85     SUB W4, W5, [W15]
001C06  3AFFF9     BRA NZ, 0x1BFA
260:                       snake.body[i].x = snake.body[i-1].x;
001BF0  E98204     DEC2 W4, W4
001BFA  784314     MOV.B [W4], W6
001BFC  984236     MOV.B W6, [W4+3]
261:                       snake.body[i].y = snake.body[i-1].y;
001BFE  904314     MOV.B [W4+1], W6
001C00  984246     MOV.B W6, [W4+4]
001C02  520263     SUB W4, #0x3, W4
262:                   }
263:                   snake.body[0].x += snake.dx;
001C08  80F6F5     MOV 0x1EDE, W5
001C0A  21EE24     MOV #0x1EE2, W4
001C0C  42C294     ADD.B W5, [W4], W5
001C0E  FD0280     EXCH W0, W5
001C10  B7FEE2     MOV.B WREG, 0x1EE2
001C12  FD0280     EXCH W0, W5
264:                   snake.body[0].y += snake.dy;
001C14  80F704     MOV 0x1EE0, W4
001C16  21EE36     MOV #0x1EE3, W6
001C18  424216     ADD.B W4, [W6], W4
001C1A  FD0200     EXCH W0, W4
001C1C  B7FEE3     MOV.B WREG, 0x1EE3
001C1E  FD0200     EXCH W0, W4
265:                   if ((snake.body[0].x<1)||(snake.body[0].x>=(CHAR_PER_LINE)) ||
001C20  E94285     DEC.B W5, W5
001C22  B3C216     MOV #0x21, W6
001C24  52CF86     SUB.B W5, W6, [W15]
001C26  3E0004     BRA GTU, 0x1C30
001C28  524FE1     SUB.B W4, #0x1, [W15]
001C2A  360002     BRA LEU, 0x1C30
266:                       (snake.body[0].y<2) || (snake.body[0].y>=LINE_PER_SCREEN-1)){
001C2C  524FF9     SUB.B W4, #0x19, [W15]
001C2E  360003     BRA LEU, 0x1C36
267:                       game_over(WALL_COLLISION);
001C30  200010     MOV #0x1, W0
001C32  07FF05     RCALL game_over
001C34  370008     BRA 0x1C46
268:                   }else if (bit_himself()){
001C36  07FFBC     RCALL bit_himself
001C38  500FE0     SUB W0, #0x0, [W15]
001C3A  320003     BRA Z, 0x1C42
269:                       game_over(TAIL_BITE);
001C3C  200020     MOV #0x2, W0
001C3E  07FEFF     RCALL game_over
001C40  370002     BRA 0x1C46
270:                   }else{
271:                       check_if_got_mouse();
001C42  07FF45     RCALL check_if_got_mouse
272:                       show_snake();
001C44  07FEB9     RCALL show_snake
273:                   }//if
274:               }//f()
001C46  060000     RETURN
275:               
276:               void present_game(){
277:                   clear_screen();
001C48  0701C1     RCALL clear_screen
278:                   print("**************\r");
001C4A  290BA0     MOV #0x90BA, W0
001C4C  0701C6     RCALL print
279:                   print("* SNAKE GAME *\r");
001C4E  290CA0     MOV #0x90CA, W0
001C50  0701C4     RCALL print
280:                   print("**************\r\r");
001C52  290DA0     MOV #0x90DA, W0
001C54  0701C2     RCALL print
281:                   print("Eating a mouse increase snake length.\r");
001C56  290EB0     MOV #0x90EB, W0
001C58  0701C0     RCALL print
282:                   print("Snake burn 10% of is calaries/sec.\r");
001C5A  291120     MOV #0x9112, W0
001C5C  0701BE     RCALL print
283:                   print("Die of starvation when calories=0.\r");
001C5E  291360     MOV #0x9136, W0
001C60  0701BC     RCALL print
284:                   print("Eating a mouse give 20 calories.\r");
001C62  2915A0     MOV #0x915A, W0
001C64  0701BA     RCALL print
285:                   print("Die when hitting wall.\r");
001C66  2917C0     MOV #0x917C, W0
001C68  0701B8     RCALL print
286:                   print("Die when bitting his tail.\r\r");
001C6A  291940     MOV #0x9194, W0
001C6C  0701B6     RCALL print
287:                   print("Use ARROWS to control snake.\r");
001C6E  291B10     MOV #0x91B1, W0
001C70  0701B4     RCALL print
288:                   wait_start_signal();
001C72  07FEB6     RCALL wait_start_signal
289:               }//f()
001C74  060000     RETURN
290:               
291:               void game_init(){
001C76  781F88     MOV W8, [W15++]
292:                   reset=0;
001C78  EF7FFC     CLR.B reset
293:                   srand(time(0));
001C7A  EB0000     CLR W0
001C7C  07F30F     RCALL 0x29C
001C7E  07F484     RCALL 0x588
294:                   //snake initialisation
295:                   snake.dx=0;
001C80  EB0400     CLR W8
001C82  88F6F8     MOV W8, 0x1EDE
296:                   snake.dy=0;
001C84  88F708     MOV W8, 0x1EE0
297:                   snake.length=2;
001C86  200024     MOV #0x2, W4
001C88  88F6C4     MOV W4, snake
298:                   snake.calories=MOUSE_CALORIES;
001C8A  200144     MOV #0x14, W4
001C8C  88F6D4     MOV W4, 0x1EDA
299:                   snake.lifespan=0;
001C8E  88F6E8     MOV W8, 0x1EDC
300:                   snake.body[0].x=12;
001C90  B3C0C4     MOV #0xC, W4
001C92  FD0200     EXCH W0, W4
001C94  B7FEE2     MOV.B WREG, 0x1EE2
001C96  B7FEE3     MOV.B WREG, 0x1EE3
001C98  FD0200     EXCH W0, W4
301:                   snake.body[0].y=12;
302:                   snake.body[0].part=HEAD_RIGHT;
001C9A  B3C875     MOV #0x87, W5
001C9C  FD0280     EXCH W0, W5
001C9E  B7FEE4     MOV.B WREG, 0x1EE4
001CA0  FD0280     EXCH W0, W5
303:                   snake.body[1].x=11;
001CA2  B3C0B5     MOV #0xB, W5
001CA4  FD0280     EXCH W0, W5
001CA6  B7FEE5     MOV.B WREG, 0x1EE5
001CA8  FD0280     EXCH W0, W5
304:                   snake.body[1].y=12;
001CAA  FD0200     EXCH W0, W4
001CAC  B7FEE6     MOV.B WREG, 0x1EE6
001CAE  FD0200     EXCH W0, W4
305:                   snake.body[1].part=RING;
001CB0  B3C864     MOV #0x86, W4
001CB2  FD0200     EXCH W0, W4
001CB4  B7FEE7     MOV.B WREG, 0x1EE7
001CB6  FD0200     EXCH W0, W4
306:                   mouse.part=MOUSE;
001CB8  424267     ADD.B W4, #0x7, W4
001CBA  FD0200     EXCH W0, W4
001CBC  B7FFA4     MOV.B WREG, 0x1FA4
001CBE  FD0200     EXCH W0, W4
307:                   clear_screen();
001CC0  070185     RCALL clear_screen
308:                   print_msg(msgCALORIES);
001CC2  848ED0     MOV 0x91DA, W0
001CC4  848EE1     MOV 0x91DC, W1
001CC6  07FE2A     RCALL print_msg
309:                   print_int(snake.calories,1);
001CC8  200011     MOV #0x1, W1
001CCA  80F6D0     MOV 0x1EDA, W0
001CCC  0701AB     RCALL print_int
310:                   print_msg(msgSECONDS);
001CCE  848F50     MOV 0x91EA, W0
001CD0  848F61     MOV 0x91EC, W1
001CD2  07FE24     RCALL print_msg
311:                   print_int(snake.lifespan,1);
001CD4  200011     MOV #0x1, W1
001CD6  80F6E0     MOV 0x1EDC, W0
001CD8  0701A5     RCALL print_int
312:                   //draw  borders
313:                   rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001CDA  200014     MOV #0x1, W4
001CDC  200D73     MOV #0xD7, W3
001CDE  780103     MOV W3, W2
001CE0  200081     MOV #0x8, W1
001CE2  780008     MOV W8, W0
001CE4  07FB77     RCALL rectangle
314:                   new_mouse();
001CE6  07FE23     RCALL new_mouse
315:                   show_snake();
001CE8  07FE67     RCALL show_snake
316:               }//f()
001CEA  78044F     MOV [--W15], W8
001CEC  060000     RETURN
317:               
318:               // for debugging only
319:               const unsigned char X[8]={0x84,0x84,0x48,0x30,0x30,0x48,0x84,0x84};
320:               const unsigned char X16[16][2]={{0x80,0x01},{0x40,0x02},{0x20,0x04},{0x10,0x08},
321:                                               {0x08,0x10},{0x04,0x20},{0x02,0x40},{0x01,0x80},
322:                                               {0x01,0x80},{0x02,0x40},{0x04,0x20},{0x08,0x10},
323:                                               {0x10,0x08},{0x20,0x04},{0x40,0x02},{0x80,0x01}};
324:               
325:               void bitmap_test(){
001CEE  BE9F88     MOV.D W8, [W15++]
001CF0  781F8A     MOV W10, [W15++]
326:                   int i;
327:                   // test box()
328:               //    box(0,0,32,64,WHITE);
329:               //    for (i=0;i<6;i++){
330:               //        box(0,0,32,64,INVERT);
331:               //        wait_n_frame(30);
332:               //    }//for
333:                   bitmap(20,20,16,16,BMP_COPY,X16);
001CF2  2926A5     MOV #0x926A, W5
001CF4  EB0200     CLR W4
001CF6  200103     MOV #0x10, W3
001CF8  780103     MOV W3, W2
001CFA  200141     MOV #0x14, W1
001CFC  200140     MOV #0x14, W0
001CFE  07FD78     RCALL bitmap
334:                   while(1){
335:                       for (i=0;i<8;i++){
001D00  EB0400     CLR W8
001D04  EB0480     CLR W9
001D06  370008     BRA 0x1D18
001D16  E80408     INC W8, W8
001D18  540FE7     SUB W8, #0x7, [W15]
001D1A  34FFF6     BRA LE, 0x1D08
001D20  780409     MOV W9, W8
001D22  37FFFA     BRA 0x1D18
336:                           bitmap(i,i*8,6,8,BMP_XOR,X);
001D02  29262A     MOV #0x9262, W10
001D08  DD40C3     SL W8, #3, W1
001D0A  78028A     MOV W10, W5
001D0C  200034     MOV #0x3, W4
001D0E  200083     MOV #0x8, W3
001D10  200062     MOV #0x6, W2
001D12  780008     MOV W8, W0
001D14  07FD6D     RCALL bitmap
337:                       }
338:                       wait_n_frame(60);
001D1C  2003C0     MOV #0x3C, W0
001D1E  07035E     RCALL wait_n_frame
339:                   }
340:               }//f()
341:               
342:               // end debug code
343:               
344:               int main(void) {
001D24  BE9F88     MOV.D W8, [W15++]
001D26  781F8A     MOV W10, [W15++]
345:                   unsigned p,frame_count;
346:                   PICvision_init();
001D28  0704E8     RCALL PICvision_init
347:               //    bitmap_test(); // for debugging only
348:                   present_game();
001D2A  07FF8E     RCALL present_game
349:                   game_init();
001D2C  07FFA4     RCALL game_init
350:                   frame_count=0;
001D2E  EB0400     CLR W8
351:                   while (1){
352:                       wait_n_frame(10);
001D34  2000A0     MOV #0xA, W0
001D36  070352     RCALL wait_n_frame
353:                       frame_count += 10;
001D38  44046A     ADD W8, #0xA, W8
354:                       if (frame_count%frames_per_second==0){
001D3A  80F654     MOV frames_per_second, W4
001D3C  BE9F80     MOV.D W0, [W15++]
001D3E  090011     REPEAT #0x11
001D40  D88404     DIV.UW W8, W4
001D42  780201     MOV W1, W4
001D44  BE004F     MOV.D [--W15], W0
001D46  520FE0     SUB W4, #0x0, [W15]
001D48  3A000E     BRA NZ, 0x1D66
355:                           snake.lifespan +=1;
001D4A  EC3EDC     INC 0x1EDC
356:                           burn_calories(snake.calories / 10);
001D4C  80F6D0     MOV 0x1EDA, W0
001D4E  2000A4     MOV #0xA, W4
001D50  781F81     MOV W1, [W15++]
001D52  090011     REPEAT #0x11
001D54  D88004     DIV.UW W0, W4
001D56  7800CF     MOV [--W15], W1
001D58  07FE98     RCALL burn_calories
357:                           rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001D5A  200014     MOV #0x1, W4
001D5C  200D73     MOV #0xD7, W3
001D5E  780103     MOV W3, W2
001D60  200081     MOV #0x8, W1
001D62  EB0000     CLR W0
001D64  07FB37     RCALL rectangle
358:                       }
359:                       p=read_paddle(PADDLE1);
001D66  200010     MOV #0x1, W0
001D68  070523     RCALL read_paddle
360:                       switch (p){
001D30  200209     MOV #0x20, W9
001D6A  500F89     SUB W0, W9, [W15]
001D6C  32002A     BRA Z, 0x1DC2
001D6E  3E0003     BRA GTU, 0x1D76
001D70  500FF0     SUB W0, #0x10, [W15]
001D72  3A0030     BRA NZ, 0x1DD4
001D74  37001C     BRA 0x1DAE
001D76  200404     MOV #0x40, W4
001D78  500F84     SUB W0, W4, [W15]
001D7A  320004     BRA Z, 0x1D84
001D7C  200804     MOV #0x80, W4
001D7E  500F84     SUB W0, W4, [W15]
001D80  3A0029     BRA NZ, 0x1DD4
001D82  37000A     BRA 0x1D98
361:                           case SNES_LEFT:
362:                               if (snake.dx==1){
001D84  80F6F4     MOV 0x1EDE, W4
001D86  520FE1     SUB W4, #0x1, [W15]
001D88  320025     BRA Z, 0x1DD4
363:                                   break;
364:                               }
365:                               snake.dx =-1;
001D8A  EFBEDE     SETM 0x1EDE
366:                               snake.dy=0;
001D8C  EF3EE0     CLR 0x1EE0
367:                               snake.body[0].part=HEAD_LEFT;
001D8E  B3C884     MOV #0x88, W4
001D90  FD0200     EXCH W0, W4
001D92  B7FEE4     MOV.B WREG, 0x1EE4
001D94  FD0200     EXCH W0, W4
368:                               break;
001D96  37001E     BRA 0x1DD4
369:                           case SNES_RIGHT:
370:                               if (snake.dx==-1){
001D98  80F6F4     MOV 0x1EDE, W4
001D9A  420FE1     ADD W4, #0x1, [W15]
001D9C  32001B     BRA Z, 0x1DD4
371:                                   break;
372:                               }
373:                               snake.dx=1;
001D9E  200014     MOV #0x1, W4
001DA0  88F6F4     MOV W4, 0x1EDE
374:                               snake.dy=0;
001DA2  EF3EE0     CLR 0x1EE0
375:                               snake.body[0].part=HEAD_RIGHT;
001DA4  B3C874     MOV #0x87, W4
001DA6  FD0200     EXCH W0, W4
001DA8  B7FEE4     MOV.B WREG, 0x1EE4
001DAA  FD0200     EXCH W0, W4
376:                               break;
001DAC  370013     BRA 0x1DD4
377:                           case SNES_UP:
378:                               if (snake.dy==1){
001DAE  80F704     MOV 0x1EE0, W4
001DB0  520FE1     SUB W4, #0x1, [W15]
001DB2  320010     BRA Z, 0x1DD4
379:                                   break;
380:                               }
381:                               snake.dy=-1;
001DB4  EFBEE0     SETM 0x1EE0
382:                               snake.dx=0;
001DB6  EF3EDE     CLR 0x1EDE
383:                               snake.body[0].part=HEAD_UP;
001DB8  B3C894     MOV #0x89, W4
001DBA  FD0200     EXCH W0, W4
001DBC  B7FEE4     MOV.B WREG, 0x1EE4
001DBE  FD0200     EXCH W0, W4
384:                               break;
001DC0  370009     BRA 0x1DD4
385:                           case SNES_DOWN:
386:                               if (snake.dy==-1){
001DC2  80F704     MOV 0x1EE0, W4
001DC4  420FE1     ADD W4, #0x1, [W15]
001DC6  320006     BRA Z, 0x1DD4
387:                                   break;
388:                               }
389:                               snake.dy=1;
001DC8  200014     MOV #0x1, W4
001DCA  88F704     MOV W4, 0x1EE0
390:                               snake.dx=0;
001DCC  EF3EDE     CLR 0x1EDE
391:                               snake.body[0].part=HEAD_DOWN;
001D32  B3C8AA     MOV #0x8A, W10
001DCE  FD0500     EXCH W0, W10
001DD0  B7FEE4     MOV.B WREG, 0x1EE4
001DD2  FD0500     EXCH W0, W10
392:                               break;
393:                       }//switch
394:                       move_snake();
001DD4  07FF03     RCALL move_snake
395:                       if (reset) game_init();
001DD6  21FFC4     MOV #0x1FFC, W4
001DD8  784214     MOV.B [W4], W4
001DDA  524FE0     SUB.B W4, #0x0, [W15]
001DDC  32FFAB     BRA Z, 0x1D34
001DDE  07FF4B     RCALL game_init
001DE0  37FFA9     BRA 0x1D34
396:                   }//while
397:                   return (EXIT_SUCCESS);
398:               }//main()
399:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/hardwareProfile.c  ------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   hardwareProfile.h
21:                 * Author: jacques Deschênes
22:                 * Description:  try to centralize  hardware specific.
23:                 * Created on 1 march 2014
24:                 */
25:                
26:                #include "hardwareProfile.h"
27:                
28:                void HardwareConfig(){
29:                    // peripheral to pin association.
30:                    PPSUnLock;
00270A  803A16     MOV OSCCON, W6
00270C  B20BF6     AND #0xBF, W6
00270E  200464     MOV #0x46, W4
002710  200575     MOV #0x57, W5
002712  207427     MOV #0x742, W7
002714  784B84     MOV.B W4, [W7]
002716  784B85     MOV.B W5, [W7]
002718  784B86     MOV.B W6, [W7]
31:                    PPSOutput(PPS_RP5,PPS_SDO1);   // video pixels output
00271A  803626     MOV RPOR2, W6
00271C  2E0FF7     MOV #0xE0FF, W7
00271E  630307     AND W6, W7, W6
002720  207000     MOV #0x700, W0
002722  730300     IOR W6, W0, W6
002724  883626     MOV W6, RPOR2
32:                    PPSOutput(PPS_RP6,PPS_OC4);  // video delay output
002726  803630     MOV RPOR3, W0
002728  2FFE06     MOV #0xFFE0, W6
00272A  600006     AND W0, W6, W0
00272C  B30150     IOR #0x15, W0
00272E  883630     MOV W0, RPOR3
33:                    PPSOutput(PPS_RP7,PPS_OC1);  // video sync output
002730  803630     MOV RPOR3, W0
002732  600387     AND W0, W7, W7
002734  212000     MOV #0x1200, W0
002736  738380     IOR W7, W0, W7
002738  883637     MOV W7, RPOR3
34:                    PPSOutput(PPS_RP8,PPS_OC2);  // audio output
00273A  803647     MOV RPOR4, W7
00273C  638306     AND W7, W6, W6
00273E  B30136     IOR #0x13, W6
002740  883646     MOV W6, RPOR4
35:                    PPSLock;
002742  803A16     MOV OSCCON, W6
002744  A06006     BSET W6, #6
002746  207427     MOV #0x742, W7
002748  784B84     MOV.B W4, [W7]
00274A  784B85     MOV.B W5, [W7]
00274C  784B86     MOV.B W6, [W7]
36:                    // pins data direction
37:                    P_PIXEL_OUT_TRIS=0;     // video pixels output
00274E  A9A2C8     BCLR TRISB, #5
38:                    P_VDLY_OUT_TRIS=0;     // video delay output
002750  A9C2C8     BCLR TRISB, #6
39:                    P_VSYNC_OUT_TRIS=0;     // video sync output
002752  A9E2C8     BCLR TRISB, #7
40:                    P_AUDIO_OUT_TRIS=0;     // audio output
002754  A902C9     BCLR 0x2C9, #0
41:                    P_NOISE_OUT_TRIS=0;     /// white noise output
002756  A942C9     BCLR 0x2C9, #2
42:                    P_PIXDLY_IN_TRIS=1;     //input video pixels delay
002758  A822C9     BSET 0x2C9, #1
43:                    P_VIDEO_MODE_TRIS=1;    //input NTSC/PAL select input
00275A  A882C9     BSET 0x2C9, #4
44:                    VIDMODE_ANDIS=1;   // disable ADC  on NTSC/PAL select input.
00275C  A8832D     BSET 0x32D, #4
45:                    // paddles interface I/O setting
46:                    P_PDL1_DAT_TRIS=1;      // paddle 1 data as input
00275E  A802C0     BSET TRISA, #0
47:                    P_PDL2_DAT_TRIS=1;      // paddle 2 data as input
002760  A822C0     BSET TRISA, #1
48:                    P_PDL_CLK_TRIS=0;       // paddles clock signal as output
002762  A902C8     BCLR TRISB, #0
49:                    P_PDL_LATCH_TRIS=0;     // paddles latch signal as output
002764  A922C8     BCLR TRISB, #1
50:                    P_PDL1_ANDIS=1;         // disable analog input
002766  A8032C     BSET AD1PCFG, #0
51:                    P_PDL2_ANDIS=1;         // disable analog input
002768  A8232C     BSET AD1PCFG, #1
52:                    // interrupts priorities
53:                    VSYNCIP=7;  // timer interrupt used for video output must have highest priority
00276A  270000     MOV #0x7000, W0
00276C  B720A6     IOR IPC1
54:                    PIXIP=7;  // change notification interrupt used for video pixels must have highest priority
00276E  B720AC     IOR IPC4
55:                    AUDIOIP=3; // audio output timer interrupt priority
002770  800544     MOV IPC2, W4
002772  B30034     IOR #0x3, W4
002774  A12004     BCLR W4, #2
002776  880544     MOV W4, IPC2
56:                    SYSTICKIP=2; // system ticks timer interrupt priority
002778  800524     MOV IPC0, W4
00277A  A1C004     BCLR W4, #12
00277C  A0D004     BSET W4, #13
00277E  A1E004     BCLR W4, #14
002780  880524     MOV W4, IPC0
57:                }//f()
002782  060000     RETURN
58:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/graphics.c  -------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   graphics.h
21:                 * Author: jacques Deschênes
22:                 * Description: Draw geometrics figures.
23:                 *      coordinates origin is screen top,left, x increase to right, y increase to bottom
24:                 * Created on 28 février 2014, 13:07
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "graphics.h"
29:                
30:                // draw a dot
31:                
32:                void plot(int x, int y, int color){
33:                    int h,ofs;
34:                    unsigned char mask;
35:                    if ((y>=VPIXELS)||(x>=HPIXELS)) return; // bound check
0012AC  200D74     MOV #0xD7, W4
0012AE  508F84     SUB W1, W4, [W15]
0012B0  3C0025     BRA GT, 0x12FC
0012B2  500F84     SUB W0, W4, [W15]
0012B4  3C0023     BRA GT, 0x12FC
36:                    h= x/8;
0012B6  200084     MOV #0x8, W4
0012B8  780281     MOV W1, W5
0012BA  090011     REPEAT #0x11
0012BC  D80004     DIV.SW W0, W4
0012BE  FD0281     EXCH W1, W5
37:                    ofs = 7 - x%8;
0012C0  1282E7     SUBR W5, #0x7, W5
38:                    mask = 1<<ofs;
0012C2  200016     MOV #0x1, W6
0012C4  DD3285     SL W6, W5, W5
39:                    switch (color){
0012C6  510F86     SUB W2, W6, [W15]
0012C8  32000C     BRA Z, 0x12E2
0012CA  510FE2     SUB W2, #0x2, [W15]
0012CC  320011     BRA Z, 0x12F0
0012CE  510FE0     SUB W2, #0x0, [W15]
0012D0  3A0015     BRA NZ, 0x12FC
40:                        case BLACK:
41:                            video_buffer[y][h]&= ~mask;
0012D2  208007     MOV #0x800, W7
0012D4  B9097B     MUL.SU W1, #27, W2
0012D6  400082     ADD W0, W2, W1
0012D8  438201     ADD W7, W1, W4
0012DA  EAC285     COM.B W5, W5
0012DC  78C3E7     MOV.B [W7+W1], W7
0012DE  62CA07     AND.B W5, W7, [W4]
42:                            break;
0012E0  37000D     BRA 0x12FC
43:                        case WHITE:
44:                            video_buffer[y][h]|= mask;
0012E2  208006     MOV #0x800, W6
0012E4  B9097B     MUL.SU W1, #27, W2
0012E6  400082     ADD W0, W2, W1
0012E8  430201     ADD W6, W1, W4
0012EA  78C366     MOV.B [W6+W1], W6
0012EC  72CA06     IOR.B W5, W6, [W4]
45:                            break;
0012EE  370006     BRA 0x12FC
46:                        case INVERT:
47:                            video_buffer[y][h] ^= mask;
0012F0  208006     MOV #0x800, W6
0012F2  B9097B     MUL.SU W1, #27, W2
0012F4  400082     ADD W0, W2, W1
0012F6  430201     ADD W6, W1, W4
0012F8  78C366     MOV.B [W6+W1], W6
0012FA  6ACA06     XOR.B W5, W6, [W4]
48:                            break;
49:                    }
50:                } // plot()
0012FC  060000     RETURN
51:                
52:                // dessine une droite en utilisant l'algorithme de Bresenham
53:                void line(int x1, int y1, int x2, int y2, int color){
0012FE  4787EA     ADD W15, #0xA, W15
001300  BE9F88     MOV.D W8, [W15++]
001302  BE9F8A     MOV.D W10, [W15++]
001304  BE9F8C     MOV.D W12, [W15++]
001306  781F8E     MOV W14, [W15++]
001308  780400     MOV W0, W8
00130A  780501     MOV W1, W10
00130C  780582     MOV W2, W11
00130E  9FB7F3     MOV W3, [W15-18]
001310  780604     MOV W4, W12
001326  448408     ADD W9, W8, W8
001328  370004     BRA 0x1332
00133C  540209     SUB W8, W9, W4
001352  44850A     ADD W9, W10, W10
00135E  550209     SUB W10, W9, W4
54:                    int deltax,deltay;
55:                    plot(x1,y1,color);
001312  78010C     MOV W12, W2
001314  78008A     MOV W10, W1
001316  780008     MOV W8, W0
001318  07FFC9     RCALL plot
56:                    if (y1==y2){// cas particulier ligne horizontale
00131A  97B27F     MOV [W15-18], W4
00131C  550F84     SUB W10, W4, [W15]
00131E  3A0012     BRA NZ, 0x1344
57:                        deltax= x1<x2?1:-1;
001320  540F8B     SUB W8, W11, [W15]
001322  3D0003     BRA GE, 0x132A
001324  200019     MOV #0x1, W9
00132A  EB8480     SETM W9
58:                        while (x1!=x2){
00132C  540F8B     SUB W8, W11, [W15]
00132E  3AFFFB     BRA NZ, 0x1326
001330  37004B     BRA 0x13C8
00133E  558F84     SUB W11, W4, [W15]
001340  3AFFF8     BRA NZ, 0x1332
001342  370042     BRA 0x13C8
59:                            x1 += deltax;
60:                            plot(x1,y1,color);
001332  78010C     MOV W12, W2
001334  78008A     MOV W10, W1
001336  780008     MOV W8, W0
001338  07FFB9     RCALL plot
00133A  440409     ADD W8, W9, W8
61:                        }
62:                    }else if (x1==x2){ // cas particulier ligne verticale
001344  540F8B     SUB W8, W11, [W15]
001346  3A0010     BRA NZ, 0x1368
63:                        deltay= y1<y2?1:-1;
001348  EB8480     SETM W9
00134A  97B2FF     MOV [W15-18], W5
00134C  550F85     SUB W10, W5, [W15]
00134E  3D0001     BRA GE, 0x1352
001350  200019     MOV #0x1, W9
64:                        while (y1!=y2){
001360  97B2FF     MOV [W15-18], W5
001362  528F84     SUB W5, W4, [W15]
001364  3AFFF7     BRA NZ, 0x1354
001366  370030     BRA 0x13C8
65:                            y1+=deltay;
66:                            plot(x1,y1,color);
001354  78010C     MOV W12, W2
001356  78008A     MOV W10, W1
001358  780008     MOV W8, W0
00135A  07FFA8     RCALL plot
00135C  450509     ADD W10, W9, W10
67:                        }
68:                    }else{
69:                        int sx,sy,err,e2;
70:                        deltax=abs(x2-x1);
001368  558708     SUB W11, W8, W14
00136A  A7F00E     BTSC W14, #15
00136C  EA070E     NEG W14, W14
71:                        deltay=abs(y2-y1);
00136E  97B2FF     MOV [W15-18], W5
001370  52820A     SUB W5, W10, W4
001372  A7F004     BTSC W4, #15
001374  EA0204     NEG W4, W4
001376  9FBF84     MOV W4, [W15-16]
72:                        sx = x1<x2?1:-1;
001378  EB8200     SETM W4
00137A  9FB7E4     MOV W4, [W15-20]
00137C  540F8B     SUB W8, W11, [W15]
00137E  3D0002     BRA GE, 0x1384
001380  200015     MOV #0x1, W5
001382  9FB7E5     MOV W5, [W15-20]
73:                        sy = y1<y2?1:-1;
001384  EB8200     SETM W4
001386  9FB7D4     MOV W4, [W15-22]
001388  97B2FF     MOV [W15-18], W5
00138A  550F85     SUB W10, W5, [W15]
00138C  3D0002     BRA GE, 0x1392
00138E  200014     MOV #0x1, W4
001390  9FB7D4     MOV W4, [W15-22]
74:                        err=deltax-deltay;
001392  97BA8F     MOV [W15-16], W5
001394  570485     SUB W14, W5, W9
75:                        while (!((x1==x2) && (y1==y2))){
00139A  78040B     MOV W11, W8
0013BE  540F8B     SUB W8, W11, [W15]
0013C0  3AFFED     BRA NZ, 0x139C
0013C2  97B2FF     MOV [W15-18], W5
0013C4  550F85     SUB W10, W5, [W15]
0013C6  3AFFE9     BRA NZ, 0x139A
76:                            e2=err<<1;
00139C  448209     ADD W9, W9, W4
77:                            if (e2>-deltay){
001396  EA0685     NEG W5, W13
001398  370001     BRA 0x139C
00139E  520F8D     SUB W4, W13, [W15]
0013A0  340005     BRA LE, 0x13AC
78:                               err -= deltay;
0013A2  97BA0F     MOV [W15-16], W4
0013A4  548484     SUB W9, W4, W9
79:                               x1 += sx;
0013A6  97B2EF     MOV [W15-20], W5
0013A8  440405     ADD W8, W5, W8
0013AA  370005     BRA 0x13B6
80:                            }else if (e2<deltax){
0013AC  570F84     SUB W14, W4, [W15]
0013AE  340003     BRA LE, 0x13B6
81:                                err +=deltax;
0013B0  44848E     ADD W9, W14, W9
82:                                y1 += sy;
0013B2  97B25F     MOV [W15-22], W4
0013B4  450504     ADD W10, W4, W10
83:                            }
84:                            plot(x1,y1,color);
0013B6  78010C     MOV W12, W2
0013B8  78008A     MOV W10, W1
0013BA  780008     MOV W8, W0
0013BC  07FF77     RCALL plot
85:                        }
86:                    }
87:                } // line()
0013C8  78074F     MOV [--W15], W14
0013CA  BE064F     MOV.D [--W15], W12
0013CC  BE054F     MOV.D [--W15], W10
0013CE  BE044F     MOV.D [--W15], W8
0013D0  B100AF     SUB #0xA, W15
0013D2  060000     RETURN
88:                
89:                void rectangle(int x1, int y1, int x2, int y2, int color){
0013D4  BE9F88     MOV.D W8, [W15++]
0013D6  BE9F8A     MOV.D W10, [W15++]
0013D8  781F8C     MOV W12, [W15++]
0013DA  780480     MOV W0, W9
0013DC  780401     MOV W1, W8
0013DE  780502     MOV W2, W10
0013E0  780603     MOV W3, W12
0013E2  780584     MOV W4, W11
90:                    line(x1,y1,x1,y2,color);
0013E4  780109     MOV W9, W2
0013E6  780088     MOV W8, W1
0013E8  780009     MOV W9, W0
0013EA  07FF89     RCALL line
91:                    line(x2,y1,x2,y2,color);
0013EC  78020B     MOV W11, W4
0013EE  78018C     MOV W12, W3
0013F0  78010A     MOV W10, W2
0013F2  780088     MOV W8, W1
0013F4  78000A     MOV W10, W0
0013F6  07FF83     RCALL line
92:                    line(x1,y1,x2,y1,color);
0013F8  78020B     MOV W11, W4
0013FA  780188     MOV W8, W3
0013FC  78010A     MOV W10, W2
0013FE  780088     MOV W8, W1
001400  780009     MOV W9, W0
001402  07FF7D     RCALL line
93:                    line(x1,y2,x2,y2,color);
001404  78020B     MOV W11, W4
001406  78018C     MOV W12, W3
001408  78010A     MOV W10, W2
00140A  78008C     MOV W12, W1
00140C  780009     MOV W9, W0
00140E  07FF77     RCALL line
94:                }//rectangle()
001410  78064F     MOV [--W15], W12
001412  BE054F     MOV.D [--W15], W10
001414  BE044F     MOV.D [--W15], W8
001416  060000     RETURN
95:                
96:                /*  algorthme mid-point
97:                 * REF: http://www.hhhprogram.com/2013/05/draw-elipse-midpoint-elipse-algorithm.html
98:                 */
99:                void ellipse (int xc, int yc, long rx, long ry, int color){
001418  B0036F     ADD #0x36, W15
00141A  BE9F88     MOV.D W8, [W15++]
00141C  BE9F8A     MOV.D W10, [W15++]
00141E  BE9F8C     MOV.D W12, [W15++]
001420  781F8E     MOV W14, [W15++]
001422  9FAF90     MOV W0, [W15-46]
001424  9FAFE1     MOV W1, [W15-36]
001426  BE0504     MOV.D W4, W10
001428  780706     MOV W6, W14
0014A4  9FA7F2     MOV W2, [W15-50]
0014A6  9FAF83     MOV W3, [W15-48]
0014B2  97AA9F     MOV [W15-46], W5
0014B4  E90285     DEC W5, W5
0014B6  9FA7C5     MOV W5, [W15-56]
0014B8  97AB1F     MOV [W15-46], W6
0014BA  E80306     INC W6, W6
0014BC  9FA7B6     MOV W6, [W15-58]
0014BE  9F9FFA     MOV W10, [W15-66]
0014C0  9FA78B     MOV W11, [W15-64]
0014CA  97B47F     MOV [W15-18], W8
0014CC  97A0CF     MOV [W15-56], W1
0014CE  408088     ADD W1, W8, W1
0014D0  9FB791     MOV W1, [W15-30]
0014DE  97A1BF     MOV [W15-58], W3
0014E0  518408     SUB W3, W8, W8
00150A  97A07F     MOV [W15-50], W0
00150C  97A88F     MOV [W15-48], W1
00150E  40030C     ADD W0, W12, W6
001510  48838D     ADDC W1, W13, W7
001540  97A47F     MOV [W15-50], W8
001542  97AC8F     MOV [W15-48], W9
001544  44030C     ADD W8, W12, W6
001546  4C838D     ADDC W9, W13, W7
001564  97B37F     MOV [W15-18], W6
001566  97BB8F     MOV [W15-16], W7
001568  530061     SUB W6, #0x1, W0
00156A  5B80E0     SUBB W7, #0x0, W1
001614  97AA4F     MOV [W15-40], W4
001616  97AADF     MOV [W15-38], W5
001618  120260     SUBR W4, #0x0, W4
00161A  1A82E0     SUBBR W5, #0x0, W5
00161C  9FB794     MOV W4, [W15-30]
00161E  9FB7A5     MOV W5, [W15-28]
001620  97AADF     MOV [W15-38], W5
001622  97B47F     MOV [W15-18], W8
001624  B9AB08     MUL.SS W5, W8, W6
001626  97BC8F     MOV [W15-16], W9
001628  97A84F     MOV [W15-40], W0
00162A  B9CA00     MUL.SS W9, W0, W4
00162C  420206     ADD W4, W6, W4
00162E  97A9CF     MOV [W15-40], W3
001630  97B15F     MOV [W15-22], W2
001632  B81902     MUL.UU W3, W2, W2
001634  9FB7B2     MOV W2, [W15-26]
001636  9FB7C3     MOV W3, [W15-24]
001638  420183     ADD W4, W3, W3
00163A  9FB7C3     MOV W3, [W15-24]
00163C  97B23F     MOV [W15-26], W4
00163E  97B2CF     MOV [W15-24], W5
001640  9FB7D4     MOV W4, [W15-22]
001642  9FB7E5     MOV W5, [W15-20]
00164C  97ABEF     MOV [W15-36], W7
00164E  53858C     SUB W7, W12, W11
00165C  97A8EF     MOV [W15-36], W1
00165E  40848C     ADD W1, W12, W9
001684  560261     SUB W12, #0x1, W4
001686  5E82E0     SUBB W13, #0x0, W5
0016A2  560261     SUB W12, #0x1, W4
0016A4  5E82E0     SUBB W13, #0x0, W5
100:                         long  x=0,y=ry;
101:                         long  p=(ry*ry)-(rx*rx*ry)+((rx*rx)/4);
00142A  B99A02     MUL.SS W3, W2, W4
00142C  420204     ADD W4, W4, W4
00142E  B81002     MUL.UU W2, W2, W0
001430  9FAFA0     MOV W0, [W15-44]
001432  9FAFB1     MOV W1, [W15-42]
001434  420081     ADD W4, W1, W1
001436  9FAFB1     MOV W1, [W15-42]
001438  97A92F     MOV [W15-44], W2
00143A  97A9BF     MOV [W15-42], W3
00143C  550202     SUB W10, W2, W4
00143E  5D8283     SUBB W11, W3, W5
001440  B9AB0A     MUL.SS W5, W10, W6
001442  B9D804     MUL.SS W11, W4, W0
001444  400306     ADD W0, W6, W6
001446  B8220A     MUL.UU W4, W10, W4
001448  430285     ADD W6, W5, W5
00144A  BE0302     MOV.D W2, W6
00144C  510FE0     SUB W2, #0x0, [W15]
00144E  598FE0     SUBB W3, #0x0, [W15]
001450  3D0002     BRA GE, 0x1456
001452  410363     ADD W2, #0x3, W6
001454  4983E0     ADDC W3, #0x0, W7
001456  DD39CE     SL W7, #14, W3
001458  DE3342     LSR W6, #2, W6
00145A  718306     IOR W3, W6, W6
00145C  DEBBC2     ASR W7, #2, W7
00145E  430404     ADD W6, W4, W8
001460  4B8485     ADDC W7, W5, W9
001462  9FB7B8     MOV W8, [W15-26]
001464  9FB7C9     MOV W9, [W15-24]
102:                         while((2*x*ry*ry)<(2*y*rx*rx)){
001466  B9DA0A     MUL.SS W11, W10, W4
001468  420204     ADD W4, W4, W4
00146A  B8500A     MUL.UU W10, W10, W0
00146C  9FA7D0     MOV W0, [W15-54]
00146E  9FA7E1     MOV W1, [W15-52]
001470  420081     ADD W4, W1, W1
001472  9FA7E1     MOV W1, [W15-52]
001474  97A15F     MOV [W15-54], W2
001476  97A1EF     MOV [W15-52], W3
001478  410102     ADD W2, W2, W2
00147A  498183     ADDC W3, W3, W3
00147C  9FA792     MOV W2, [W15-62]
00147E  9FA7A3     MOV W3, [W15-60]
001480  97AA2F     MOV [W15-44], W4
001482  97AABF     MOV [W15-42], W5
001484  420204     ADD W4, W4, W4
001486  4A8285     ADDC W5, W5, W5
001488  9FB7D4     MOV W4, [W15-22]
00148A  9FB7E5     MOV W5, [W15-20]
0014A8  200014     MOV #0x1, W4
0014AA  200005     MOV #0x0, W5
0014AC  9FB7F4     MOV W4, [W15-18]
0014AE  9FBF85     MOV W5, [W15-16]
0014B0  B86660     MUL.UU W12, #0, W12
0014C2  370050     BRA 0x1564
00156C  97B3DF     MOV [W15-22], W7
00156E  B9DA07     MUL.SS W11, W7, W4
001570  97B46F     MOV [W15-20], W8
001572  B9C30A     MUL.SS W8, W10, W6
001574  430304     ADD W6, W4, W6
001576  97B4DF     MOV [W15-22], W9
001578  B85209     MUL.UU W10, W9, W4
00157A  430285     ADD W6, W5, W5
00157C  520F8C     SUB W4, W12, [W15]
00157E  5A8F8D     SUBB W5, W13, [W15]
001580  3CFFA1     BRA GT, 0x14C4
001582  BE010A     MOV.D W10, W2
001584  9FB79A     MOV W10, [W15-30]
001586  9FB7AB     MOV W11, [W15-28]
001588  9FAFF0     MOV W0, [W15-34]
00158A  9FB781     MOV W1, [W15-32]
00158C  979D7F     MOV [W15-66], W10
00158E  97A58F     MOV [W15-64], W11
001590  BE0600     MOV.D W0, W12
103:                              plot(xc+x,yc-y,color);
0014C4  97A86F     MOV [W15-36], W0
0014C6  50000A     SUB W0, W10, W0
0014C8  9FAFF0     MOV W0, [W15-34]
0014D2  78010E     MOV W14, W2
0014D4  780080     MOV W0, W1
0014D6  97B01F     MOV [W15-30], W0
0014D8  07FEE9     RCALL plot
104:                              plot(xc-x,yc+y,color);
0014DA  97A96F     MOV [W15-36], W2
0014DC  450482     ADD W10, W2, W9
0014E2  78010E     MOV W14, W2
0014E4  BE0008     MOV.D W8, W0
0014E6  07FEE2     RCALL plot
105:                              plot(xc+x,yc+y,color);
0014E8  78010E     MOV W14, W2
0014EA  780089     MOV W9, W1
0014EC  97B01F     MOV [W15-30], W0
0014EE  07FEDE     RCALL plot
106:                              plot(xc-x,yc-y,color);
0014F0  78010E     MOV W14, W2
0014F2  97A8FF     MOV [W15-34], W1
0014F4  780008     MOV W8, W0
0014F6  07FEDA     RCALL plot
107:                              if(p<0){
0014F8  97B23F     MOV [W15-26], W4
0014FA  97B2CF     MOV [W15-24], W5
0014FC  520FE0     SUB W4, #0x0, [W15]
0014FE  5A8FE0     SUBB W5, #0x0, [W15]
001500  3D000D     BRA GE, 0x151C
108:                                  x=x+1;
109:                                  p=p+(2*ry*ry*x)+(ry*ry);
001502  97A45F     MOV [W15-54], W8
001504  97A4EF     MOV [W15-52], W9
001506  440204     ADD W8, W4, W4
001508  4C8285     ADDC W9, W5, W5
001512  420106     ADD W4, W6, W2
001514  4A8187     ADDC W5, W7, W3
001516  9FB7B2     MOV W2, [W15-26]
001518  9FB7C3     MOV W3, [W15-24]
00151A  37001A     BRA 0x1550
110:                              }else {
111:                                  x=x+1;
112:                                  y=y-1;
00151C  550561     SUB W10, #0x1, W10
00151E  5D85E0     SUBB W11, #0x0, W11
113:                                  p=p+(2*ry*ry*x+ry*ry)-(2*rx*rx*y);
00148C  2FFFE4     MOV #0xFFFE, W4
00148E  97AB3F     MOV [W15-42], W6
001490  B9B204     MUL.SS W6, W4, W4
001492  97ABAF     MOV [W15-44], W7
001494  520207     SUB W4, W7, W4
001496  2FFFE5     MOV #0xFFFE, W5
001498  97ACAF     MOV [W15-44], W9
00149A  B84C05     MUL.UU W9, W5, W8
00149C  9FAFC8     MOV W8, [W15-40]
00149E  9FAFD9     MOV W9, [W15-38]
0014A0  420489     ADD W4, W9, W9
0014A2  9FAFD9     MOV W9, [W15-38]
001520  97B23F     MOV [W15-26], W4
001522  97B2CF     MOV [W15-24], W5
001524  97A45F     MOV [W15-54], W8
001526  97A4EF     MOV [W15-52], W9
001528  440304     ADD W8, W4, W6
00152A  4C8385     ADDC W9, W5, W7
00152C  97ACCF     MOV [W15-40], W9
00152E  B9DA09     MUL.SS W11, W9, W4
001530  97A95F     MOV [W15-38], W2
001532  B9900A     MUL.SS W2, W10, W0
001534  400004     ADD W0, W4, W0
001536  97A9CF     MOV [W15-40], W3
001538  B85203     MUL.UU W10, W3, W4
00153A  400285     ADD W0, W5, W5
00153C  420206     ADD W4, W6, W4
00153E  4A8287     ADDC W5, W7, W5
001548  420006     ADD W4, W6, W0
00154A  4A8087     ADDC W5, W7, W1
00154C  9FB7B0     MOV W0, [W15-26]
00154E  9FB7C1     MOV W1, [W15-24]
001550  97A17F     MOV [W15-50], W2
001552  97A98F     MOV [W15-48], W3
001554  41060C     ADD W2, W12, W12
001556  49868D     ADDC W3, W13, W13
001558  97B27F     MOV [W15-18], W4
00155A  97BA8F     MOV [W15-16], W5
00155C  420261     ADD W4, #0x1, W4
00155E  4A82E0     ADDC W5, #0x0, W5
001560  9FB7F4     MOV W4, [W15-18]
001562  9FBF85     MOV W5, [W15-16]
114:                              }
115:                         }
116:                         p=((float)x+0.5)*((float)x+0.5)*ry*ry+(y-1)*(y-1)*rx*rx-rx*rx*ry*ry;
001598  BE000A     MOV.D W10, W0
00159A  07F70C     RCALL 0x3B4
00159C  BE0400     MOV.D W0, W8
00159E  97B31F     MOV [W15-30], W6
0015A0  97B3AF     MOV [W15-28], W7
0015A2  530361     SUB W6, #0x1, W6
0015A4  5B83E0     SUBB W7, #0x0, W7
0015A6  9FB7F6     MOV W6, [W15-18]
0015A8  9FBF87     MOV W7, [W15-16]
0015AA  BE000C     MOV.D W12, W0
0015AC  07F703     RCALL 0x3B4
0015AE  200002     MOV #0x0, W2
0015B0  23F003     MOV #0x3F00, W3
0015B2  07F682     RCALL 0x2B8
0015B4  BE0100     MOV.D W0, W2
0015B6  07F754     RCALL 0x460
0015B8  BE0108     MOV.D W8, W2
0015BA  07F752     RCALL 0x460
0015BC  BE0100     MOV.D W0, W2
0015BE  BE0008     MOV.D W8, W0
0015C0  07F74F     RCALL 0x460
0015C2  BE0400     MOV.D W0, W8
0015C4  97BB8F     MOV [W15-16], W7
0015C6  97B07F     MOV [W15-18], W0
0015C8  B9BA00     MUL.SS W7, W0, W4
0015CA  420204     ADD W4, W4, W4
0015CC  97B0FF     MOV [W15-18], W1
0015CE  9FB7D1     MOV W1, [W15-22]
0015D0  780101     MOV W1, W2
0015D2  B81002     MUL.UU W2, W2, W0
0015D4  420081     ADD W4, W1, W1
0015D6  97A9AF     MOV [W15-44], W3
0015D8  B98B03     MUL.SS W1, W3, W6
0015DA  97A93F     MOV [W15-42], W2
0015DC  B99200     MUL.SS W2, W0, W4
0015DE  420206     ADD W4, W6, W4
0015E0  97AD2F     MOV [W15-44], W10
0015E2  B8000A     MUL.UU W0, W10, W0
0015E4  420081     ADD W4, W1, W1
0015E6  07F6E6     RCALL 0x3B4
0015E8  BE0100     MOV.D W0, W2
0015EA  BE0008     MOV.D W8, W0
0015EC  07F665     RCALL 0x2B8
0015EE  BE0400     MOV.D W0, W8
0015F0  97A9BF     MOV [W15-42], W3
0015F2  97A25F     MOV [W15-54], W4
0015F4  B99B04     MUL.SS W3, W4, W6
0015F6  97A06F     MOV [W15-52], W0
0015F8  97A8AF     MOV [W15-44], W1
0015FA  B98201     MUL.SS W0, W1, W4
0015FC  420206     ADD W4, W6, W4
0015FE  97A15F     MOV [W15-54], W2
001600  B85002     MUL.UU W10, W2, W0
001602  420081     ADD W4, W1, W1
001604  07F6D7     RCALL 0x3B4
001606  BE0100     MOV.D W0, W2
001608  BE0008     MOV.D W8, W0
00160A  07F655     RCALL 0x2B6
00160C  07F6B2     RCALL 0x372
00160E  BE0500     MOV.D W0, W10
001610  97B61F     MOV [W15-30], W12
001612  97B6AF     MOV [W15-28], W13
117:                         while(y>=0){
001592  510FE0     SUB W2, #0x0, [W15]
001594  598FE0     SUBB W3, #0x0, [W15]
001596  3500B8     BRA LT, 0x1708
001702  520FE0     SUB W4, #0x0, [W15]
001704  5A8FE0     SUBB W5, #0x0, [W15]
001706  3DFFA2     BRA GE, 0x164C
118:                              plot(xc+x,yc-y,color);
001650  97AC7F     MOV [W15-34], W8
001652  97A81F     MOV [W15-46], W0
001654  440500     ADD W8, W0, W10
001656  78010E     MOV W14, W2
001658  BE000A     MOV.D W10, W0
00165A  07FE28     RCALL plot
119:                              plot(xc-x,yc+y,color);
001660  97A91F     MOV [W15-46], W2
001662  510408     SUB W2, W8, W8
001664  78010E     MOV W14, W2
001666  BE0008     MOV.D W8, W0
001668  07FE21     RCALL plot
120:                              plot(xc+x,yc+y,color);
00166A  78010E     MOV W14, W2
00166C  780089     MOV W9, W1
00166E  78000A     MOV W10, W0
001670  07FE1D     RCALL plot
121:                              plot(xc-x,yc-y,color);
001672  78010E     MOV W14, W2
001674  78008B     MOV W11, W1
001676  780008     MOV W8, W0
001678  07FE19     RCALL plot
122:                              if(p>0){
00167A  97B27F     MOV [W15-18], W4
00167C  97BA8F     MOV [W15-16], W5
00167E  520FE0     SUB W4, #0x0, [W15]
001680  5A8FE0     SUBB W5, #0x0, [W15]
001682  34000F     BRA LE, 0x16A2
123:                                  y=y-1;
124:                                  p=p-(2*rx*rx*y)+(rx*rx);
001688  97B47F     MOV [W15-18], W8
00168A  97BC8F     MOV [W15-16], W9
00168C  97A82F     MOV [W15-44], W0
00168E  97A8BF     MOV [W15-42], W1
001690  400308     ADD W0, W8, W6
001692  488389     ADDC W1, W9, W7
001694  97B15F     MOV [W15-22], W2
001696  97B1EF     MOV [W15-20], W3
001698  430102     ADD W6, W2, W2
00169A  4B8183     ADDC W7, W3, W3
00169C  9FB7F2     MOV W2, [W15-18]
00169E  9FBF83     MOV W3, [W15-16]
0016A0  370020     BRA 0x16E2
125:                              }else{
126:                                  y=y-1;
127:                                  x=x+1;
0016A6  97AB7F     MOV [W15-34], W6
0016A8  97B38F     MOV [W15-32], W7
0016AA  430361     ADD W6, #0x1, W6
0016AC  4B83E0     ADDC W7, #0x0, W7
0016AE  9FAFF6     MOV W6, [W15-34]
0016B0  9FB787     MOV W7, [W15-32]
128:                                  p=p+(2*ry*ry*x)-(2*rx*rx*y)-(rx*rx);
001644  97A29F     MOV [W15-62], W5
001646  9FAFC5     MOV W5, [W15-40]
001648  9FB7FA     MOV W10, [W15-18]
00164A  9FBF8B     MOV W11, [W15-16]
0016B2  97B47F     MOV [W15-18], W8
0016B4  97BC8F     MOV [W15-16], W9
0016B6  97A82F     MOV [W15-44], W0
0016B8  97A8BF     MOV [W15-42], W1
0016BA  540100     SUB W8, W0, W2
0016BC  5C8181     SUBB W9, W1, W3
0016BE  97A3AF     MOV [W15-60], W7
0016C0  B9B806     MUL.SS W7, W6, W0
0016C2  97B40F     MOV [W15-32], W8
0016C4  97A49F     MOV [W15-62], W9
0016C6  B9C309     MUL.SS W8, W9, W6
0016C8  430000     ADD W6, W0, W0
0016CA  97A8CF     MOV [W15-40], W1
0016CC  97AC7F     MOV [W15-34], W8
0016CE  B80B08     MUL.UU W1, W8, W6
0016D0  400387     ADD W0, W7, W7
0016D2  430302     ADD W6, W2, W6
0016D4  4B8383     ADDC W7, W3, W7
0016D6  97B03F     MOV [W15-26], W0
0016D8  97B0CF     MOV [W15-24], W1
0016DA  430000     ADD W6, W0, W0
0016DC  4B8081     ADDC W7, W1, W1
0016DE  9FB7F0     MOV W0, [W15-18]
0016E0  9FBF81     MOV W1, [W15-16]
0016E2  560661     SUB W12, #0x1, W12
0016E4  5E86E0     SUBB W13, #0x0, W13
0016E6  97B15F     MOV [W15-22], W2
0016E8  97B1EF     MOV [W15-20], W3
0016EA  97B31F     MOV [W15-30], W6
0016EC  97B3AF     MOV [W15-28], W7
0016EE  430102     ADD W6, W2, W2
0016F0  4B8183     ADDC W7, W3, W3
0016F2  9FB7D2     MOV W2, [W15-22]
0016F4  9FB7E3     MOV W3, [W15-20]
0016F6  97B43F     MOV [W15-26], W8
0016F8  97B4CF     MOV [W15-24], W9
0016FA  430408     ADD W6, W8, W8
0016FC  4B8489     ADDC W7, W9, W9
0016FE  9FB7B8     MOV W8, [W15-26]
001700  9FB7C9     MOV W9, [W15-24]
129:                              }
130:                         }
131:               }//ellipse()
001708  78074F     MOV [--W15], W14
00170A  BE064F     MOV.D [--W15], W12
00170C  BE054F     MOV.D [--W15], W10
00170E  BE044F     MOV.D [--W15], W8
001710  B1036F     SUB #0x36, W15
001712  060000     RETURN
132:               
133:               /*
134:                * points[]={x1,y1,x2,y2,x3,y3,...}
135:                * vertices est le nombre de points
136:                */
137:               void polygon(int points[], int vertices, int color){
001714  BE9F88     MOV.D W8, [W15++]
001716  BE9F8A     MOV.D W10, [W15++]
001718  781F8C     MOV W12, [W15++]
00171A  780600     MOV W0, W12
00171C  780582     MOV W2, W11
138:                   int i;
139:                   for(i=0;i<(2*vertices-2);i+=2){
00171E  E90501     DEC W1, W10
001720  45050A     ADD W10, W10, W10
001722  EB0480     CLR W9
001724  550F89     SUB W10, W9, [W15]
001726  34000B     BRA LE, 0x173E
001728  78040C     MOV W12, W8
001736  E88489     INC2 W9, W9
001738  440464     ADD W8, #0x4, W8
00173A  550F89     SUB W10, W9, [W15]
00173C  3CFFF6     BRA GT, 0x172A
140:                       line(points[i],points[i+1],points[i+2],points[i+3],color);
00172A  900128     MOV [W8+4], W2
00172C  900098     MOV [W8+2], W1
00172E  78020B     MOV W11, W4
001730  9001B8     MOV [W8+6], W3
001732  780018     MOV [W8], W0
001734  07FDE4     RCALL line
141:                   }
142:                   line(points[0],points[1],points[i],points[i+1],color);
00173E  E80289     INC W9, W5
001740  428285     ADD W5, W5, W5
001742  448489     ADD W9, W9, W9
001744  90009C     MOV [W12+2], W1
001746  78020B     MOV W11, W4
001748  7A81EC     MOV [W12+W5], W3
00174A  7C816C     MOV [W12+W9], W2
00174C  78001C     MOV [W12], W0
00174E  07FDD7     RCALL line
143:               }//polygon()
001750  78064F     MOV [--W15], W12
001752  BE054F     MOV.D [--W15], W10
001754  BE044F     MOV.D [--W15], W8
001756  060000     RETURN
144:               
145:               
146:               void box(int left, int top, int width, int height,int color){
001758  4787E4     ADD W15, #0x4, W15
00175A  BE9F88     MOV.D W8, [W15++]
00175C  BE9F8A     MOV.D W10, [W15++]
00175E  BE9F8C     MOV.D W12, [W15++]
001760  781F8E     MOV W14, [W15++]
001762  9FBF80     MOV W0, [W15-16]
147:                   int y, x,idx,mwidth,bitsleft;
148:                   unsigned char mask;
149:                   for (y=top;y<top+height;y++){
001764  418701     ADD W3, W1, W14
001766  508F8E     SUB W1, W14, [W15]
001768  350035     BRA LT, 0x17D4
00176A  37003C     BRA 0x17E4
0017CC  E8068D     INC W13, W13
0017CE  568F8E     SUB W13, W14, [W15]
0017D0  350006     BRA LT, 0x17DE
0017D2  370008     BRA 0x17E4
0017D4  780681     MOV W1, W13
150:                       x=left;
151:                       bitsleft=width;
152:                       while (bitsleft){
001770  780382     MOV W2, W7
001772  97BA8F     MOV [W15-16], W5
0017CA  3AFFD0     BRA NZ, 0x176C
0017DE  510FE0     SUB W2, #0x0, [W15]
0017E0  3AFFC7     BRA NZ, 0x1770
0017E2  37FFF4     BRA 0x17CC
153:                           idx=x/8;
001778  090011     REPEAT #0x11
00177A  D80283     DIV.SW W5, W3
00177C  780400     MOV W0, W8
0017D6  200083     MOV #0x8, W3
154:                           if (x%8==0){
00177E  6280E7     AND W5, #0x7, W1
001784  320006     BRA Z, 0x1792
155:                               mask=0xff;
001780  78400A     MOV.B W10, W0
0017DC  EBC500     SETM.B W10
156:                               mwidth=8;
001782  780303     MOV W3, W6
157:                           }else{
158:                               mask=0xff>>(x%8);
001786  780301     MOV W1, W6
001788  090011     REPEAT #0x11
00178A  D80283     DIV.SW W5, W3
00178C  FD0301     EXCH W1, W6
00178E  DED806     ASR W11, W6, W0
0017D8  200FFB     MOV #0xFF, W11
159:                               mwidth=8-x%8;
001790  130368     SUBR W6, #0x8, W6
160:                           }
161:                           if (bitsleft<mwidth){
001792  530F87     SUB W6, W7, [W15]
001794  340004     BRA LE, 0x179E
162:                               mask &= 0xff<<(mwidth-bitsleft);
001796  530307     SUB W6, W7, W6
001798  DD5B06     SL W11, W6, W6
00179A  604006     AND.B W0, W6, W0
00179C  780307     MOV W7, W6
163:                               mwidth=bitsleft;
164:                           }
165:                           switch(color){
00179E  520FE1     SUB W4, #0x1, [W15]
0017A0  32000A     BRA Z, 0x17B6
0017A2  520FE2     SUB W4, #0x2, [W15]
0017A4  32000D     BRA Z, 0x17C0
0017A6  520FE0     SUB W4, #0x0, [W15]
0017A8  3A000F     BRA NZ, 0x17C8
166:                               case BLACK:
167:                                   video_buffer[y][idx] &= ~mask;
0017AA  460408     ADD W12, W8, W8
0017AC  448088     ADD W9, W8, W1
0017AE  EAC000     COM.B W0, W0
0017B0  7C4469     MOV.B [W9+W8], W8
0017B2  604888     AND.B W0, W8, [W1]
168:                                   break;
0017B4  370009     BRA 0x17C8
169:                               case WHITE:
170:                                   video_buffer[y][idx] |= mask;
001774  B9687B     MUL.SU W13, #27, W0
001776  780600     MOV W0, W12
0017B6  460408     ADD W12, W8, W8
0017B8  448088     ADD W9, W8, W1
0017BA  7C4469     MOV.B [W9+W8], W8
0017BC  704888     IOR.B W0, W8, [W1]
0017DA  208009     MOV #0x800, W9
171:                                   break;
0017BE  370004     BRA 0x17C8
172:                               case INVERT:
173:                                   video_buffer[y][idx] ^= mask;
0017C0  460408     ADD W12, W8, W8
0017C2  448088     ADD W9, W8, W1
0017C4  7C4469     MOV.B [W9+W8], W8
0017C6  684888     XOR.B W0, W8, [W1]
174:                                   break;
175:                           }//switch
176:                           x += mwidth;
00176C  428286     ADD W5, W6, W5
00176E  370004     BRA 0x1778
177:                           bitsleft -= mwidth;
0017C8  538386     SUB W7, W6, W7
178:                       }//while
179:                   }//for
180:               }//f()
0017E4  78074F     MOV [--W15], W14
0017E6  BE064F     MOV.D [--W15], W12
0017E8  BE054F     MOV.D [--W15], W10
0017EA  BE044F     MOV.D [--W15], W8
0017EC  B1004F     SUB #0x4, W15
0017EE  060000     RETURN
181:               
182:               
183:               
184:               void bitmap(int left, int top, int width, int height, bmp_op_t op, const unsigned char* bmp){
0017F0  4787EE     ADD W15, #0xE, W15
0017F2  BE9F88     MOV.D W8, [W15++]
0017F4  BE9F8A     MOV.D W10, [W15++]
0017F6  BE9F8C     MOV.D W12, [W15++]
0017F8  781F8E     MOV W14, [W15++]
0017FA  9FB7B0     MOV W0, [W15-26]
0017FC  9FB7E2     MOV W2, [W15-20]
0018F8  97B3DF     MOV [W15-22], W7
0018FA  458587     ADD W11, W7, W11
0018FC  370005     BRA 0x1908
185:                   int x,y, xbmp,mwidth,idx, bitsleft,ybmp_inc;
186:                   unsigned char  mask, bmpbits, *ybmp;
187:               
188:                   ybmp_inc=width/8;
0017FE  200086     MOV #0x8, W6
001800  BE9F80     MOV.D W0, [W15++]
001802  090011     REPEAT #0x11
001804  D80106     DIV.SW W2, W6
001806  780100     MOV W0, W2
001808  BE004F     MOV.D [--W15], W0
00180A  9FB7D2     MOV W2, [W15-22]
189:                   if (width%8) ybmp_inc++;
00180C  97B3EF     MOV [W15-20], W7
00180E  638367     AND W7, #0x7, W6
001810  320002     BRA Z, 0x1816
001812  E80102     INC W2, W2
001814  9FB7D2     MOV W2, [W15-22]
190:                   ybmp=bmp;
0018FE  780585     MOV W5, W11
191:                   //remainder=0;
192:                   for (y=top;y<top+height;y++){
001816  418181     ADD W3, W1, W3
001818  9FB7C3     MOV W3, [W15-24]
00181A  508F83     SUB W1, W3, [W15]
00181C  350070     BRA LT, 0x18FE
00181E  370078     BRA 0x1910
0018EC  97B27F     MOV [W15-18], W4
0018EE  E80204     INC W4, W4
0018F0  9FB7F4     MOV W4, [W15-18]
0018F2  97B34F     MOV [W15-24], W6
0018F4  530F84     SUB W6, W4, [W15]
0018F6  34000C     BRA LE, 0x1910
001900  9FB7F1     MOV W1, [W15-18]
193:                       x=left;
194:                       xbmp=0;
195:                       bitsleft=width;
196:                       while (bitsleft){
001826  97B3EF     MOV [W15-20], W7
001828  97B23F     MOV [W15-26], W4
00182A  EB0000     CLR W0
0018EA  3AFF9A     BRA NZ, 0x1820
001908  97B46F     MOV [W15-20], W8
00190A  540FE0     SUB W8, #0x0, [W15]
00190C  3AFF8C     BRA NZ, 0x1826
00190E  37FFEE     BRA 0x18EC
197:                           idx=x/8;
001834  780500     MOV W0, W10
001836  090011     REPEAT #0x11
001838  D80205     DIV.SW W4, W5
00183A  FD0500     EXCH W0, W10
001902  200085     MOV #0x8, W5
198:                           if (x%8==0){
00183C  620167     AND W4, #0x7, W2
001842  320008     BRA Z, 0x1854
199:                               mask=0xff;
00183E  78408E     MOV.B W14, W1
001906  EBC700     SETM.B W14
200:                               mwidth=8;
001840  780305     MOV W5, W6
201:                           }else{
202:                               mask=0xff>>(x%8);
001844  781F80     MOV W0, [W15++]
001846  090011     REPEAT #0x11
001848  D80205     DIV.SW W4, W5
00184A  780301     MOV W1, W6
00184C  78004F     MOV [--W15], W0
00184E  200FF2     MOV #0xFF, W2
001850  DE9086     ASR W2, W6, W1
203:                               mwidth=8-x%8;
001852  130368     SUBR W6, #0x8, W6
204:                           }
205:                           if (bitsleft<mwidth){
001854  530F87     SUB W6, W7, [W15]
001856  340005     BRA LE, 0x1862
206:                               mask &= 0xff<<(mwidth-bitsleft);
001858  530307     SUB W6, W7, W6
00185A  200FF3     MOV #0xFF, W3
00185C  DD1B06     SL W3, W6, W6
00185E  60C086     AND.B W1, W6, W1
001860  780307     MOV W7, W6
207:                               mwidth=bitsleft;
208:                           }
209:                           bmpbits = (*(ybmp+xbmp/8))<<(xbmp%8);
001862  780400     MOV W0, W8
001864  780181     MOV W1, W3
001866  090011     REPEAT #0x11
001868  D80005     DIV.SW W0, W5
00186A  FD0400     EXCH W0, W8
00186C  FD0181     EXCH W1, W3
00186E  7C416B     MOV.B [W11+W8], W2
001870  FB8102     ZE W2, W2
001872  DD1103     SL W2, W3, W2
210:                           if (xbmp%8){
001874  6004E7     AND W0, #0x7, W9
001876  320006     BRA Z, 0x1884
211:                               bmpbits |= (*(ybmp+xbmp/8+1))>>(8-xbmp%8);
001878  458408     ADD W11, W8, W8
00187A  904418     MOV.B [W8+1], W8
00187C  FB8408     ZE W8, W8
00187E  1181E8     SUBR W3, #0x8, W3
001880  DEC183     ASR W8, W3, W3
001882  714103     IOR.B W2, W3, W2
212:                           }
213:                           bmpbits >>= (x%8);
001884  FB8102     ZE W2, W2
001886  781F80     MOV W0, [W15++]
001888  780181     MOV W1, W3
00188A  090011     REPEAT #0x11
00188C  D80205     DIV.SW W4, W5
00188E  FD0181     EXCH W1, W3
001890  78004F     MOV [--W15], W0
001892  DE9103     ASR W2, W3, W2
214:                           bmpbits &= mask;
001894  614101     AND.B W2, W1, W2
215:                           switch(op){
001896  200038     MOV #0x3, W8
001898  200009     MOV #0x0, W9
00189A  560F88     SUB W12, W8, [W15]
00189C  5E8F89     SUBB W13, W9, [W15]
00189E  3E0024     BRA GTU, 0x18E8
0018A0  01600C     BRA W12
0018A2  370003     BRA 0x18AA
0018A4  37000B     BRA 0x18BC
0018A6  370011     BRA 0x18CA
0018A8  370019     BRA 0x18DC
001904  B82661     MUL.UU W4, #1, W12
216:                               case BMP_COPY:
217:                                   video_buffer[y][idx] &= ~mask;
0018B2  EAC081     COM.B W1, W1
0018B4  7D4468     MOV.B [W8+W10], W8
0018B6  60C088     AND.B W1, W8, W1
218:                                   video_buffer[y][idx] |= bmpbits;
0018AA  97BC8F     MOV [W15-16], W9
0018AC  44850A     ADD W9, W10, W10
0018AE  208008     MOV #0x800, W8
0018B0  44018A     ADD W8, W10, W3
0018B8  714981     IOR.B W2, W1, [W3]
219:                                   break;
0018BA  370016     BRA 0x18E8
220:                               case BMP_OR:
221:                                   video_buffer[y][idx] |= bmpbits;
0018BC  97BC8F     MOV [W15-16], W9
0018BE  44850A     ADD W9, W10, W10
0018C0  208003     MOV #0x800, W3
0018C2  41808A     ADD W3, W10, W1
0018C4  7D41E3     MOV.B [W3+W10], W3
0018C6  714883     IOR.B W2, W3, [W1]
222:                                   break;
0018C8  37000F     BRA 0x18E8
223:                               case BMP_AND:
224:                                   video_buffer[y][idx] &= (~mask) | bmpbits;
0018CA  97BC0F     MOV [W15-16], W8
0018CC  44050A     ADD W8, W10, W10
0018CE  208009     MOV #0x800, W9
0018D0  44840A     ADD W9, W10, W8
0018D2  EAC081     COM.B W1, W1
0018D4  714081     IOR.B W2, W1, W1
0018D6  7D4169     MOV.B [W9+W10], W2
0018D8  60CC02     AND.B W1, W2, [W8]
225:                                   break;
0018DA  370006     BRA 0x18E8
226:                               case BMP_XOR:
227:                                   video_buffer[y][idx] ^= bmpbits;
00182C  97B47F     MOV [W15-18], W8
00182E  B9417B     MUL.SU W8, #27, W2
001830  780482     MOV W2, W9
001832  9FBF89     MOV W9, [W15-16]
0018DC  97B88F     MOV [W15-16], W1
0018DE  40850A     ADD W1, W10, W10
0018E0  208003     MOV #0x800, W3
0018E2  41808A     ADD W3, W10, W1
0018E4  7D41E3     MOV.B [W3+W10], W3
0018E6  694883     XOR.B W2, W3, [W1]
228:                                   break;
229:                           }//switch
230:                           x += mwidth;
001820  420206     ADD W4, W6, W4
231:                           xbmp += mwidth;
001822  400006     ADD W0, W6, W0
001824  370007     BRA 0x1834
232:                           bitsleft -= mwidth;
0018E8  538386     SUB W7, W6, W7
233:                       }//while
234:                       ybmp+=ybmp_inc;
235:                       
236:                   }//for
237:               
238:               //    awidth=width/8;
239:               //    if (width%8) awidth++;
240:               //    first= left/8;
241:               //    lmask= 0xff>>(left%8);
242:               //    last= (left+width-1)/8;
243:               //    if (width<9){
244:               //        if (8-left%8>=width){
245:               //            rmask= lmask;
246:               //        }else{
247:               //            rmask= 0xff<<(8-left%8);
248:               //        }//if
249:               //    }
250:               //    else{
251:               //        rmask=0xff<<(8-(left+width)%8);
252:               //    }//if
253:               //    if (first==last){
254:               //        lmask &= rmask;
255:               //        for (i=top;i<top+height;i++){
256:               //            switch(r2op){
257:               //                case BMP_COPY:
258:               //                    video_buffer[i][first] &= ~lmask;
259:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
260:               //                    break;
261:               //                case BMP_OR:
262:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
263:               //                    break;
264:               //                case BMP_AND:
265:               //                    video_buffer[i][first] &= ~(lmask^((*(bmp+(i-top)))>>(left%8)));
266:               //                    break;
267:               //                case BMP_XOR:
268:               //                    video_buffer[i][first] ^= (*(bmp+(i-top)))>>(left%8);
269:               //                    break;
270:               //            }//switch
271:               //        }//for
272:               //    }else{
273:               //        for (i=top;i<top+height;i++){
274:               //            switch(r2op){
275:               //                case BMP_COPY:
276:               //                    video_buffer[i][first] &= ~lmask;
277:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
278:               //                    video_buffer[i][last] &= ~rmask;
279:               //                    if (width<8)
280:               //                        video_buffer[i][last]|=(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8);
281:               //                    else
282:               //                        video_buffer[i][last] |=(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8);
283:               //                    break;
284:               //                case BMP_OR:
285:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
286:               //                    if (width<8)
287:               //                        video_buffer[i][last]|=(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8);
288:               //                    else
289:               //                        video_buffer[i][last] |=(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8);
290:               //                    break;
291:               //                    break;
292:               //                case BMP_AND:
293:               //                    video_buffer[i][first] &= ~(lmask^((*(bmp+(i-top)))>>(left%8)));
294:               //              //      video_buffer[i][last] &= ~(rmask^(*(bmp+(i-top)*awidth+awidth-1)));
295:               //                    if (width<8)
296:               //                        video_buffer[i][last]&=~(rmask^(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8));
297:               //                    else
298:               //                        video_buffer[i][last] &=~(rmask^(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8));
299:               //                    break;
300:               //                case BMP_XOR:
301:               //                    video_buffer[i][first] ^= (*(bmp+(i-top)*awidth+awidth-1))>>(left%8);
302:               //                    if (width<8)
303:               //                        video_buffer[i][last] ^=(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8);
304:               //                    else
305:               //                        video_buffer[i][last] ^=(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8);
306:               //                    break;
307:               //            }//switch
308:               //        }//for
309:               //        if (last>first+1){
310:               //            for (i=top;i<top+height;i++){
311:               //                for (j=first+1;j<last;j++){
312:               //                    switch(r2op){
313:               //                        case BMP_COPY:
314:               //                            video_buffer[i][j]= *(bmp+(i-top)*awidth+j);
315:               //                            break;
316:               //                        case BMP_OR:
317:               //                            video_buffer[i][j] |= *(bmp+(i-top)*awidth+j);
318:               //                            break;
319:               //                        case BMP_AND:
320:               //                            video_buffer[i][j] &= *(bmp+(i-top)*awidth+j);
321:               //                            break;
322:               //                        case BMP_XOR:
323:               //                            video_buffer[i][j] ^= *(bmp+(i-top)*awidth+j);
324:               //                            break;
325:               //                    }//switch
326:               //                }//for
327:               //            }//for
328:               //        }//if
329:               //    }
330:               }//f()
001910  78074F     MOV [--W15], W14
001912  BE064F     MOV.D [--W15], W12
001914  BE054F     MOV.D [--W15], W10
001916  BE044F     MOV.D [--W15], W8
001918  B100EF     SUB #0xE, W15
00191A  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NTSC_FRAMES_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE+40)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAMES_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE+45)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8  // flag screen in retrace phase
60:                #define F_BLANK 16   // flag keep screen blank
61:                
62:                unsigned frames_per_second;
63:                static unsigned int frame_line_cntr=0; // count line in video frame
64:                volatile static unsigned long frame_cntr=0; // number of frame since reset
65:                volatile static unsigned int flags;
66:                
67:                
68:                char video_buffer[VPIXELS][BYTES_PER_LINE];
69:                int vsync, hsync, video_mode;
70:                
71:                void ntsc_init(){
72:                    VIDPR = NTSC_LINE_PERIOD;  // video timer PRx SFR
002360  203F85     MOV #0x3F8, W5
002362  880865     MOV W5, PR2
73:                    VSYNCR= NTSC_HPULSE;       // video OCxR  SFR
002364  2004B4     MOV #0x4B, W4
002366  880C14     MOV W4, OC1R
74:                    VSYNCRS=NTSC_LINE_PERIOD;  // video OCxRS SFR
002368  880C05     MOV W5, OC1RS
75:                    VDLYR=NTSC_VIDEO_DELAY;     // video delay OCxR SFR
00236A  200BE5     MOV #0xBE, W5
00236C  880CA5     MOV W5, OC4R
76:                    VDLYRS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;  // video delay OCxRS SFR
00236E  203E05     MOV #0x3E0, W5
002370  880C95     MOV W5, OC4RS
77:                    hsync=NTSC_HPULSE;
002372  88F674     MOV W4, hsync
78:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
002374  203AC4     MOV #0x3AC, W4
002376  88F664     MOV W4, vsync
79:                    video_mode=NTSC_MODE;
002378  EF3EC8     CLR video_mode
80:                    frames_per_second=NTSC_FRAMES_PER_SECOND;
00237A  2003C4     MOV #0x3C, W4
00237C  88F654     MOV W4, frames_per_second
81:                }//f()
00237E  060000     RETURN
82:                
83:                void pal_init(){
84:                    VIDPR = PAL_LINE_PERIOD;
002380  204005     MOV #0x400, W5
002382  880865     MOV W5, PR2
85:                    VSYNCR= PAL_HPULSE;
002384  2004B4     MOV #0x4B, W4
002386  880C14     MOV W4, OC1R
86:                    VSYNCRS=PAL_LINE_PERIOD;
002388  880C05     MOV W5, OC1RS
87:                    VDLYR=PAL_VIDEO_DELAY;
00238A  200C35     MOV #0xC3, W5
00238C  880CA5     MOV W5, OC4R
88:                    VDLYRS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
00238E  203E65     MOV #0x3E6, W5
002390  880C95     MOV W5, OC4RS
89:                    hsync=PAL_HPULSE;
002392  88F674     MOV W4, hsync
90:                    vsync=PAL_LINE_PERIOD-PAL_HPULSE;
002394  203B44     MOV #0x3B4, W4
002396  88F664     MOV W4, vsync
91:                    video_mode=PAL_MODE;
002398  200014     MOV #0x1, W4
00239A  88F644     MOV W4, video_mode
92:                    frames_per_second=PAL_FRAMES_PER_SECOND;
00239C  200324     MOV #0x32, W4
00239E  88F654     MOV W4, frames_per_second
93:                }//f()
0023A0  060000     RETURN
94:                
95:                void  video_init(){ // initialisation sorties NTSC
96:                    VIDTMR.TON=0; // désactivation TIMER2
0023A2  A9E111     BCLR 0x111, #7
97:                    if (P_VIDEO_MODE){
0023A4  801655     MOV PORTB, W5
0023A6  210004     MOV #0x1000, W4
0023A8  628204     AND W5, W4, W4
0023AA  320002     BRA Z, 0x23B0
98:                        ntsc_init();
0023AC  07FFD9     RCALL ntsc_init
0023AE  370001     BRA 0x23B2
99:                    }else{
100:                       pal_init();
0023B0  07FFE7     RCALL pal_init
101:                   }
102:                   //  video sync OC mode
103:                   VSYNCCON.OCM=5; // mode 5, timer 2
0023B2  800C24     MOV OC1CON, W4
0023B4  A00004     BSET W4, #0
0023B6  A11004     BCLR W4, #1
0023B8  A02004     BSET W4, #2
0023BA  880C24     MOV W4, OC1CON
104:                   //video delay change notification interrupt enable on that pin.
105:                   PIXIE=1;
0023BC  A8A062     BSET CNEN2, #5
106:                   // video sync interrupt enabling
107:                   VSYNCIF=0;
0023BE  A9E084     BCLR IFS0, #7
108:                   VSYNCIE=1;
0023C0  A8E094     BSET IEC0, #7
109:                   // SPIx configuration (pixels output)
110:                   PIXCON1.DISSCK=1;
0023C2  A88243     BSET 0x243, #4
111:                   PIXCON1.MSTEN=1;
0023C4  A8A242     BSET SPI1CON1, #5
112:                   PIXCON1.SPRE=5;
0023C6  801214     MOV SPI1CON1, W4
0023C8  A02004     BSET W4, #2
0023CA  A13004     BCLR W4, #3
0023CC  A04004     BSET W4, #4
0023CE  881214     MOV W4, SPI1CON1
113:                   PIXCON1.PPRE=3;
0023D0  200030     MOV #0x3, W0
0023D2  B72242     IOR SPI1CON1
114:                   PIXCON2.SPIBEN=1;  // enhanced buffer mode
0023D4  A80244     BSET SPI1CON2, #0
115:                   PIXSTAT.SPIEN=1;
0023D6  A8E241     BSET 0x241, #7
116:                   VIDTMR.TON=1;
0023D8  A8E111     BSET 0x111, #7
117:               }//horz_sync_init()
0023DA  060000     RETURN
118:               
119:               void  wait_n_frame(unsigned n){
120:               unsigned long f0;
121:                   f0=frame_cntr+n;
0023DC  80F6A4     MOV frame_cntr, W4
0023DE  80F6B5     MOV 0x1ED6, W5
0023E0  420000     ADD W4, W0, W0
0023E2  4A80E0     ADDC W5, #0x0, W1
122:                   while (frame_cntr<f0);
0023E4  80F6A4     MOV frame_cntr, W4
0023E6  80F6B5     MOV 0x1ED6, W5
0023E8  500F84     SUB W0, W4, [W15]
0023EA  588F85     SUBB W1, W5, [W15]
0023EC  3EFFFB     BRA GTU, 0x23E4
123:               }//f()
0023EE  060000     RETURN
124:               
125:               void  blank_out(unsigned state){
126:                   if (!state){
0023F0  500FE0     SUB W0, #0x0, [W15]
0023F2  3A0002     BRA NZ, 0x23F8
127:                       flags &= ~F_BLANK;
0023F4  A99ED2     BCLR flags, #4
0023F6  370001     BRA 0x23FA
128:                   }else{
129:                       flags |=F_BLANK;
0023F8  A89ED2     BSET flags, #4
130:                   }
131:               }//f()
0023FA  060000     RETURN
132:               
133:               
134:               // video sync signal generation
135:               void __attribute__((interrupt,no_auto_psv,shadow)) _VSYNC_ISR(void){
0023FC  FEA000     PUSH.S
0023FE  BE9F84     MOV.D W4, [W15++]
136:                   frame_line_cntr++;
002400  80F684     MOV frame_line_cntr, W4
002402  E80204     INC W4, W4
002404  88F684     MOV W4, frame_line_cntr
137:                   switch (frame_line_cntr){
002406  200375     MOV #0x37, W5
002408  520F85     SUB W4, W5, [W15]
00240A  320030     BRA Z, 0x246C
00240C  3E0007     BRA GTU, 0x241C
00240E  520FE4     SUB W4, #0x4, [W15]
002410  320019     BRA Z, 0x2444
002412  520FFE     SUB W4, #0x1E, [W15]
002414  32001C     BRA Z, 0x244E
002416  520FE1     SUB W4, #0x1, [W15]
002418  3A004D     BRA NZ, 0x24B4
00241A  37000F     BRA 0x243A
00241C  201075     MOV #0x107, W5
00241E  520F85     SUB W4, W5, [W15]
002420  320034     BRA Z, 0x248A
002422  3E0004     BRA GTU, 0x242C
002424  5282F1     SUB W5, #0x11, W5
002426  520F85     SUB W4, W5, [W15]
002428  3A0045     BRA NZ, 0x24B4
00242A  37001A     BRA 0x2460
00242C  2010F5     MOV #0x10F, W5
00242E  520F85     SUB W4, W5, [W15]
002430  320026     BRA Z, 0x247E
002432  201395     MOV #0x139, W5
002434  520F85     SUB W4, W5, [W15]
002436  3A003E     BRA NZ, 0x24B4
002438  370033     BRA 0x24A0
138:                       case 1:
139:                           VSYNCR=vsync;
00243A  F81ECC     PUSH vsync
00243C  F90182     POP OC1R
140:                           VDLYCONR &=0xF8;
00243E  200F80     MOV #0xF8, W0
002440  B62196     AND OC4CON
141:                           break;
002442  370038     BRA 0x24B4
142:                       case 4:
143:                           VDLYCONR |=5;
002444  200050     MOV #0x5, W0
002446  B72196     IOR OC4CON
144:                           VSYNCR=hsync;
002448  F81ECE     PUSH hsync
00244A  F90182     POP OC1R
145:                           break;
00244C  370033     BRA 0x24B4
146:                       case NTSC_FIRST_VISIBLE:
147:                           if (video_mode==NTSC_MODE && !(flags&F_BLANK)){
00244E  80F644     MOV video_mode, W4
002450  520FE0     SUB W4, #0x0, [W15]
002452  3A0030     BRA NZ, 0x24B4
002454  AB9ED2     BTST flags, #4
002456  3A002E     BRA NZ, 0x24B4
148:                               VDLYIF=0;
002458  A96086     BCLR IFS1, #3
149:                               VDLYIE=1;
00245A  A86096     BSET IEC1, #3
150:                               flags &= ~F_RETRACE;
00245C  A97ED2     BCLR flags, #3
00245E  37002A     BRA 0x24B4
151:                           }
152:                           break;
153:                       case NTSC_LAST_VISIBLE:
154:                           if (video_mode==NTSC_MODE){
002460  80F644     MOV video_mode, W4
002462  520FE0     SUB W4, #0x0, [W15]
002464  3A0027     BRA NZ, 0x24B4
155:                               VDLYIE=0;
002466  A96096     BCLR IEC1, #3
156:                               flags |= F_RETRACE;
002468  A87ED2     BSET flags, #3
00246A  370024     BRA 0x24B4
157:                           }
158:                           break;
159:                       case PAL_FIRST_VISIBLE:
160:                           if (video_mode==PAL_MODE && !(flags&F_BLANK)){
00246C  80F644     MOV video_mode, W4
00246E  520FE1     SUB W4, #0x1, [W15]
002470  3A0021     BRA NZ, 0x24B4
002472  AB9ED2     BTST flags, #4
002474  3A001F     BRA NZ, 0x24B4
161:                               VDLYIF=0;
002476  A96086     BCLR IFS1, #3
162:                               VDLYIE=1;
002478  A86096     BSET IEC1, #3
163:                               flags &= ~F_RETRACE;
00247A  A97ED2     BCLR flags, #3
00247C  37001B     BRA 0x24B4
164:                           }
165:                           break;
166:                       case PAL_LAST_VISIBLE:
167:                           if (video_mode==PAL_MODE){
00247E  80F644     MOV video_mode, W4
002480  520FE1     SUB W4, #0x1, [W15]
002482  3A0018     BRA NZ, 0x24B4
168:                               VDLYIE=0;
002484  A96096     BCLR IEC1, #3
169:                               flags |= F_RETRACE;
002486  A87ED2     BSET flags, #3
002488  370015     BRA 0x24B4
170:                           }
171:                           break;
172:                       case NTSC_LINES_PER_FRAME+1:
173:                           if (video_mode==NTSC_MODE){
00248A  80F644     MOV video_mode, W4
00248C  520FE0     SUB W4, #0x0, [W15]
00248E  3A0012     BRA NZ, 0x24B4
174:                               frame_line_cntr=0;
002490  EF3ED0     CLR frame_line_cntr
175:                               frame_cntr++;
002492  80F6A4     MOV frame_cntr, W4
002494  80F6B5     MOV 0x1ED6, W5
002496  420261     ADD W4, #0x1, W4
002498  4A82E0     ADDC W5, #0x0, W5
00249A  88F6A4     MOV W4, frame_cntr
00249C  88F6B5     MOV W5, 0x1ED6
00249E  37000A     BRA 0x24B4
176:                           }
177:                           break;
178:                       case PAL_LINES_PER_FRAME+1:
179:                           if (video_mode==PAL_MODE){
0024A0  80F644     MOV video_mode, W4
0024A2  520FE1     SUB W4, #0x1, [W15]
0024A4  3A0007     BRA NZ, 0x24B4
180:                               frame_line_cntr=0;
0024A6  EF3ED0     CLR frame_line_cntr
181:                               frame_cntr++;
0024A8  80F6A4     MOV frame_cntr, W4
0024AA  80F6B5     MOV 0x1ED6, W5
0024AC  420261     ADD W4, #0x1, W4
0024AE  4A82E0     ADDC W5, #0x0, W5
0024B0  88F6A4     MOV W4, frame_cntr
0024B2  88F6B5     MOV W5, 0x1ED6
182:                           }
183:                           break;
184:                   }//switch
185:                   VSYNCIF=0;
0024B4  A9E084     BCLR IFS0, #7
186:               }// _VSYNC_ISR()
0024B6  BE024F     MOV.D [--W15], W4
0024B8  FE8000     POP.S
0024BA  064000     RETFIE
187:               
188:               void __attribute__((interrupt,no_auto_psv,shadow)) _VIDEO_OUT_ISR(void){
0024BC  FEA000     PUSH.S
0024BE  BE9F84     MOV.D W4, [W15++]
0024C0  BE9F86     MOV.D W6, [W15++]
0024D6  B9337B     MUL.SU W6, #27, W6
0024D8  207FF4     MOV #0x7FF, W4
0024DA  430304     ADD W6, W4, W6
189:                   int y,x;
190:                   if (PIXDLY_INP){
0024C2  AB22CB     BTST 0x2CB, #1
0024C4  320016     BRA Z, 0x24F2
191:                       if (video_mode==NTSC_MODE){
0024C6  80F644     MOV video_mode, W4
0024C8  520FE0     SUB W4, #0x0, [W15]
0024CA  3A0003     BRA NZ, 0x24D2
192:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE);
0024CC  80F686     MOV frame_line_cntr, W6
0024CE  53037E     SUB W6, #0x1E, W6
0024D0  370002     BRA 0x24D6
193:                       }else{
194:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE);
0024D2  80F686     MOV frame_line_cntr, W6
0024D4  B10376     SUB #0x37, W6
195:                       }
196:                       for (x=0;x<BYTES_PER_LINE;x++){
0024DC  EB0280     CLR W5
0024E6  E80285     INC W5, W5
0024E8  528FFB     SUB W5, #0x1B, [W15]
0024EA  3AFFF9     BRA NZ, 0x24DE
197:                           while (PIXSTAT.SPITBF);
0024DE  AB2240     BTST SPI1STAT, #1
0024E0  3AFFFE     BRA NZ, 0x24DE
198:                           PIXBUF=video_buffer[y][x];
0024E2  FB0256     SE [++W6], W4
0024E4  881244     MOV W4, SPI1BUF
199:                       }//for
200:                       while (PIXSTAT.SPITBF);
0024EC  AB2240     BTST SPI1STAT, #1
0024EE  3AFFFE     BRA NZ, 0x24EC
201:                       PIXBUF=0;
0024F0  EF2248     CLR SPI1BUF
202:                   }
203:                   VDLYIF=0;
0024F2  A96086     BCLR IFS1, #3
204:               }// _VIDEO_OUT_ISR
0024F4  BE034F     MOV.D [--W15], W6
0024F6  BE024F     MOV.D [--W15], W4
0024F8  FE8000     POP.S
0024FA  064000     RETFIE
205:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  216x216 pixels
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include "PICvision.h"
34:                #include "PICvision_banner.h"
35:                
36:                void splash_screen(){
002668  4787E6     ADD W15, #0x6, W15
00266A  BE9F88     MOV.D W8, [W15++]
00266C  BE9F8A     MOV.D W10, [W15++]
00266E  BE9F8C     MOV.D W12, [W15++]
002670  781F8E     MOV W14, [W15++]
002676  285CA8     MOV #0x85CA, W8
002678  207FEE     MOV #0x7FE, W14
00267C  78000A     MOV W10, W0
00267E  2004F4     MOV #0x4F, W4
002680  52020A     SUB W4, W10, W4
002690  2004F7     MOV #0x4F, W7
002692  538103     SUB W7, W3, W2
002694  208001     MOV #0x800, W1
002696  370008     BRA 0x26A8
0026A8  B93A78     MUL.SU W7, #24, W4
0026AA  E90204     DEC W4, W4
0026AC  420208     ADD W4, W8, W4
0026AE  B9067B     MUL.SU W0, #27, W12
0026B0  9FB7FC     MOV W12, [W15-18]
0026B2  9FBF8D     MOV W13, [W15-16]
0026B4  E8028C     INC W12, W5
0026B6  428281     ADD W5, W1, W5
0026B8  37FFEF     BRA 0x2698
0026C2  E90303     DEC W3, W6
0026C4  B9337B     MUL.SU W6, #27, W6
0026C6  208014     MOV #0x801, W4
0026C8  430204     ADD W6, W4, W4
0026CA  B91B7B     MUL.SU W3, #27, W6
0026CC  470286     ADD W14, W6, W5
37:                    int i,k,first,last,left;
38:                    left=(HPIXELS-PIX_WIDTH)/16+1;
39:                    last=0;
002672  EB0500     CLR W10
40:                    while (last<(VPIXELS-PIX_HEIGHT)/2+PIX_HEIGHT){
0026DA  200944     MOV #0x94, W4
0026DC  550F84     SUB W10, W4, [W15]
0026DE  3AFFCE     BRA NZ, 0x267C
41:                        first=max(0,PIX_HEIGHT-last-1);
002682  3B0001     BRA NN, 0x2686
002684  EB0200     CLR W4
42:                        for (i=0;i<PIX_HEIGHT-first;i++){
002674  28D49B     MOV #0x8D49, W11
002686  200503     MOV #0x50, W3
002688  518184     SUB W3, W4, W3
00268A  A94042     BCLR SR, #2
00268C  340016     BRA LE, 0x26BA
00268E  78030B     MOV W11, W6
0026A4  538F82     SUB W7, W2, [W15]
0026A6  32000A     BRA Z, 0x26BC
0026BA  EB0180     CLR W3
43:                            for (k=0;k<ARRAY_WIDTH;k++){
00269A  520F86     SUB W4, W6, [W15]
00269C  3AFFFD     BRA NZ, 0x2698
00269E  E90387     DEC W7, W7
0026A0  E90000     DEC W0, W0
0026A2  530378     SUB W6, #0x18, W6
44:                                video_buffer[last-i][left+k]=PICVISION_BANNER[PIX_HEIGHT-1-i][k];
002698  786AD4     MOV.B [++W4], [++W5]
45:                            }//for
46:                        }//for
47:                        if (last-i>0){
0026BC  550183     SUB W10, W3, W3
0026BE  A94042     BCLR SR, #2
0026C0  340009     BRA LE, 0x26D4
48:                            for (k=0;k<ARRAY_WIDTH;k++){
0026D0  520F85     SUB W4, W5, [W15]
0026D2  3AFFFD     BRA NZ, 0x26CE
49:                                video_buffer[last-i-1][left+k]=0;
00267A  EB4480     CLR.B W9
0026CE  786A09     MOV.B W9, [++W4]
50:                            }//for
51:                        }//if
52:                        wait_n_frame(1);
0026D4  200010     MOV #0x1, W0
0026D6  07FE82     RCALL wait_n_frame
53:                        last++;
0026D8  E8050A     INC W10, W10
54:                    }//while
55:                    set_curpos(left,last/8+2);
0026E0  200141     MOV #0x14, W1
0026E2  200020     MOV #0x2, W0
0026E4  07FCF7     RCALL set_curpos
56:                    print("Copyright 2014, Jacques Deschenes");
0026E6  2928A0     MOV #0x928A, W0
0026E8  07FC78     RCALL print
57:                    wait_n_frame(180);
0026EA  200B40     MOV #0xB4, W0
0026EC  07FE77     RCALL wait_n_frame
58:                }//f()
0026EE  78074F     MOV [--W15], W14
0026F0  BE064F     MOV.D [--W15], W12
0026F2  BE054F     MOV.D [--W15], W10
0026F4  BE044F     MOV.D [--W15], W8
0026F6  B1006F     SUB #0x6, W15
0026F8  060000     RETURN
59:                
60:                
61:                void PICvision_init(void) {
62:                    HardwareConfig();
0026FA  070007     RCALL HardwareConfig
63:                    timers_init(TICK_FREQ);
0026FC  200640     MOV #0x64, W0
0026FE  07FD43     RCALL timers_init
64:                    video_init();
002700  07FE50     RCALL video_init
65:                    sound_init(1000/TICK_FREQ);
002702  2000A0     MOV #0xA, W0
002704  07FF07     RCALL sound_init
66:                    splash_screen();
002706  07FFB0     RCALL splash_screen
67:                }//f()
002708  060000     RETURN
68:                
69:                
