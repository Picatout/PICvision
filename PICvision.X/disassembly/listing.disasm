Disassembly Listing for PICvision
Generated From:
/home/jacques/MPLABXProjects/PICvision/PICvision.X/dist/default/production/PICvision.X.production.elf
2014-03-24 17:01:43

---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/text_console/text_console.c  --------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   text_console.h
21:                 * Author: jacques Deschênes
22:                 * Description: manage text writing in video_buffer
23:                 * Created on 28 février 2014, 10:04
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <string.h>
28:                #include "text_console.h"
29:                
30:                //static text_coord_t cursor_pos;
31:                
32:                //#define X_OFS  ((HPIXELS-CHAR_PER_LINE*CHAR_WIDTH)/2)  // x offset to cursor from screen edge
33:                //#define Y_OFS  ((VPIXELS-LINE_PER_SCREEN*CHAR_HEIGHT)/2) // y offset to cursor from screen edge
34:                
35:                // boolean flags
36:                #define CUR_SHOW 1  // cursor active
37:                #define CUR_VIS  2  // cursor state visible
38:                #define INV_VID  4  // invert video
39:                
40:                
41:                static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
42:                static unsigned char tab_width=TAB_WIDTH;
43:                static cursor_t cur_shape=CR_UNDER;
44:                static unsigned short flags=0;
45:                
46:                
47:                
48:                void scroll_up(void){
49:                    char *src, *dst;
50:                    dst = (char*)video_buffer;
51:                    src = (char*)video_buffer + CHAR_HEIGHT*BYTES_PER_LINE;
52:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
002052  215F02     MOV #0x15F0, W2
002054  208D81     MOV #0x8D8, W1
002056  208000     MOV #0x800, W0
002058  07F375     RCALL 0x744
53:                    dst= (char*)video_buffer+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*BYTES_PER_LINE;
54:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
00205A  21DF04     MOV #0x1DF0, W4
00205C  0900D7     REPEAT #0xD7
00205E  EB5A00     CLR.B [W4++]
55:                }//scroll_up();
002060  060000     RETURN
56:                
57:                void scroll_down(void){
58:                    char *src, *dst;
59:                    src = (char*)video_buffer;
60:                    dst = (char*)video_buffer+CHAR_HEIGHT*BYTES_PER_LINE;
61:                    memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*BYTES_PER_LINE);
002062  215F02     MOV #0x15F0, W2
002064  208001     MOV #0x800, W1
002066  200D80     MOV #0xD8, W0
002068  400001     ADD W0, W1, W0
00206A  07F36C     RCALL 0x744
62:                    dst=(char*)video_buffer;
63:                    memset(dst,0,HPIXELS/8*CHAR_HEIGHT);
00206C  208004     MOV #0x800, W4
00206E  0900D7     REPEAT #0xD7
002070  EB5A00     CLR.B [W4++]
64:                }//scroll_down()
002072  060000     RETURN
65:                
66:                
67:                void cursor_right(void){
68:                    cx += CHAR_WIDTH;
002074  80FF84     MOV cx, W4
002076  420266     ADD W4, #0x6, W4
002078  88FF84     MOV W4, cx
69:                    if (cx>(CHAR_PER_LINE*CHAR_WIDTH)){
00207A  200D25     MOV #0xD2, W5
00207C  520F85     SUB W4, W5, [W15]
00207E  36000A     BRA LEU, 0x2094
70:                        cx = 0;
002080  EF3FF0     CLR cx
71:                        cy += CHAR_HEIGHT;
002082  80FF94     MOV cy, W4
002084  420268     ADD W4, #0x8, W4
002086  88FF94     MOV W4, cy
72:                        if (cy>(LINE_PER_SCREEN*CHAR_HEIGHT)){
002088  4282E6     ADD W5, #0x6, W5
00208A  520F85     SUB W4, W5, [W15]
00208C  360003     BRA LEU, 0x2094
73:                            scroll_up();
00208E  07FFE1     RCALL scroll_up
74:                            cy -= CHAR_HEIGHT;
002090  2FFF80     MOV #0xFFF8, W0
002092  B43FF2     ADD cy
75:                        }
76:                    }
77:                } // cursor_right()
002094  060000     RETURN
78:                
79:                void cursor_left(void){
80:                    if (cx>=CHAR_WIDTH){
002096  80FF84     MOV cx, W4
002098  520FE5     SUB W4, #0x5, [W15]
00209A  360003     BRA LEU, 0x20A2
81:                        cx -= CHAR_WIDTH;
00209C  520266     SUB W4, #0x6, W4
00209E  88FF84     MOV W4, cx
0020A0  370009     BRA 0x20B4
82:                    }else{
83:                        cx = CHAR_WIDTH*(CHAR_PER_LINE-1);
0020A2  200CC4     MOV #0xCC, W4
0020A4  88FF84     MOV W4, cx
84:                        if (cy>=CHAR_HEIGHT){
0020A6  80FF94     MOV cy, W4
0020A8  520FE7     SUB W4, #0x7, [W15]
0020AA  360003     BRA LEU, 0x20B2
85:                            cy -= CHAR_HEIGHT;
0020AC  520268     SUB W4, #0x8, W4
0020AE  88FF94     MOV W4, cy
0020B0  370001     BRA 0x20B4
86:                        }else{
87:                            scroll_down();
0020B2  07FFD7     RCALL scroll_down
88:                        }
89:                    }
90:                }// cursor_left()
0020B4  060000     RETURN
91:                
92:                void cursor_up(void){
93:                    if (cy>=CHAR_HEIGHT){
0020B6  80FF94     MOV cy, W4
0020B8  520FE7     SUB W4, #0x7, [W15]
0020BA  360003     BRA LEU, 0x20C2
94:                        cy -= CHAR_HEIGHT;
0020BC  520268     SUB W4, #0x8, W4
0020BE  88FF94     MOV W4, cy
0020C0  370001     BRA 0x20C4
95:                    }else{
96:                        scroll_down();
0020C2  07FFCF     RCALL scroll_down
97:                    }
98:                }// cursor_up()
0020C4  060000     RETURN
99:                
100:               void cursor_down(void){
101:                   if (cy<=(CHAR_HEIGHT*(LINE_PER_SCREEN-2))){
0020C6  80FF94     MOV cy, W4
0020C8  200C85     MOV #0xC8, W5
0020CA  520F85     SUB W4, W5, [W15]
0020CC  3E0003     BRA GTU, 0x20D4
102:                       cy += CHAR_HEIGHT;
0020CE  420268     ADD W4, #0x8, W4
0020D0  88FF94     MOV W4, cy
0020D2  370001     BRA 0x20D6
103:                   }else{
104:                       scroll_up();
0020D4  07FFBE     RCALL scroll_up
105:                   }
106:               }//cursor_down()
0020D6  060000     RETURN
107:               
108:               void crlf(void){
109:                   cx=0;
0020D8  EF3FF0     CLR cx
110:                   if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
0020DA  80FF94     MOV cy, W4
0020DC  200D05     MOV #0xD0, W5
0020DE  520F85     SUB W4, W5, [W15]
0020E0  3A0002     BRA NZ, 0x20E6
111:                       scroll_up();
0020E2  07FFB7     RCALL scroll_up
0020E4  370002     BRA 0x20EA
112:                   }else{
113:                       cy += CHAR_HEIGHT;
0020E6  420268     ADD W4, #0x8, W4
0020E8  88FF94     MOV W4, cy
114:                   }
115:               }//crlf()
0020EA  060000     RETURN
116:               
117:               void put_char(unsigned char c){
0020EC  4787E6     ADD W15, #0x6, W15
0020EE  BE9F88     MOV.D W8, [W15++]
0020F0  BE9F8A     MOV.D W10, [W15++]
0020F2  BE9F8C     MOV.D W12, [W15++]
0020F4  781F8E     MOV W14, [W15++]
00216C  E80389     INC W9, W7
00216E  B94A7B     MUL.SU W9, #27, W4
002170  780284     MOV W4, W5
002172  42820D     ADD W5, W13, W4
002174  208000     MOV #0x800, W0
002176  420200     ADD W4, W0, W4
00217A  DD3743     SL W6, #3, W14
00217C  28F6C6     MOV #0x8F6C, W6
00217E  470306     ADD W14, W6, W6
002180  E8068D     INC W13, W13
002182  42828D     ADD W5, W13, W5
002184  428280     ADD W5, W0, W5
002186  448069     ADD W9, #0x9, W0
118:                   register int i,l,r,b,x,y;
119:                   x=cx;
0020F6  80FF83     MOV cx, W3
120:                   y=cy;
0020F8  80FF99     MOV cy, W9
121:                   switch (c){
0020FA  504FE9     SUB.B W0, #0x9, [W15]
0020FC  320007     BRA Z, 0x210C
0020FE  504FED     SUB.B W0, #0xD, [W15]
002100  320003     BRA Z, 0x2108
002102  504FE8     SUB.B W0, #0x8, [W15]
002104  3A001B     BRA NZ, 0x213C
002106  370018     BRA 0x2138
122:                       case CR:
123:                           crlf();
002108  07FFE7     RCALL crlf
124:                           break;
00210A  37006E     BRA 0x21E8
125:                       case TAB:
126:                           cx += (cx%tab_width);
00210C  21FFE4     MOV #0x1FFE, W4
00210E  784214     MOV.B [W4], W4
002110  FB8204     ZE W4, W4
002112  BE9F80     MOV.D W0, [W15++]
002114  090011     REPEAT #0x11
002116  D88184     DIV.UW W3, W4
002118  780201     MOV W1, W4
00211A  BE004F     MOV.D [--W15], W0
00211C  420183     ADD W4, W3, W3
00211E  88FF83     MOV W3, cx
127:                           if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
002120  200D14     MOV #0xD1, W4
002122  518F84     SUB W3, W4, [W15]
002124  360061     BRA LEU, 0x21E8
128:                               cx = 0;
002126  EF3FF0     CLR cx
129:                               if (cy==(LINE_PER_SCREEN-1)*CHAR_HEIGHT){
002128  E90204     DEC W4, W4
00212A  548F84     SUB W9, W4, [W15]
00212C  3A0002     BRA NZ, 0x2132
130:                                   scroll_up();
00212E  07FF91     RCALL scroll_up
002130  37005B     BRA 0x21E8
131:                               }else{
132:                                   cy += CHAR_HEIGHT;
002132  4484E8     ADD W9, #0x8, W9
002134  88FF99     MOV W9, cy
002136  370058     BRA 0x21E8
133:                               }
134:                           }
135:                           break;
136:                       case '\b':
137:                           cursor_left();
002138  07FFAE     RCALL cursor_left
138:                           break;
00213A  370056     BRA 0x21E8
139:                       default:
140:                           if ((c<32) || (c>=(FONT_SIZE+32))) break;
00213C  B3CE06     MOV #0xE0, W6
00213E  404306     ADD.B W0, W6, W6
002140  B3C6D4     MOV #0x6D, W4
002142  534F84     SUB.B W6, W4, [W15]
002144  3E0051     BRA GTU, 0x21E8
141:                           c -=32;
142:                           b=x>>3; // character position in video_buffer
002146  DE9EC3     ASR W3, #3, W13
143:                           r=0;
144:                           l=(8-CHAR_WIDTH)-(x&7); // shift inside this byte
002148  6181E7     AND W3, #0x7, W3
00214A  1181E2     SUBR W3, #0x2, W3
145:                           if (l<0){
146:                               r=-l;
00214C  DE9A4F     ASR W3, #15, W4
00214E  EA0083     NEG W3, W1
002150  608084     AND W1, W4, W1
147:                           }
148:                           for (i=0;i<8;i++){
0021E2  538F80     SUB W7, W0, [W15]
0021E4  3AFFD1     BRA NZ, 0x2188
149:                               if (r){
002188  508FE0     SUB W1, #0x0, [W15]
00218A  320018     BRA Z, 0x21BC
150:                                   if (flags & INV_VID){
002152  80FF62     MOV flags, W2
002154  610164     AND W2, #0x4, W2
00218C  510FE0     SUB W2, #0x0, [W15]
00218E  32000B     BRA Z, 0x21A6
151:                                       video_buffer[y][b] |= (0x3f>>r);
002156  2003FA     MOV #0x3F, W10
002158  DED601     ASR W10, W1, W12
002198  764694     IOR.B W12, [W4], W13
152:                                       video_buffer[y][b] &=~(font6x8[(int)c][i]>>r);
002190  784696     MOV.B [W6], W13
002192  FB848D     ZE W13, W9
002194  DECF01     ASR W9, W1, W14
002196  EAC70E     COM.B W14, W14
00219A  674A0D     AND.B W14, W13, [W4]
153:                                       video_buffer[y][b+1] |= (0x3f<<(8-r));
00215A  108468     SUBR W1, #0x8, W8
00215C  DD5588     SL W10, W8, W11
0021A0  75C695     IOR.B W11, [W5], W13
154:                                       video_buffer[y][b+1] &= ~(font6x8[(int)c][i]<<(8-r));
00219C  DD4C88     SL W9, W8, W9
00219E  EAC489     COM.B W9, W9
0021A2  64CA8D     AND.B W9, W13, [W5]
0021A4  37001A     BRA 0x21DA
155:                                   }else{
156:                                       video_buffer[y][b] &= ~(0x3f>>r);
00215E  EAC20C     COM.B W12, W4
002160  9FF784     MOV.B W4, [W15-16]
0021AA  97F68F     MOV.B [W15-16], W13
0021AC  66C714     AND.B W13, [W4], W14
157:                                       video_buffer[y][b] |= font6x8[(int)c][i]>>r;
0021A6  784716     MOV.B [W6], W14
0021A8  FB848E     ZE W14, W9
0021AE  DECE81     ASR W9, W1, W13
0021B0  774A0D     IOR.B W14, W13, [W4]
158:                                       video_buffer[y][b+1] &= ~(0x3f<<(8-r));
002162  EAC70B     COM.B W11, W14
002164  9FEFFE     MOV.B W14, [W15-17]
0021B2  97EF7F     MOV.B [W15-17], W14
0021B4  674695     AND.B W14, [W5], W13
159:                                       video_buffer[y][b+1] |= font6x8[(int)c][i]<<(8-r);
0021B6  DD4C88     SL W9, W8, W9
0021B8  76CA89     IOR.B W13, W9, [W5]
0021BA  37000F     BRA 0x21DA
160:                                   }
161:                                   y++;
162:                               } else{
163:                                   if (flags & INV_VID){
0021BC  510FE0     SUB W2, #0x0, [W15]
0021BE  320007     BRA Z, 0x21CE
164:                                       video_buffer[y][b] |= (0x3f<<l);
002166  DD5503     SL W10, W3, W10
0021C8  754494     IOR.B W10, [W4], W9
165:                                       video_buffer[y++][b] &=~(font6x8[(int)c][i]<<l);
002178  FB8306     ZE W6, W6
0021C0  784496     MOV.B [W6], W9
0021C2  FB8689     ZE W9, W13
0021C4  DD6E83     SL W13, W3, W13
0021C6  EAC68D     COM.B W13, W13
0021CA  66CA09     AND.B W13, W9, [W4]
0021CC  370006     BRA 0x21DA
166:                                   }else{
167:                                       video_buffer[y][b] &= ~(0x3f<<l);
002168  EAC20A     COM.B W10, W4
00216A  9FEFE4     MOV.B W4, [W15-18]
0021CE  97EF6F     MOV.B [W15-18], W14
0021D0  674694     AND.B W14, [W4], W13
168:                                       video_buffer[y++][b] |= font6x8[(int)c][i]<<l;
0021D2  784716     MOV.B [W6], W14
0021D4  FB848E     ZE W14, W9
0021D6  DD4C83     SL W9, W3, W9
0021D8  76CA09     IOR.B W13, W9, [W4]
0021DA  E80387     INC W7, W7
0021DC  42027B     ADD W4, #0x1B, W4
0021DE  E80306     INC W6, W6
0021E0  4282FB     ADD W5, #0x1B, W5
169:                                   }
170:                               }
171:                           }
172:                           cursor_right();
0021E6  07FF46     RCALL cursor_right
173:                   }//switch(c)
174:               }//put_char()
0021E8  78074F     MOV [--W15], W14
0021EA  BE064F     MOV.D [--W15], W12
0021EC  BE054F     MOV.D [--W15], W10
0021EE  BE044F     MOV.D [--W15], W8
0021F0  B1006F     SUB #0x6, W15
0021F2  060000     RETURN
175:               
176:               void clear_screen(){
177:                   memset(video_buffer,0,HPIXELS/8*VPIXELS);
0021F4  208004     MOV #0x800, W4
0021F6  0916C7     REPEAT #0x16C7
0021F8  EB5A00     CLR.B [W4++]
178:                   cx=0;
0021FA  EB0200     CLR W4
0021FC  88FF84     MOV W4, cx
179:                   cy=0;
0021FE  88FF94     MOV W4, cy
180:               } // clear_screen()
002200  060000     RETURN
181:               
182:               void print(const char *text){
002202  781F88     MOV W8, [W15++]
002204  780400     MOV W0, W8
183:                   while (*text){
002206  784018     MOV.B [W8], W0
002208  504FE0     SUB.B W0, #0x0, [W15]
00220A  320004     BRA Z, 0x2214
00220E  784058     MOV.B [++W8], W0
002210  504FE0     SUB.B W0, #0x0, [W15]
002212  3AFFFC     BRA NZ, 0x220C
184:                       put_char(*text++);
00220C  07FF6F     RCALL put_char
185:                   }
186:               }// print()
002214  78044F     MOV [--W15], W8
002216  060000     RETURN
187:               
188:               void print_hex(unsigned int hex, unsigned char width){
002218  FA000C     LNK #0xC
189:                   char c[12], *d;
190:                   int i;
191:                   c[11]=0;
00221A  EB4200     CLR.B W4
00221C  9FFFF4     MOV.B W4, [W15-1]
192:                   d= &c[10];
002220  E9820F     DEC2 W15, W4
193:                   for(i=width;i>=0||hex;i--){
00221E  FB8301     ZE W1, W6
002222  37000C     BRA 0x223C
00223A  E90306     DEC W6, W6
00223C  530FE0     SUB W6, #0x0, [W15]
00223E  3DFFF2     BRA GE, 0x2224
002240  500FE0     SUB W0, #0x0, [W15]
002242  3AFFF0     BRA NZ, 0x2224
194:                       *d=(hex%16);
002224  6042EF     AND.B W0, #0xF, W5
002226  784A05     MOV.B W5, [W4]
195:                       if (*d<10)
002228  52CFE9     SUB.B W5, #0x9, [W15]
00222A  3C0003     BRA GT, 0x2232
196:                           *d += '0';
00222C  B3C307     MOV #0x30, W7
00222E  42CA07     ADD.B W5, W7, [W4]
002230  370002     BRA 0x2236
197:                       else
198:                           *d += 'A'-10;
002232  B3C377     MOV #0x37, W7
002234  42CA07     ADD.B W5, W7, [W4]
199:                       hex /=16;
002236  DE0044     LSR W0, #4, W0
200:                       d--;
002238  E90204     DEC W4, W4
201:                   }
202:                   print(++d);
002244  E80004     INC W4, W0
002246  07FFDD     RCALL print
203:               } // print_hex()
002248  FA8000     ULNK
00224A  060000     RETURN
204:               
205:               void print_int(int number, unsigned short width){ // imprime entier,width inclus le signe
00224C  FA000E     LNK #0xE
002292  538005     SUB W7, W5, W0
002294  780207     MOV W7, W4
206:                   int sign=0, i;
002258  EB0100     CLR W2
207:                   char str[14], *d;
208:                   str[13]=0;
00224E  EB4200     CLR.B W4
002250  9FFFF4     MOV.B W4, [W15-1]
002252  508FED     SUB W1, #0xD, [W15]
002254  360001     BRA LEU, 0x2258
002256  2000D1     MOV #0xD, W1
209:                   d=&str[12];
002268  E9820F     DEC2 W15, W4
002282  E9838F     DEC2 W15, W7
210:                   if (width>13){width=13;}
211:                   if (number<0){
00225A  500F82     SUB W0, W2, [W15]
00225C  3D0002     BRA GE, 0x2262
212:                       sign=1;
002260  200012     MOV #0x1, W2
213:                       number = -number;
00225E  EA0000     NEG W0, W0
214:                   }
215:                   //for (i=--width;i>=0||number;i--){
216:                   i=width;
002262  780281     MOV W1, W5
217:                   while (number>0){
002264  500FE0     SUB W0, #0x0, [W15]
002266  34000D     BRA LE, 0x2282
00227C  500FE0     SUB W0, #0x0, [W15]
00227E  3CFFF6     BRA GT, 0x226C
002280  370001     BRA 0x2284
218:                      *d--=(number%10)+'0';
00226A  2000A6     MOV #0xA, W6
00226C  780381     MOV W1, W7
00226E  090011     REPEAT #0x11
002270  D80006     DIV.SW W0, W6
002272  FD0381     EXCH W1, W7
002274  B3C303     MOV #0x30, W3
002276  43D203     ADD.B W7, W3, [W4--]
002278  780384     MOV W4, W7
219:                       number /= 10;
220:                       i--;
00227A  E90285     DEC W5, W5
221:                   }
222:                   if (i==width){
002284  508F85     SUB W1, W5, [W15]
002286  3A0003     BRA NZ, 0x228E
223:                       *d--='0';
002288  B3C304     MOV #0x30, W4
00228A  785384     MOV.B W4, [W7--]
224:                       i--;
00228C  E90285     DEC W5, W5
225:                   }
226:                   while (i>0){
00228E  528FE0     SUB W5, #0x0, [W15]
002290  340007     BRA LE, 0x22A0
00229A  520F80     SUB W4, W0, [W15]
00229C  3AFFFD     BRA NZ, 0x2298
00229E  538385     SUB W7, W5, W7
227:                       *d--=' ';
002296  B3C206     MOV #0x20, W6
002298  785206     MOV.B W6, [W4--]
228:                       i--;
229:                   }
230:                   if (sign){*d='-';}else{*d=' ';}
0022A0  510FE0     SUB W2, #0x0, [W15]
0022A2  320003     BRA Z, 0x22AA
0022A4  B3C2D4     MOV #0x2D, W4
0022A6  784B84     MOV.B W4, [W7]
0022A8  370002     BRA 0x22AE
0022AA  B3C204     MOV #0x20, W4
0022AC  784B84     MOV.B W4, [W7]
231:                   print(d);
0022AE  780007     MOV W7, W0
0022B0  07FFA8     RCALL print
232:               }// print_int()
0022B2  FA8000     ULNK
0022B4  060000     RETURN
233:               
234:               void set_tab_width(unsigned char width){
235:                   tab_width=width;
0022B6  B7FFFE     MOV.B WREG, tab_width
236:               }// set_tab_width()
0022B8  060000     RETURN
237:               
238:               void clear_eol(void){
0022BA  BE9F88     MOV.D W8, [W15++]
0022BC  BE9F8A     MOV.D W10, [W15++]
239:                   int x,y;
240:                   x=cx;
0022BE  80FF8A     MOV cx, W10
241:                   y=cy;
0022C0  80FF9B     MOV cy, W11
242:                   while (cx<(CHAR_WIDTH*(CHAR_PER_LINE-2))){
0022C2  200C54     MOV #0xC5, W4
0022C4  550F84     SUB W10, W4, [W15]
0022C6  3E0007     BRA GTU, 0x22D6
0022CA  780484     MOV W4, W9
0022D0  80FF84     MOV cx, W4
0022D2  520F89     SUB W4, W9, [W15]
0022D4  36FFFB     BRA LEU, 0x22CC
243:                       put_char(32);
0022C8  B3C208     MOV #0x20, W8
0022CC  784008     MOV.B W8, W0
0022CE  07FF0E     RCALL put_char
244:                   }
245:                   put_char(32);
0022D6  B3C200     MOV #0x20, W0
0022D8  07FF09     RCALL put_char
246:                   cx=x;
0022DA  88FF8A     MOV W10, cx
247:                   cy=y;
0022DC  88FF9B     MOV W11, cy
248:               }// clear_eol()
0022DE  BE054F     MOV.D [--W15], W10
0022E0  BE044F     MOV.D [--W15], W8
0022E2  060000     RETURN
249:               
250:               text_coord_t get_curpos(){
251:                   text_coord_t cpos;
252:                   cpos.x = cx/CHAR_WIDTH;
0022E4  80FF85     MOV cx, W5
0022E6  200064     MOV #0x6, W4
0022E8  781F80     MOV W0, [W15++]
0022EA  090011     REPEAT #0x11
0022EC  D88284     DIV.UW W5, W4
0022EE  780200     MOV W0, W4
0022F0  78004F     MOV [--W15], W0
0022F2  780804     MOV W4, [W0]
253:                   cpos.y = cy/CHAR_HEIGHT;
0022F4  80FF94     MOV cy, W4
0022F6  DE2243     LSR W4, #3, W4
0022F8  980014     MOV W4, [W0+2]
254:                   return cpos;
255:               } // get_cursor_pos()
0022FA  060000     RETURN
256:               
257:               void set_curpos(unsigned short x, unsigned short y){// {x,y} character coord.
258:                   if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
0022FC  200224     MOV #0x22, W4
0022FE  500F84     SUB W0, W4, [W15]
002300  3E0006     BRA GTU, 0x230E
002302  508FFA     SUB W1, #0x1A, [W15]
002304  3E0004     BRA GTU, 0x230E
259:                       return;
260:                   cx=x*CHAR_WIDTH;
002306  B90266     MUL.SU W0, #6, W4
002308  88FF84     MOV W4, cx
261:                   cy=y*CHAR_HEIGHT;
00230A  DD08C3     SL W1, #3, W1
00230C  88FF91     MOV W1, cy
262:               }//set_curpos()
00230E  060000     RETURN
263:               
264:               void invert_char(void){// invert pixels of character at cursor position
002310  BE9F88     MOV.D W8, [W15++]
00232C  E80287     INC W7, W5
00232E  B93C7B     MUL.SU W7, #27, W8
002330  420008     ADD W4, W8, W0
002332  208004     MOV #0x800, W4
002334  400204     ADD W0, W4, W4
002336  4383EA     ADD W7, #0xA, W7
265:                   register int i,l,r,b,x,y;
266:                   x=cx;
002312  80FF81     MOV cx, W1
267:                   y=cy;
002314  80FF97     MOV cy, W7
268:                   b=x>>3;
002316  DE8A43     ASR W1, #3, W4
269:                   r=0;
270:                   l=(8-CHAR_WIDTH)-(x&7);
002318  6080E7     AND W1, #0x7, W1
00231A  1080E2     SUBR W1, #0x2, W1
271:                   if (l<0){
272:                       r=-l;
00231C  DE8ACF     ASR W1, #15, W5
00231E  EA0301     NEG W1, W6
002320  630305     AND W6, W5, W6
273:                   }
274:                   for (i=9;i;i--){
00234C  528F87     SUB W5, W7, [W15]
00234E  3AFFF4     BRA NZ, 0x2338
275:                       if (r){
002338  530FE0     SUB W6, #0x0, [W15]
00233A  320005     BRA Z, 0x2346
276:                           video_buffer[y][b] ^= (0x3f>>r);
002322  2003F5     MOV #0x3F, W5
002324  DEA986     ASR W5, W6, W3
00233C  69CA14     XOR.B W3, [W4], [W4]
277:                           video_buffer[y][b+1] ^= (0x3f<<(8-r));
002326  130168     SUBR W6, #0x8, W2
002328  DD2902     SL W5, W2, W2
00233E  904014     MOV.B [W4+1], W0
002340  684002     XOR.B W0, W2, W0
002342  984210     MOV.B W0, [W4+1]
002344  370001     BRA 0x2348
278:                           y++;
279:                       } else{
280:                           video_buffer[y++][b] ^= (0x3f<<l);
00232A  DD2881     SL W5, W1, W1
002346  68CA14     XOR.B W1, [W4], [W4]
002348  E80285     INC W5, W5
00234A  42027B     ADD W4, #0x1B, W4
281:                       }
282:                   }
283:               }//invert_char()
002350  BE044F     MOV.D [--W15], W8
002352  060000     RETURN
284:               
285:               static void toggle_underscore(void){
286:                   register int l,r,b,x;
287:                   x=cx;
00200A  80FF84     MOV cx, W4
288:                   b=x>>5;
00200C  DEA2C5     ASR W4, #5, W5
289:                   r=0;
290:                   l=(8-CHAR_WIDTH)-(x&7);
00200E  620267     AND W4, #0x7, W4
002010  120262     SUBR W4, #0x2, W4
291:                   if (l<0){
002012  3B0014     BRA NN, 0x203C
292:                       r=-l;
002014  EA0304     NEG W4, W6
293:                   }
294:                   if (r){
002016  320012     BRA Z, 0x203C
295:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
002018  80FF90     MOV cy, W0
00201A  400067     ADD W0, #0x7, W0
00201C  208004     MOV #0x800, W4
00201E  B9007B     MUL.SU W0, #27, W0
002020  400085     ADD W0, W5, W1
002022  420101     ADD W4, W1, W2
002024  2003F7     MOV #0x3F, W7
002026  DEB986     ASR W7, W6, W3
002028  78C0E4     MOV.B [W4+W1], W1
00202A  68C903     XOR.B W1, W3, [W2]
296:                       video_buffer[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<(8-r));
00202C  E80285     INC W5, W5
00202E  400285     ADD W0, W5, W5
002030  420005     ADD W4, W5, W0
002032  130368     SUBR W6, #0x8, W6
002034  DD3B86     SL W7, W6, W7
002036  7AC264     MOV.B [W4+W5], W4
002038  6A4807     XOR.B W4, W7, [W0]
00203A  37000A     BRA 0x2050
297:                   } else{
298:                       video_buffer[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
00203C  80FF90     MOV cy, W0
00203E  400067     ADD W0, #0x7, W0
002040  208006     MOV #0x800, W6
002042  B9007B     MUL.SU W0, #27, W0
002044  428280     ADD W5, W0, W5
002046  430385     ADD W6, W5, W7
002048  2003F0     MOV #0x3F, W0
00204A  DD0204     SL W0, W4, W4
00204C  7AC2E6     MOV.B [W6+W5], W5
00204E  6ACB84     XOR.B W5, W4, [W7]
299:                   }
300:               }//toggle_underscore()
002050  060000     RETURN
301:               
302:               void show_cursor(BOOL show){
002354  781F88     MOV W8, [W15++]
303:                   if (show){
002356  500FE0     SUB W0, #0x0, [W15]
002358  32000B     BRA Z, 0x2370
304:                       flags |= CUR_SHOW;
00235A  80FF64     MOV flags, W4
00235C  A00004     BSET W4, #0
305:                       flags ^= CUR_VIS;
00235E  A21004     BTG W4, #1
002360  88FF64     MOV W4, flags
306:                       if (cur_shape==CR_BLOCK){
002362  80FF74     MOV cur_shape, W4
002364  520FE1     SUB W4, #0x1, [W15]
002366  3A0002     BRA NZ, 0x236C
307:                           invert_char();
002368  07FFD3     RCALL invert_char
00236A  37000E     BRA 0x2388
308:                       }else{
309:                           toggle_underscore();
00236C  07FE4E     RCALL toggle_underscore
00236E  37000C     BRA 0x2388
310:                       }
311:                   }else{
312:                       if (flags & CUR_VIS){
002370  80FF68     MOV flags, W8
002372  640262     AND W8, #0x2, W4
002374  320008     BRA Z, 0x2386
313:                           if (cur_shape==CR_BLOCK){
002376  80FF74     MOV cur_shape, W4
002378  520FE1     SUB W4, #0x1, [W15]
00237A  3A0002     BRA NZ, 0x2380
314:                               invert_char();
00237C  07FFC9     RCALL invert_char
00237E  370001     BRA 0x2382
315:                           }else{
316:                               toggle_underscore();
002380  07FE44     RCALL toggle_underscore
317:                           }
318:                           flags &= ~CUR_VIS;
002382  A11008     BCLR W8, #1
002384  88FF68     MOV W8, flags
319:                       }
320:                       flags &= ~CUR_SHOW;
002386  A91FEC     BCLR flags, #0
321:                   }
322:               
323:               }// show_cursor()
002388  78044F     MOV [--W15], W8
00238A  060000     RETURN
324:               
325:               void set_cursor(cursor_t shape){
00238C  781F88     MOV W8, [W15++]
00238E  780400     MOV W0, W8
326:                   if (flags & CUR_VIS){
002390  AB3FEC     BTST flags, #1
002392  320006     BRA Z, 0x23A0
327:                       show_cursor(FALSE);
002394  EB0000     CLR W0
002396  07FFDE     RCALL show_cursor
328:                       cur_shape=shape;
002398  88FF78     MOV W8, cur_shape
329:                       show_cursor(TRUE);
00239A  200010     MOV #0x1, W0
00239C  07FFDB     RCALL show_cursor
00239E  370001     BRA 0x23A2
330:                   }else{
331:                       cur_shape=shape;
0023A0  88FF78     MOV W8, cur_shape
332:                   }
333:               }// set_cursor()
0023A2  78044F     MOV [--W15], W8
0023A4  060000     RETURN
334:               
335:               
336:               void invert_video(){
337:                   flags |= INV_VID;
0023A6  A85FEC     BSET flags, #2
338:               }//invert_video()
0023A8  060000     RETURN
339:               
340:               void normal_video(){
341:                   flags &= ~INV_VID;
0023AA  A95FEC     BCLR flags, #2
342:               }//normal_video()
0023AC  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/system/timers.c  --------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 *  NAME: timers.c
21:                 *  DATE CREATED: 2014-02-21
22:                 *  AUTHOR: Jacques Deschênes
23:                 *  DESCRIPTION: create timers with callback. TIMER1 is used as a system timer that
24:                 *               ticks at regular interval. The ISR of TIMER1 manage created timers.
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "timers.h"
29:                
30:                #define F_TMR_USED 1
31:                #define F_TMR_HALTED 2
32:                #define F_TMR_REPEAT 4
33:                #define TMR_RUNNING 1
34:                
35:                
36:                typedef struct timer_type{
37:                    unsigned status;    // slot used,  timer halted
38:                    unsigned delay;    // timer interval
39:                    unsigned countdown;
40:                    timer_handler_t *handler; // timer callback handler
41:                }timer_t;
42:                
43:                volatile static timer_t timers[MAX_TIMERS];
44:                volatile static unsigned long ticks;
45:                
46:                void timers_init(unsigned ticks_per_second){
0023AE  BE9F88     MOV.D W8, [W15++]
0023B0  781F8A     MOV W10, [W15++]
0023B2  780500     MOV W0, W10
47:                    unsigned long quotient;
48:                    unsigned prescale;
49:                    int i;
50:                    for (i=0;i<MAX_TIMERS;i++){
0023B4  EB0200     CLR W4
0023C6  E80204     INC W4, W4
0023C8  520FE8     SUB W4, #0x8, [W15]
0023CA  3AFFF8     BRA NZ, 0x23BC
51:                        timers[i].status=0;
0023B6  21FAC1     MOV #0x1FAC, W1
0023B8  EB0300     CLR W6
0023BC  DD22C3     SL W4, #3, W5
0023BE  408385     ADD W1, W5, W7
0023C0  780B86     MOV W6, [W7]
52:                        timers[i].handler=NULL;
0023BA  408066     ADD W1, #0x6, W0
0023C2  400285     ADD W0, W5, W5
0023C4  780A86     MOV W6, [W5]
53:                    }//for
54:                    ticks=0;
0023CC  EF3FA8     CLR ticks
0023CE  EF3FAA     CLR 0x1FAA
55:                
56:                    SYSTICKTMR.TON=0;  // disable systick timer
0023D0  A9E105     BCLR 0x105, #7
57:                    SYSTICKTMR.TCS=0;  // use internal Tcy
0023D2  A92104     BCLR T1CON, #1
58:                    quotient = FCY/ticks_per_second;
0023D4  B85461     MUL.UU W10, #1, W8
0023D6  BE0108     MOV.D W8, W2
0023D8  224000     MOV #0x2400, W0
0023DA  200F41     MOV #0xF4, W1
0023DC  07F075     RCALL 0x4C8
59:                    prescale=1;
0023E4  200014     MOV #0x1, W4
60:                    while (quotient>65535){
0023DE  400FE1     ADD W0, #0x1, [W15]
0023E0  588FE0     SUBB W1, #0x0, [W15]
0023E2  36000B     BRA LEU, 0x23FA
0023E6  2FFFF6     MOV #0xFFFF, W6
0023E8  200007     MOV #0x0, W7
0023F0  500F86     SUB W0, W6, [W15]
0023F2  588F87     SUBB W1, W7, [W15]
0023F4  3EFFFA     BRA GTU, 0x23EA
61:                        quotient >>= 1;
0023EA  D10081     LSR W1, W1
0023EC  D38000     RRC W0, W0
62:                        prescale <<= 1;
0023EE  420204     ADD W4, W4, W4
63:                    }
64:                    if (prescale==1){
0023F6  520FE1     SUB W4, #0x1, [W15]
0023F8  3A0006     BRA NZ, 0x2406
65:                        SYSTICKTMR.TCKPS=0;
0023FA  800824     MOV T1CON, W4
0023FC  A14004     BCLR W4, #4
0023FE  A15004     BCLR W4, #5
002400  880824     MOV W4, T1CON
66:                        SYSTICKPR=quotient;
002402  880810     MOV W0, PR1
002404  370020     BRA 0x2446
67:                    }else if (prescale<=8){
002406  520FE8     SUB W4, #0x8, [W15]
002408  3E000A     BRA GTU, 0x241E
68:                        SYSTICKTMR.TCKPS=1;
00240A  800824     MOV T1CON, W4
00240C  A04004     BSET W4, #4
00240E  A15004     BCLR W4, #5
002410  880824     MOV W4, T1CON
69:                        SYSTICKPR= FCY/8/ticks_per_second;
002412  BE0108     MOV.D W8, W2
002414  284800     MOV #0x8480, W0
002416  2001E1     MOV #0x1E, W1
002418  07F057     RCALL 0x4C8
00241A  880810     MOV W0, PR1
00241C  370014     BRA 0x2446
70:                    }else if (prescale<=64){
00241E  200405     MOV #0x40, W5
002420  520F85     SUB W4, W5, [W15]
002422  3E000A     BRA GTU, 0x2438
71:                        SYSTICKTMR.TCKPS=2;
002424  800824     MOV T1CON, W4
002426  A14004     BCLR W4, #4
002428  A05004     BSET W4, #5
00242A  880824     MOV W4, T1CON
72:                        SYSTICKPR= FCY/64/ticks_per_second;
00242C  BE0108     MOV.D W8, W2
00242E  2D0900     MOV #0xD090, W0
002430  200031     MOV #0x3, W1
002432  07F04A     RCALL 0x4C8
002434  880810     MOV W0, PR1
002436  370007     BRA 0x2446
73:                    }else{
74:                        SYSTICKTMR.TCKPS=3;
002438  200300     MOV #0x30, W0
00243A  B72104     IOR T1CON
75:                        SYSTICKPR = FCY/256/ticks_per_second;
00243C  2F4244     MOV #0xF424, W4
00243E  090011     REPEAT #0x11
002440  D8820A     DIV.UW W4, W10
002442  780200     MOV W0, W4
002444  880814     MOV W4, PR1
76:                    }//if
77:                    SYSTICKIF=0; // reset interrupt flag
002446  A96084     BCLR IFS0, #3
78:                    SYSTICKIE=1; // enable interrupt on systick timer
002448  A86094     BSET IEC0, #3
79:                    SYSTICKTMR.TON = 1; // enable systick timer
00244A  A8E105     BSET 0x105, #7
80:                }//f()
00244C  78054F     MOV [--W15], W10
00244E  BE044F     MOV.D [--W15], W8
002450  060000     RETURN
81:                
82:                int create_timer(unsigned delay, unsigned repeat, timer_handler_t *handler){
83:                    int i;
84:                    if (!handler) return -1;
002452  EB8200     SETM W4
002454  510FE0     SUB W2, #0x0, [W15]
002456  320020     BRA Z, 0x2498
85:                    for (i=0;i<MAX_TIMERS;i++){
00245C  200014     MOV #0x1, W4
002490  E80204     INC W4, W4
002492  520FE8     SUB W4, #0x8, [W15]
002494  3AFFE4     BRA NZ, 0x245E
86:                        if (!(timers[i].status & F_TMR_USED)){
002458  AB1FAC     BTST timers, #0
00245A  320007     BRA Z, 0x246A
00245E  DD22C3     SL W4, #3, W5
002460  21FAC6     MOV #0x1FAC, W6
002462  7A82E6     MOV [W6+W5], W5
002464  6282E1     AND W5, #0x1, W5
002466  3A0014     BRA NZ, 0x2490
002468  370001     BRA 0x246C
00246A  EB0200     CLR W4
87:                            timers[i].status = F_TMR_USED|F_TMR_HALTED;
00246C  DD22C3     SL W4, #3, W5
00246E  200037     MOV #0x3, W7
002470  21FAC6     MOV #0x1FAC, W6
002472  7AB307     MOV W7, [W6+W5]
88:                            if (repeat==TIMER_REPEAT) {timers[i].status |= F_TMR_REPEAT;}
002474  508FE1     SUB W1, #0x1, [W15]
002476  3A0004     BRA NZ, 0x2480
002478  7A83E6     MOV [W6+W5], W7
00247A  430285     ADD W6, W5, W5
00247C  A02007     BSET W7, #2
00247E  780A87     MOV W7, [W5]
89:                            timers[i].delay=delay;
002480  DD22C3     SL W4, #3, W5
002482  21FAE6     MOV #0x1FAE, W6
002484  7AB300     MOV W0, [W6+W5]
90:                            timers[i].countdown=delay;
002486  E88306     INC2 W6, W6
002488  7AB300     MOV W0, [W6+W5]
91:                            timers[i].handler=handler;
00248A  E88306     INC2 W6, W6
00248C  7AB302     MOV W2, [W6+W5]
92:                            return i;
00248E  370004     BRA 0x2498
93:                        }//if
94:                    }//for
95:                    return -1;
002496  EB8200     SETM W4
96:                }//f()
002498  780004     MOV W4, W0
00249A  060000     RETURN
97:                
98:                void stop_timer(int timer_id){
99:                    if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
00249C  500FE7     SUB W0, #0x7, [W15]
00249E  3E000B     BRA GTU, 0x24B6
0024A6  620261     AND W4, #0x1, W4
0024A8  320006     BRA Z, 0x24B6
100:                        (timers[timer_id].status & F_TMR_USED)){
0024A0  DD0243     SL W0, #3, W4
0024A2  21FAC5     MOV #0x1FAC, W5
0024A4  7A0265     MOV [W5+W4], W4
101:                       timers[timer_id].status |= F_TMR_HALTED;
0024AA  DD0043     SL W0, #3, W0
0024AC  780205     MOV W5, W4
0024AE  7802E4     MOV [W4+W0], W5
0024B0  420000     ADD W4, W0, W0
0024B2  A01005     BSET W5, #1
0024B4  780805     MOV W5, [W0]
102:                   }//if
103:               }//f()
0024B6  060000     RETURN
104:               
105:               void start_timer(int timer_id){
106:                   if ((timer_id>=0) && (timer_id<MAX_TIMERS) &&
0024B8  500FE7     SUB W0, #0x7, [W15]
0024BA  3E000F     BRA GTU, 0x24DA
0024C2  620261     AND W4, #0x1, W4
0024C4  32000A     BRA Z, 0x24DA
107:                       (timers[timer_id].status & F_TMR_USED)){
0024BC  DD0243     SL W0, #3, W4
0024BE  21FAC5     MOV #0x1FAC, W5
0024C0  7A0265     MOV [W5+W4], W4
108:                           timers[timer_id].countdown=timers[timer_id].delay;
0024C6  DD0043     SL W0, #3, W0
0024C8  E88300     INC2 W0, W6
0024CA  780205     MOV W5, W4
0024CC  4282E4     ADD W5, #0x4, W5
0024CE  7B0364     MOV [W4+W6], W6
0024D0  783286     MOV W6, [W5+W0]
109:                           timers[timer_id].status &= ~F_TMR_HALTED;
0024D2  7802E4     MOV [W4+W0], W5
0024D4  420000     ADD W4, W0, W0
0024D6  A11005     BCLR W5, #1
0024D8  780805     MOV W5, [W0]
110:                   }//if
111:               }//f()
0024DA  060000     RETURN
112:               
113:               void update_timer(int timer_id, unsigned new_delay){
114:                   if ((timer_id>=0)&&(timer_id<=MAX_TIMERS)&&timers[timer_id].status){
0024DC  500FE8     SUB W0, #0x8, [W15]
0024DE  3E0008     BRA GTU, 0x24F0
0024E0  DD0243     SL W0, #3, W4
0024E2  21FAC5     MOV #0x1FAC, W5
0024E4  7A0265     MOV [W5+W4], W4
0024E6  520FE0     SUB W4, #0x0, [W15]
0024E8  320003     BRA Z, 0x24F0
115:                       timers[timer_id].delay=new_delay;
0024EA  DD0043     SL W0, #3, W0
0024EC  E88205     INC2 W5, W4
0024EE  783201     MOV W1, [W4+W0]
116:                   }
117:               }//f()
0024F0  060000     RETURN
118:               
119:               void destroy_timer(int timer_id){
120:                   if ((timer_id<0)||(timer_id>=MAX_TIMERS)) return;
0024F2  500FE7     SUB W0, #0x7, [W15]
0024F4  3E0008     BRA GTU, 0x2506
121:                   timers[timer_id].status=0;
0024F6  DD0043     SL W0, #3, W0
0024F8  21FAC5     MOV #0x1FAC, W5
0024FA  428280     ADD W5, W0, W5
0024FC  EB0200     CLR W4
0024FE  780A84     MOV W4, [W5]
122:                   timers[timer_id].handler=NULL;
002500  21FB25     MOV #0x1FB2, W5
002502  428000     ADD W5, W0, W0
002504  780804     MOV W4, [W0]
123:               }//f()
002506  060000     RETURN
124:               
125:               unsigned long sys_ticks(){
126:                   return ticks;
002508  80FD40     MOV ticks, W0
00250A  80FD51     MOV 0x1FAA, W1
127:               }//f()
00250C  060000     RETURN
128:               
129:               void __attribute__((interrupt,no_auto_psv)) _SYSTICK_ISR(void){
00250E  F80036     PUSH RCOUNT
002510  BE9F80     MOV.D W0, [W15++]
002512  BE9F82     MOV.D W2, [W15++]
002514  BE9F84     MOV.D W4, [W15++]
002516  BE9F86     MOV.D W6, [W15++]
002518  BE9F88     MOV.D W8, [W15++]
00251A  BE9F8A     MOV.D W10, [W15++]
130:                   int i;
131:                   ticks++;
00251C  80FD44     MOV ticks, W4
00251E  80FD55     MOV 0x1FAA, W5
002520  420261     ADD W4, #0x1, W4
002522  4A82E0     ADDC W5, #0x0, W5
002524  88FD44     MOV W4, ticks
002526  88FD55     MOV W5, 0x1FAA
132:                   for (i=0;i<MAX_TIMERS;i++){
002528  EB0400     CLR W8
002570  E80408     INC W8, W8
002572  540FE8     SUB W8, #0x8, [W15]
002574  3AFFDB     BRA NZ, 0x252C
133:                       if (((timers[i].status&(F_TMR_USED|F_TMR_HALTED))==TMR_RUNNING)){
00252C  DD4243     SL W8, #3, W4
00252E  21FAC5     MOV #0x1FAC, W5
002530  7A0265     MOV [W5+W4], W4
002532  620263     AND W4, #0x3, W4
002534  520FE1     SUB W4, #0x1, [W15]
002536  3A001C     BRA NZ, 0x2570
134:                           if (--timers[i].countdown==0){
00252A  21FB09     MOV #0x1FB0, W9
002538  DD4343     SL W8, #3, W6
00253A  430264     ADD W6, #0x4, W4
00253C  7A03E5     MOV [W5+W4], W7
00253E  448306     ADD W9, W6, W6
002540  E90B07     DEC W7, [W6]
002542  7A0265     MOV [W5+W4], W4
002544  520FE0     SUB W4, #0x0, [W15]
002546  3A0014     BRA NZ, 0x2570
135:                               timers[i].handler();
002548  DD45C3     SL W8, #3, W11
00254A  458266     ADD W11, #0x6, W4
00254C  780505     MOV W5, W10
00254E  7A026A     MOV [W10+W4], W4
002550  010004     CALL W4
136:                               if (timers[i].status & F_TMR_REPEAT) {
002552  7D826A     MOV [W10+W11], W4
002554  620264     AND W4, #0x4, W4
002556  320006     BRA Z, 0x2564
137:                                   timers[i].countdown=timers[i].delay;
002558  78020B     MOV W11, W4
00255A  E88284     INC2 W4, W5
00255C  78030A     MOV W10, W6
00255E  7A8366     MOV [W6+W5], W6
002560  7A3486     MOV W6, [W9+W4]
002562  370006     BRA 0x2570
138:                               }else{
139:                                   timers[i].status |= F_TMR_HALTED;
002564  DD4243     SL W8, #3, W4
002566  21FAC5     MOV #0x1FAC, W5
002568  7A0365     MOV [W5+W4], W6
00256A  428204     ADD W5, W4, W4
00256C  A01006     BSET W6, #1
00256E  780A06     MOV W6, [W4]
140:                               }
141:                           }//if
142:                       }
143:                   }//for
144:                   SYSTICKIF=0;
002576  A96084     BCLR IFS0, #3
145:               }// _SYSTICK_ISR()
002578  BE054F     MOV.D [--W15], W10
00257A  BE044F     MOV.D [--W15], W8
00257C  BE034F     MOV.D [--W15], W6
00257E  BE024F     MOV.D [--W15], W4
002580  BE014F     MOV.D [--W15], W2
002582  BE004F     MOV.D [--W15], W0
002584  F90036     POP RCOUNT
002586  064000     RETFIE
146:               
147:               
148:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/menus.c  ----------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   menus.c
21:                 * Author: jacques Deschênes
22:                 * Description: display text menu on screen, use paddle as input device.
23:                 *            >>> use dynamic memory allocation, space must reserved for
24:                 *            >>> heap in project properties
25:                 * Created on 24 mars 2014, 13:41
26:                 */
27:                
28:                #include <stdlib.h>
29:                #include "menus.h"
30:                
31:                /* menu_t *create_menu()
32:                 * Description: create a new menu.
33:                 * Arguments:
34:                 *      - *title  menu title text
35:                 *  return pointer to that menu or NULL if failed.
36:                 */
37:                menu_t *create_menu(const char *title){
002890  781F88     MOV W8, [W15++]
002892  780400     MOV W0, W8
38:                    menu_t *m;
39:                    m=malloc(sizeof(menu_t));
002894  200060     MOV #0x6, W0
002896  07EE67     RCALL 0x566
40:                    if (m){
002898  500FE0     SUB W0, #0x0, [W15]
00289A  320004     BRA Z, 0x28A4
41:                        m->title=title;
00289C  780808     MOV W8, [W0]
42:                        m->first=NULL;
00289E  EB0200     CLR W4
0028A0  980024     MOV W4, [W0+4]
43:                        m->items=0;
0028A2  980014     MOV W4, [W0+2]
44:                    }
45:                    return m;
46:                }//f()
0028A4  78044F     MOV [--W15], W8
0028A6  060000     RETURN
47:                
48:                /* menu_item_t* add_menu_item(const char *text, int id, menut_t *menu)
49:                 * Description: create a new menu item and add it to menu
50:                 * Arguments:
51:                 *      - text  item caption text
52:                 *      - id   unique identifier for this item
53:                 *      - *menu pointer to parent menu
54:                 *  return pointer to item or NULL if failed.
55:                 */
56:                menu_item_t* add_menu_item(const char *text, int id, menu_t *menu){
0028A8  BE9F88     MOV.D W8, [W15++]
0028AA  781F8A     MOV W10, [W15++]
0028AC  780500     MOV W0, W10
0028AE  780481     MOV W1, W9
0028B0  780402     MOV W2, W8
57:                    menu_item_t *item, *walk;
58:                    item=malloc(sizeof(menu_item_t));
0028B2  200060     MOV #0x6, W0
0028B4  07EE58     RCALL 0x566
59:                    if (item){
0028B6  500FE0     SUB W0, #0x0, [W15]
0028B8  32001A     BRA Z, 0x28EE
60:                        item->id=id;
0028BA  980019     MOV W9, [W0+2]
61:                        item->text=text;
0028BC  78080A     MOV W10, [W0]
62:                        item->next=NULL;
0028BE  EB0200     CLR W4
0028C0  980024     MOV W4, [W0+4]
63:                        if (!menu->first){
0028C2  900228     MOV [W8+4], W4
0028C4  520FE0     SUB W4, #0x0, [W15]
0028C6  3A000F     BRA NZ, 0x28E6
64:                            menu->first=item;
0028C8  980420     MOV W0, [W8+4]
65:                            menu->items=1;
0028CA  200014     MOV #0x1, W4
0028CC  980414     MOV W4, [W8+2]
0028CE  37000F     BRA 0x28EE
66:                        }else{
67:                            walk=menu->first;
68:                            while (walk){
69:                                if (!walk->next){
0028D0  780284     MOV W4, W5
0028D2  900225     MOV [W5+4], W4
0028D4  520FE0     SUB W4, #0x0, [W15]
0028D6  3AFFFC     BRA NZ, 0x28D0
0028D8  370001     BRA 0x28DC
0028DA  780284     MOV W4, W5
0028E6  9002A4     MOV [W4+4], W5
0028E8  528FE0     SUB W5, #0x0, [W15]
0028EA  3AFFF3     BRA NZ, 0x28D2
0028EC  37FFF6     BRA 0x28DA
70:                                    walk->next=item;
0028DC  9802A0     MOV W0, [W5+4]
71:                                    menu->items++;
0028DE  900218     MOV [W8+2], W4
0028E0  E80204     INC W4, W4
0028E2  980414     MOV W4, [W8+2]
72:                                    break;
0028E4  370004     BRA 0x28EE
73:                                }else{
74:                                    walk=walk->next;
75:                                }//if
76:                            }//while
77:                        }//if
78:                    }//if
79:                    return item;
80:                }//f()
0028EE  78054F     MOV [--W15], W10
0028F0  BE044F     MOV.D [--W15], W8
0028F2  060000     RETURN
81:                
82:                // display menu and hilite selected item
83:                void display_menu(menu_t *menu,int x, int y, int selected){
0028F4  BE9F88     MOV.D W8, [W15++]
0028F6  BE9F8A     MOV.D W10, [W15++]
0028F8  781F8C     MOV W12, [W15++]
0028FA  780400     MOV W0, W8
0028FC  780583     MOV W3, W11
002918  E8860C     INC2 W12, W12
84:                    menu_item_t *walk;
85:                    int count;
86:                
87:                    count=0;
002916  EB0480     CLR W9
88:                    set_curpos(x,y);
0028FE  780602     MOV W2, W12
002900  780501     MOV W1, W10
002902  78008C     MOV W12, W1
002904  78000A     MOV W10, W0
002906  07FCFA     RCALL set_curpos
89:                    invert_video();
002908  07FD4E     RCALL invert_video
90:                    print(menu->title);
00290A  780018     MOV [W8], W0
00290C  07FC7A     RCALL print
91:                    normal_video();
00290E  07FD4D     RCALL normal_video
92:                    walk=menu->first;
002910  900428     MOV [W8+4], W8
93:                    while (walk){
002912  540FE0     SUB W8, #0x0, [W15]
002914  320013     BRA Z, 0x293C
002934  540FE0     SUB W8, #0x0, [W15]
002936  320002     BRA Z, 0x293C
94:                        set_curpos(x,y+2+count);
00291A  460089     ADD W12, W9, W1
00291C  78000A     MOV W10, W0
00291E  07FCEE     RCALL set_curpos
95:                        if (count==selected){
002920  548F8B     SUB W9, W11, [W15]
002922  3A0005     BRA NZ, 0x292E
96:                            invert_video();
002924  07FD40     RCALL invert_video
97:                            print(walk->text);
002926  780018     MOV [W8], W0
002928  07FC6C     RCALL print
98:                            normal_video();
00292A  07FD3F     RCALL normal_video
00292C  370002     BRA 0x2932
99:                        }else{
100:                           print(walk->text);
00292E  780018     MOV [W8], W0
002930  07FC68     RCALL print
101:                       }
102:                       walk=walk->next;
002932  900428     MOV [W8+4], W8
103:                       count++;
002938  E80489     INC W9, W9
00293A  37FFEF     BRA 0x291A
104:                   }//while
105:               }//f()
00293C  78064F     MOV [--W15], W12
00293E  BE054F     MOV.D [--W15], W10
002940  BE044F     MOV.D [--W15], W8
002942  060000     RETURN
106:               
107:               
108:               /* int run_menu(menu_t *menu, int x, int y, int pad);
109:                * Description: display menu and wait for selection.
110:                * Arguments:
111:                *      - *menu pointer  menu to display
112:                *      - x  text console column coordinate of menu title
113:                *      - y  text console line coordinate of menu title
114:                *      - paddle which gamepad control menu.
115:                * return id of selected item
116:                */
117:               int run_menu(menu_t *menu, int x, int y, int paddle){
002944  BE9F88     MOV.D W8, [W15++]
002946  BE9F8A     MOV.D W10, [W15++]
002948  BE9F8C     MOV.D W12, [W15++]
00294A  781F8E     MOV W14, [W15++]
00294C  780480     MOV W0, W9
00294E  780501     MOV W1, W10
002950  780582     MOV W2, W11
002952  780603     MOV W3, W12
118:                   int selected, loop;
119:                   unsigned buttons;
120:                   selected=0;
002954  EB0400     CLR W8
121:                   loop=1;
122:                   while (loop){
123:                       display_menu(menu,x,y,selected);
00295A  780188     MOV W8, W3
00295C  78010B     MOV W11, W2
00295E  78008A     MOV W10, W1
002960  780009     MOV W9, W0
002962  07FFC8     RCALL display_menu
124:                       buttons=read_paddle(paddle);
002964  78000C     MOV W12, W0
002966  070101     RCALL read_paddle
125:                       if ((buttons&SNES_UP)==SNES_UP){
002968  600270     AND W0, #0x10, W4
00296A  320004     BRA Z, 0x2974
126:                           if (selected>0) selected--;
00296C  540FE0     SUB W8, #0x0, [W15]
00296E  34000C     BRA LE, 0x2988
002970  E90408     DEC W8, W8
002972  37000A     BRA 0x2988
127:                       }else if((buttons&SNES_DOWN)==SNES_DOWN){
002956  20020E     MOV #0x20, W14
002974  60020E     AND W0, W14, W4
002976  320006     BRA Z, 0x2984
128:                           if (selected<(menu->items-1)) selected++;
002978  900219     MOV [W9+2], W4
00297A  E90204     DEC W4, W4
00297C  520F88     SUB W4, W8, [W15]
00297E  340004     BRA LE, 0x2988
002980  E80408     INC W8, W8
002982  370002     BRA 0x2988
129:                       }else if ((buttons & SNES_SELECT)==SNES_SELECT){
002984  600064     AND W0, #0x4, W0
002986  3A0009     BRA NZ, 0x299A
130:                           loop=0;
131:                       }
132:                       wait_n_frame(10);
002958  2000AD     MOV #0xA, W13
002988  78000D     MOV W13, W0
00298A  07FE3C     RCALL wait_n_frame
00298C  37FFE6     BRA 0x295A
00298E  900014     MOV [W4+2], W0
00299A  2000A0     MOV #0xA, W0
00299C  07FE33     RCALL wait_n_frame
133:                   }
134:               
135:                   int i;
136:                   menu_item_t *walk;
137:                   walk=menu->first;
00299E  900229     MOV [W9+4], W4
138:                   i=0;
139:                   while(i<selected)walk=walk->next;
0029A0  540FE0     SUB W8, #0x0, [W15]
0029A2  34FFF5     BRA LE, 0x298E
0029A4  37FFFF     BRA 0x29A4
140:                   return walk->id;
141:               }//f()
002990  78074F     MOV [--W15], W14
002992  BE064F     MOV.D [--W15], W12
002994  BE054F     MOV.D [--W15], W10
002996  BE044F     MOV.D [--W15], W8
002998  060000     RETURN
142:               
143:               // recursively free items list.
144:               void free_item(menu_item_t *item){
0029A6  781F88     MOV W8, [W15++]
0029A8  780400     MOV W0, W8
145:                   if (item->next) free_item(item->next);
0029AA  900028     MOV [W8+4], W0
0029AC  500FE0     SUB W0, #0x0, [W15]
0029AE  320001     BRA Z, 0x29B2
0029B0  07FFFA     RCALL free_item
146:                   free(item);
0029B2  780008     MOV W8, W0
0029B4  07EE79     RCALL 0x6A8
147:               }//f()
0029B6  78044F     MOV [--W15], W8
0029B8  060000     RETURN
148:               
149:               /* void destroy_menu(menu_t menu)
150:                * Description: destroy menu and all items in it.
151:                * Arguments:
152:                *      - *menu  pointer to menu
153:                */
154:               void destroy_menu(menu_t *menu){
0029BA  781F88     MOV W8, [W15++]
0029BC  780400     MOV W0, W8
155:                   free_item(menu->first);
0029BE  900028     MOV [W8+4], W0
0029C0  07FFF2     RCALL free_item
156:                   free(menu);
0029C2  780008     MOV W8, W0
0029C4  07EE71     RCALL 0x6A8
157:               }//f()
0029C6  78044F     MOV [--W15], W8
0029C8  060000     RETURN
158:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/graphics/graphics.c  ----------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   graphics.h
21:                 * Author: jacques Deschênes
22:                 * Description: Draw geometrics figures.
23:                 *      coordinates origin is screen top,left, x increase to right, y increase to bottom
24:                 * Created on 28 février 2014, 13:07
25:                 */
26:                
27:                #include <stdlib.h>
28:                #include "graphics.h"
29:                
30:                // draw a dot
31:                
32:                void plot(int x, int y, int color){
33:                    int h,ofs;
34:                    unsigned char mask;
35:                    if ((y>=VPIXELS)||(x>=HPIXELS)) return; // bound check
0014E4  200D74     MOV #0xD7, W4
0014E6  508F84     SUB W1, W4, [W15]
0014E8  3C0025     BRA GT, 0x1534
0014EA  500F84     SUB W0, W4, [W15]
0014EC  3C0023     BRA GT, 0x1534
36:                    h= x/8;
0014EE  200084     MOV #0x8, W4
0014F0  780281     MOV W1, W5
0014F2  090011     REPEAT #0x11
0014F4  D80004     DIV.SW W0, W4
0014F6  FD0281     EXCH W1, W5
37:                    ofs = 7 - x%8;
0014F8  1282E7     SUBR W5, #0x7, W5
38:                    mask = 1<<ofs;
0014FA  200016     MOV #0x1, W6
0014FC  DD3285     SL W6, W5, W5
39:                    switch (color){
0014FE  510F86     SUB W2, W6, [W15]
001500  32000C     BRA Z, 0x151A
001502  510FE2     SUB W2, #0x2, [W15]
001504  320011     BRA Z, 0x1528
001506  510FE0     SUB W2, #0x0, [W15]
001508  3A0015     BRA NZ, 0x1534
40:                        case BLACK:
41:                            video_buffer[y][h]&= ~mask;
00150A  208007     MOV #0x800, W7
00150C  B9097B     MUL.SU W1, #27, W2
00150E  400082     ADD W0, W2, W1
001510  438201     ADD W7, W1, W4
001512  EAC285     COM.B W5, W5
001514  78C3E7     MOV.B [W7+W1], W7
001516  62CA07     AND.B W5, W7, [W4]
42:                            break;
001518  37000D     BRA 0x1534
43:                        case WHITE:
44:                            video_buffer[y][h]|= mask;
00151A  208006     MOV #0x800, W6
00151C  B9097B     MUL.SU W1, #27, W2
00151E  400082     ADD W0, W2, W1
001520  430201     ADD W6, W1, W4
001522  78C366     MOV.B [W6+W1], W6
001524  72CA06     IOR.B W5, W6, [W4]
45:                            break;
001526  370006     BRA 0x1534
46:                        case INVERT:
47:                            video_buffer[y][h] ^= mask;
001528  208006     MOV #0x800, W6
00152A  B9097B     MUL.SU W1, #27, W2
00152C  400082     ADD W0, W2, W1
00152E  430201     ADD W6, W1, W4
001530  78C366     MOV.B [W6+W1], W6
001532  6ACA06     XOR.B W5, W6, [W4]
48:                            break;
49:                    }
50:                } // plot()
001534  060000     RETURN
51:                
52:                // dessine une droite en utilisant l'algorithme de Bresenham
53:                void line(int x1, int y1, int x2, int y2, int color){
001536  4787EA     ADD W15, #0xA, W15
001538  BE9F88     MOV.D W8, [W15++]
00153A  BE9F8A     MOV.D W10, [W15++]
00153C  BE9F8C     MOV.D W12, [W15++]
00153E  781F8E     MOV W14, [W15++]
001540  780400     MOV W0, W8
001542  780501     MOV W1, W10
001544  780582     MOV W2, W11
001546  9FB7F3     MOV W3, [W15-18]
001548  780604     MOV W4, W12
00155E  448408     ADD W9, W8, W8
001560  370004     BRA 0x156A
001574  540209     SUB W8, W9, W4
00158A  44850A     ADD W9, W10, W10
001596  550209     SUB W10, W9, W4
54:                    int deltax,deltay;
55:                    plot(x1,y1,color);
00154A  78010C     MOV W12, W2
00154C  78008A     MOV W10, W1
00154E  780008     MOV W8, W0
001550  07FFC9     RCALL plot
56:                    if (y1==y2){// cas particulier ligne horizontale
001552  97B27F     MOV [W15-18], W4
001554  550F84     SUB W10, W4, [W15]
001556  3A0012     BRA NZ, 0x157C
57:                        deltax= x1<x2?1:-1;
001558  540F8B     SUB W8, W11, [W15]
00155A  3D0003     BRA GE, 0x1562
00155C  200019     MOV #0x1, W9
001562  EB8480     SETM W9
58:                        while (x1!=x2){
001564  540F8B     SUB W8, W11, [W15]
001566  3AFFFB     BRA NZ, 0x155E
001568  37004B     BRA 0x1600
001576  558F84     SUB W11, W4, [W15]
001578  3AFFF8     BRA NZ, 0x156A
00157A  370042     BRA 0x1600
59:                            x1 += deltax;
60:                            plot(x1,y1,color);
00156A  78010C     MOV W12, W2
00156C  78008A     MOV W10, W1
00156E  780008     MOV W8, W0
001570  07FFB9     RCALL plot
001572  440409     ADD W8, W9, W8
61:                        }
62:                    }else if (x1==x2){ // cas particulier ligne verticale
00157C  540F8B     SUB W8, W11, [W15]
00157E  3A0010     BRA NZ, 0x15A0
63:                        deltay= y1<y2?1:-1;
001580  EB8480     SETM W9
001582  97B2FF     MOV [W15-18], W5
001584  550F85     SUB W10, W5, [W15]
001586  3D0001     BRA GE, 0x158A
001588  200019     MOV #0x1, W9
64:                        while (y1!=y2){
001598  97B2FF     MOV [W15-18], W5
00159A  528F84     SUB W5, W4, [W15]
00159C  3AFFF7     BRA NZ, 0x158C
00159E  370030     BRA 0x1600
65:                            y1+=deltay;
66:                            plot(x1,y1,color);
00158C  78010C     MOV W12, W2
00158E  78008A     MOV W10, W1
001590  780008     MOV W8, W0
001592  07FFA8     RCALL plot
001594  450509     ADD W10, W9, W10
67:                        }
68:                    }else{
69:                        int sx,sy,err,e2;
70:                        deltax=abs(x2-x1);
0015A0  558708     SUB W11, W8, W14
0015A2  A7F00E     BTSC W14, #15
0015A4  EA070E     NEG W14, W14
71:                        deltay=abs(y2-y1);
0015A6  97B2FF     MOV [W15-18], W5
0015A8  52820A     SUB W5, W10, W4
0015AA  A7F004     BTSC W4, #15
0015AC  EA0204     NEG W4, W4
0015AE  9FBF84     MOV W4, [W15-16]
72:                        sx = x1<x2?1:-1;
0015B0  EB8200     SETM W4
0015B2  9FB7E4     MOV W4, [W15-20]
0015B4  540F8B     SUB W8, W11, [W15]
0015B6  3D0002     BRA GE, 0x15BC
0015B8  200015     MOV #0x1, W5
0015BA  9FB7E5     MOV W5, [W15-20]
73:                        sy = y1<y2?1:-1;
0015BC  EB8200     SETM W4
0015BE  9FB7D4     MOV W4, [W15-22]
0015C0  97B2FF     MOV [W15-18], W5
0015C2  550F85     SUB W10, W5, [W15]
0015C4  3D0002     BRA GE, 0x15CA
0015C6  200014     MOV #0x1, W4
0015C8  9FB7D4     MOV W4, [W15-22]
74:                        err=deltax-deltay;
0015CA  97BA8F     MOV [W15-16], W5
0015CC  570485     SUB W14, W5, W9
75:                        while (!((x1==x2) && (y1==y2))){
0015D2  78040B     MOV W11, W8
0015F6  540F8B     SUB W8, W11, [W15]
0015F8  3AFFED     BRA NZ, 0x15D4
0015FA  97B2FF     MOV [W15-18], W5
0015FC  550F85     SUB W10, W5, [W15]
0015FE  3AFFE9     BRA NZ, 0x15D2
76:                            e2=err<<1;
0015D4  448209     ADD W9, W9, W4
77:                            if (e2>-deltay){
0015CE  EA0685     NEG W5, W13
0015D0  370001     BRA 0x15D4
0015D6  520F8D     SUB W4, W13, [W15]
0015D8  340005     BRA LE, 0x15E4
78:                               err -= deltay;
0015DA  97BA0F     MOV [W15-16], W4
0015DC  548484     SUB W9, W4, W9
79:                               x1 += sx;
0015DE  97B2EF     MOV [W15-20], W5
0015E0  440405     ADD W8, W5, W8
0015E2  370005     BRA 0x15EE
80:                            }else if (e2<deltax){
0015E4  570F84     SUB W14, W4, [W15]
0015E6  340003     BRA LE, 0x15EE
81:                                err +=deltax;
0015E8  44848E     ADD W9, W14, W9
82:                                y1 += sy;
0015EA  97B25F     MOV [W15-22], W4
0015EC  450504     ADD W10, W4, W10
83:                            }
84:                            plot(x1,y1,color);
0015EE  78010C     MOV W12, W2
0015F0  78008A     MOV W10, W1
0015F2  780008     MOV W8, W0
0015F4  07FF77     RCALL plot
85:                        }
86:                    }
87:                } // line()
001600  78074F     MOV [--W15], W14
001602  BE064F     MOV.D [--W15], W12
001604  BE054F     MOV.D [--W15], W10
001606  BE044F     MOV.D [--W15], W8
001608  B100AF     SUB #0xA, W15
00160A  060000     RETURN
88:                
89:                void rectangle(int x1, int y1, int x2, int y2, int color){
00160C  BE9F88     MOV.D W8, [W15++]
00160E  BE9F8A     MOV.D W10, [W15++]
001610  781F8C     MOV W12, [W15++]
001612  780480     MOV W0, W9
001614  780401     MOV W1, W8
001616  780502     MOV W2, W10
001618  780603     MOV W3, W12
00161A  780584     MOV W4, W11
90:                    line(x1,y1,x1,y2,color);
00161C  780109     MOV W9, W2
00161E  780088     MOV W8, W1
001620  780009     MOV W9, W0
001622  07FF89     RCALL line
91:                    line(x2,y1,x2,y2,color);
001624  78020B     MOV W11, W4
001626  78018C     MOV W12, W3
001628  78010A     MOV W10, W2
00162A  780088     MOV W8, W1
00162C  78000A     MOV W10, W0
00162E  07FF83     RCALL line
92:                    line(x1,y1,x2,y1,color);
001630  78020B     MOV W11, W4
001632  780188     MOV W8, W3
001634  78010A     MOV W10, W2
001636  780088     MOV W8, W1
001638  780009     MOV W9, W0
00163A  07FF7D     RCALL line
93:                    line(x1,y2,x2,y2,color);
00163C  78020B     MOV W11, W4
00163E  78018C     MOV W12, W3
001640  78010A     MOV W10, W2
001642  78008C     MOV W12, W1
001644  780009     MOV W9, W0
001646  07FF77     RCALL line
94:                }//rectangle()
001648  78064F     MOV [--W15], W12
00164A  BE054F     MOV.D [--W15], W10
00164C  BE044F     MOV.D [--W15], W8
00164E  060000     RETURN
95:                
96:                /*  algorthme mid-point
97:                 * REF: http://www.hhhprogram.com/2013/05/draw-elipse-midpoint-elipse-algorithm.html
98:                 */
99:                void ellipse (int xc, int yc, long rx, long ry, int color){
001650  B0036F     ADD #0x36, W15
001652  BE9F88     MOV.D W8, [W15++]
001654  BE9F8A     MOV.D W10, [W15++]
001656  BE9F8C     MOV.D W12, [W15++]
001658  781F8E     MOV W14, [W15++]
00165A  9FAF90     MOV W0, [W15-46]
00165C  9FAFE1     MOV W1, [W15-36]
00165E  BE0504     MOV.D W4, W10
001660  780706     MOV W6, W14
0016DC  9FA7F2     MOV W2, [W15-50]
0016DE  9FAF83     MOV W3, [W15-48]
0016EA  97AA9F     MOV [W15-46], W5
0016EC  E90285     DEC W5, W5
0016EE  9FA7C5     MOV W5, [W15-56]
0016F0  97AB1F     MOV [W15-46], W6
0016F2  E80306     INC W6, W6
0016F4  9FA7B6     MOV W6, [W15-58]
0016F6  9F9FFA     MOV W10, [W15-66]
0016F8  9FA78B     MOV W11, [W15-64]
001702  97B47F     MOV [W15-18], W8
001704  97A0CF     MOV [W15-56], W1
001706  408088     ADD W1, W8, W1
001708  9FB791     MOV W1, [W15-30]
001716  97A1BF     MOV [W15-58], W3
001718  518408     SUB W3, W8, W8
001742  97A07F     MOV [W15-50], W0
001744  97A88F     MOV [W15-48], W1
001746  40030C     ADD W0, W12, W6
001748  48838D     ADDC W1, W13, W7
001778  97A47F     MOV [W15-50], W8
00177A  97AC8F     MOV [W15-48], W9
00177C  44030C     ADD W8, W12, W6
00177E  4C838D     ADDC W9, W13, W7
00179C  97B37F     MOV [W15-18], W6
00179E  97BB8F     MOV [W15-16], W7
0017A0  530061     SUB W6, #0x1, W0
0017A2  5B80E0     SUBB W7, #0x0, W1
00184C  97AA4F     MOV [W15-40], W4
00184E  97AADF     MOV [W15-38], W5
001850  120260     SUBR W4, #0x0, W4
001852  1A82E0     SUBBR W5, #0x0, W5
001854  9FB794     MOV W4, [W15-30]
001856  9FB7A5     MOV W5, [W15-28]
001858  97AADF     MOV [W15-38], W5
00185A  97B47F     MOV [W15-18], W8
00185C  B9AB08     MUL.SS W5, W8, W6
00185E  97BC8F     MOV [W15-16], W9
001860  97A84F     MOV [W15-40], W0
001862  B9CA00     MUL.SS W9, W0, W4
001864  420206     ADD W4, W6, W4
001866  97A9CF     MOV [W15-40], W3
001868  97B15F     MOV [W15-22], W2
00186A  B81902     MUL.UU W3, W2, W2
00186C  9FB7B2     MOV W2, [W15-26]
00186E  9FB7C3     MOV W3, [W15-24]
001870  420183     ADD W4, W3, W3
001872  9FB7C3     MOV W3, [W15-24]
001874  97B23F     MOV [W15-26], W4
001876  97B2CF     MOV [W15-24], W5
001878  9FB7D4     MOV W4, [W15-22]
00187A  9FB7E5     MOV W5, [W15-20]
001884  97ABEF     MOV [W15-36], W7
001886  53858C     SUB W7, W12, W11
001894  97A8EF     MOV [W15-36], W1
001896  40848C     ADD W1, W12, W9
0018BC  560261     SUB W12, #0x1, W4
0018BE  5E82E0     SUBB W13, #0x0, W5
0018DA  560261     SUB W12, #0x1, W4
0018DC  5E82E0     SUBB W13, #0x0, W5
100:                         long  x=0,y=ry;
101:                         long  p=(ry*ry)-(rx*rx*ry)+((rx*rx)/4);
001662  B99A02     MUL.SS W3, W2, W4
001664  420204     ADD W4, W4, W4
001666  B81002     MUL.UU W2, W2, W0
001668  9FAFA0     MOV W0, [W15-44]
00166A  9FAFB1     MOV W1, [W15-42]
00166C  420081     ADD W4, W1, W1
00166E  9FAFB1     MOV W1, [W15-42]
001670  97A92F     MOV [W15-44], W2
001672  97A9BF     MOV [W15-42], W3
001674  550202     SUB W10, W2, W4
001676  5D8283     SUBB W11, W3, W5
001678  B9AB0A     MUL.SS W5, W10, W6
00167A  B9D804     MUL.SS W11, W4, W0
00167C  400306     ADD W0, W6, W6
00167E  B8220A     MUL.UU W4, W10, W4
001680  430285     ADD W6, W5, W5
001682  BE0302     MOV.D W2, W6
001684  510FE0     SUB W2, #0x0, [W15]
001686  598FE0     SUBB W3, #0x0, [W15]
001688  3D0002     BRA GE, 0x168E
00168A  410363     ADD W2, #0x3, W6
00168C  4983E0     ADDC W3, #0x0, W7
00168E  DD39CE     SL W7, #14, W3
001690  DE3342     LSR W6, #2, W6
001692  718306     IOR W3, W6, W6
001694  DEBBC2     ASR W7, #2, W7
001696  430404     ADD W6, W4, W8
001698  4B8485     ADDC W7, W5, W9
00169A  9FB7B8     MOV W8, [W15-26]
00169C  9FB7C9     MOV W9, [W15-24]
102:                         while((2*x*ry*ry)<(2*y*rx*rx)){
00169E  B9DA0A     MUL.SS W11, W10, W4
0016A0  420204     ADD W4, W4, W4
0016A2  B8500A     MUL.UU W10, W10, W0
0016A4  9FA7D0     MOV W0, [W15-54]
0016A6  9FA7E1     MOV W1, [W15-52]
0016A8  420081     ADD W4, W1, W1
0016AA  9FA7E1     MOV W1, [W15-52]
0016AC  97A15F     MOV [W15-54], W2
0016AE  97A1EF     MOV [W15-52], W3
0016B0  410102     ADD W2, W2, W2
0016B2  498183     ADDC W3, W3, W3
0016B4  9FA792     MOV W2, [W15-62]
0016B6  9FA7A3     MOV W3, [W15-60]
0016B8  97AA2F     MOV [W15-44], W4
0016BA  97AABF     MOV [W15-42], W5
0016BC  420204     ADD W4, W4, W4
0016BE  4A8285     ADDC W5, W5, W5
0016C0  9FB7D4     MOV W4, [W15-22]
0016C2  9FB7E5     MOV W5, [W15-20]
0016E0  200014     MOV #0x1, W4
0016E2  200005     MOV #0x0, W5
0016E4  9FB7F4     MOV W4, [W15-18]
0016E6  9FBF85     MOV W5, [W15-16]
0016E8  B86660     MUL.UU W12, #0, W12
0016FA  370050     BRA 0x179C
0017A4  97B3DF     MOV [W15-22], W7
0017A6  B9DA07     MUL.SS W11, W7, W4
0017A8  97B46F     MOV [W15-20], W8
0017AA  B9C30A     MUL.SS W8, W10, W6
0017AC  430304     ADD W6, W4, W6
0017AE  97B4DF     MOV [W15-22], W9
0017B0  B85209     MUL.UU W10, W9, W4
0017B2  430285     ADD W6, W5, W5
0017B4  520F8C     SUB W4, W12, [W15]
0017B6  5A8F8D     SUBB W5, W13, [W15]
0017B8  3CFFA1     BRA GT, 0x16FC
0017BA  BE010A     MOV.D W10, W2
0017BC  9FB79A     MOV W10, [W15-30]
0017BE  9FB7AB     MOV W11, [W15-28]
0017C0  9FAFF0     MOV W0, [W15-34]
0017C2  9FB781     MOV W1, [W15-32]
0017C4  979D7F     MOV [W15-66], W10
0017C6  97A58F     MOV [W15-64], W11
0017C8  BE0600     MOV.D W0, W12
103:                              plot(xc+x,yc-y,color);
0016FC  97A86F     MOV [W15-36], W0
0016FE  50000A     SUB W0, W10, W0
001700  9FAFF0     MOV W0, [W15-34]
00170A  78010E     MOV W14, W2
00170C  780080     MOV W0, W1
00170E  97B01F     MOV [W15-30], W0
001710  07FEE9     RCALL plot
104:                              plot(xc-x,yc+y,color);
001712  97A96F     MOV [W15-36], W2
001714  450482     ADD W10, W2, W9
00171A  78010E     MOV W14, W2
00171C  BE0008     MOV.D W8, W0
00171E  07FEE2     RCALL plot
105:                              plot(xc+x,yc+y,color);
001720  78010E     MOV W14, W2
001722  780089     MOV W9, W1
001724  97B01F     MOV [W15-30], W0
001726  07FEDE     RCALL plot
106:                              plot(xc-x,yc-y,color);
001728  78010E     MOV W14, W2
00172A  97A8FF     MOV [W15-34], W1
00172C  780008     MOV W8, W0
00172E  07FEDA     RCALL plot
107:                              if(p<0){
001730  97B23F     MOV [W15-26], W4
001732  97B2CF     MOV [W15-24], W5
001734  520FE0     SUB W4, #0x0, [W15]
001736  5A8FE0     SUBB W5, #0x0, [W15]
001738  3D000D     BRA GE, 0x1754
108:                                  x=x+1;
109:                                  p=p+(2*ry*ry*x)+(ry*ry);
00173A  97A45F     MOV [W15-54], W8
00173C  97A4EF     MOV [W15-52], W9
00173E  440204     ADD W8, W4, W4
001740  4C8285     ADDC W9, W5, W5
00174A  420106     ADD W4, W6, W2
00174C  4A8187     ADDC W5, W7, W3
00174E  9FB7B2     MOV W2, [W15-26]
001750  9FB7C3     MOV W3, [W15-24]
001752  37001A     BRA 0x1788
110:                              }else {
111:                                  x=x+1;
112:                                  y=y-1;
001754  550561     SUB W10, #0x1, W10
001756  5D85E0     SUBB W11, #0x0, W11
113:                                  p=p+(2*ry*ry*x+ry*ry)-(2*rx*rx*y);
0016C4  2FFFE4     MOV #0xFFFE, W4
0016C6  97AB3F     MOV [W15-42], W6
0016C8  B9B204     MUL.SS W6, W4, W4
0016CA  97ABAF     MOV [W15-44], W7
0016CC  520207     SUB W4, W7, W4
0016CE  2FFFE5     MOV #0xFFFE, W5
0016D0  97ACAF     MOV [W15-44], W9
0016D2  B84C05     MUL.UU W9, W5, W8
0016D4  9FAFC8     MOV W8, [W15-40]
0016D6  9FAFD9     MOV W9, [W15-38]
0016D8  420489     ADD W4, W9, W9
0016DA  9FAFD9     MOV W9, [W15-38]
001758  97B23F     MOV [W15-26], W4
00175A  97B2CF     MOV [W15-24], W5
00175C  97A45F     MOV [W15-54], W8
00175E  97A4EF     MOV [W15-52], W9
001760  440304     ADD W8, W4, W6
001762  4C8385     ADDC W9, W5, W7
001764  97ACCF     MOV [W15-40], W9
001766  B9DA09     MUL.SS W11, W9, W4
001768  97A95F     MOV [W15-38], W2
00176A  B9900A     MUL.SS W2, W10, W0
00176C  400004     ADD W0, W4, W0
00176E  97A9CF     MOV [W15-40], W3
001770  B85203     MUL.UU W10, W3, W4
001772  400285     ADD W0, W5, W5
001774  420206     ADD W4, W6, W4
001776  4A8287     ADDC W5, W7, W5
001780  420006     ADD W4, W6, W0
001782  4A8087     ADDC W5, W7, W1
001784  9FB7B0     MOV W0, [W15-26]
001786  9FB7C1     MOV W1, [W15-24]
001788  97A17F     MOV [W15-50], W2
00178A  97A98F     MOV [W15-48], W3
00178C  41060C     ADD W2, W12, W12
00178E  49868D     ADDC W3, W13, W13
001790  97B27F     MOV [W15-18], W4
001792  97BA8F     MOV [W15-16], W5
001794  420261     ADD W4, #0x1, W4
001796  4A82E0     ADDC W5, #0x0, W5
001798  9FB7F4     MOV W4, [W15-18]
00179A  9FBF85     MOV W5, [W15-16]
114:                              }
115:                         }
116:                         p=((float)x+0.5)*((float)x+0.5)*ry*ry+(y-1)*(y-1)*rx*rx-rx*rx*ry*ry;
0017D0  BE000A     MOV.D W10, W0
0017D2  07F5F0     RCALL 0x3B4
0017D4  BE0400     MOV.D W0, W8
0017D6  97B31F     MOV [W15-30], W6
0017D8  97B3AF     MOV [W15-28], W7
0017DA  530361     SUB W6, #0x1, W6
0017DC  5B83E0     SUBB W7, #0x0, W7
0017DE  9FB7F6     MOV W6, [W15-18]
0017E0  9FBF87     MOV W7, [W15-16]
0017E2  BE000C     MOV.D W12, W0
0017E4  07F5E7     RCALL 0x3B4
0017E6  200002     MOV #0x0, W2
0017E8  23F003     MOV #0x3F00, W3
0017EA  07F566     RCALL 0x2B8
0017EC  BE0100     MOV.D W0, W2
0017EE  07F638     RCALL 0x460
0017F0  BE0108     MOV.D W8, W2
0017F2  07F636     RCALL 0x460
0017F4  BE0100     MOV.D W0, W2
0017F6  BE0008     MOV.D W8, W0
0017F8  07F633     RCALL 0x460
0017FA  BE0400     MOV.D W0, W8
0017FC  97BB8F     MOV [W15-16], W7
0017FE  97B07F     MOV [W15-18], W0
001800  B9BA00     MUL.SS W7, W0, W4
001802  420204     ADD W4, W4, W4
001804  97B0FF     MOV [W15-18], W1
001806  9FB7D1     MOV W1, [W15-22]
001808  780101     MOV W1, W2
00180A  B81002     MUL.UU W2, W2, W0
00180C  420081     ADD W4, W1, W1
00180E  97A9AF     MOV [W15-44], W3
001810  B98B03     MUL.SS W1, W3, W6
001812  97A93F     MOV [W15-42], W2
001814  B99200     MUL.SS W2, W0, W4
001816  420206     ADD W4, W6, W4
001818  97AD2F     MOV [W15-44], W10
00181A  B8000A     MUL.UU W0, W10, W0
00181C  420081     ADD W4, W1, W1
00181E  07F5CA     RCALL 0x3B4
001820  BE0100     MOV.D W0, W2
001822  BE0008     MOV.D W8, W0
001824  07F549     RCALL 0x2B8
001826  BE0400     MOV.D W0, W8
001828  97A9BF     MOV [W15-42], W3
00182A  97A25F     MOV [W15-54], W4
00182C  B99B04     MUL.SS W3, W4, W6
00182E  97A06F     MOV [W15-52], W0
001830  97A8AF     MOV [W15-44], W1
001832  B98201     MUL.SS W0, W1, W4
001834  420206     ADD W4, W6, W4
001836  97A15F     MOV [W15-54], W2
001838  B85002     MUL.UU W10, W2, W0
00183A  420081     ADD W4, W1, W1
00183C  07F5BB     RCALL 0x3B4
00183E  BE0100     MOV.D W0, W2
001840  BE0008     MOV.D W8, W0
001842  07F539     RCALL 0x2B6
001844  07F596     RCALL 0x372
001846  BE0500     MOV.D W0, W10
001848  97B61F     MOV [W15-30], W12
00184A  97B6AF     MOV [W15-28], W13
117:                         while(y>=0){
0017CA  510FE0     SUB W2, #0x0, [W15]
0017CC  598FE0     SUBB W3, #0x0, [W15]
0017CE  3500B8     BRA LT, 0x1940
00193A  520FE0     SUB W4, #0x0, [W15]
00193C  5A8FE0     SUBB W5, #0x0, [W15]
00193E  3DFFA2     BRA GE, 0x1884
118:                              plot(xc+x,yc-y,color);
001888  97AC7F     MOV [W15-34], W8
00188A  97A81F     MOV [W15-46], W0
00188C  440500     ADD W8, W0, W10
00188E  78010E     MOV W14, W2
001890  BE000A     MOV.D W10, W0
001892  07FE28     RCALL plot
119:                              plot(xc-x,yc+y,color);
001898  97A91F     MOV [W15-46], W2
00189A  510408     SUB W2, W8, W8
00189C  78010E     MOV W14, W2
00189E  BE0008     MOV.D W8, W0
0018A0  07FE21     RCALL plot
120:                              plot(xc+x,yc+y,color);
0018A2  78010E     MOV W14, W2
0018A4  780089     MOV W9, W1
0018A6  78000A     MOV W10, W0
0018A8  07FE1D     RCALL plot
121:                              plot(xc-x,yc-y,color);
0018AA  78010E     MOV W14, W2
0018AC  78008B     MOV W11, W1
0018AE  780008     MOV W8, W0
0018B0  07FE19     RCALL plot
122:                              if(p>0){
0018B2  97B27F     MOV [W15-18], W4
0018B4  97BA8F     MOV [W15-16], W5
0018B6  520FE0     SUB W4, #0x0, [W15]
0018B8  5A8FE0     SUBB W5, #0x0, [W15]
0018BA  34000F     BRA LE, 0x18DA
123:                                  y=y-1;
124:                                  p=p-(2*rx*rx*y)+(rx*rx);
0018C0  97B47F     MOV [W15-18], W8
0018C2  97BC8F     MOV [W15-16], W9
0018C4  97A82F     MOV [W15-44], W0
0018C6  97A8BF     MOV [W15-42], W1
0018C8  400308     ADD W0, W8, W6
0018CA  488389     ADDC W1, W9, W7
0018CC  97B15F     MOV [W15-22], W2
0018CE  97B1EF     MOV [W15-20], W3
0018D0  430102     ADD W6, W2, W2
0018D2  4B8183     ADDC W7, W3, W3
0018D4  9FB7F2     MOV W2, [W15-18]
0018D6  9FBF83     MOV W3, [W15-16]
0018D8  370020     BRA 0x191A
125:                              }else{
126:                                  y=y-1;
127:                                  x=x+1;
0018DE  97AB7F     MOV [W15-34], W6
0018E0  97B38F     MOV [W15-32], W7
0018E2  430361     ADD W6, #0x1, W6
0018E4  4B83E0     ADDC W7, #0x0, W7
0018E6  9FAFF6     MOV W6, [W15-34]
0018E8  9FB787     MOV W7, [W15-32]
128:                                  p=p+(2*ry*ry*x)-(2*rx*rx*y)-(rx*rx);
00187C  97A29F     MOV [W15-62], W5
00187E  9FAFC5     MOV W5, [W15-40]
001880  9FB7FA     MOV W10, [W15-18]
001882  9FBF8B     MOV W11, [W15-16]
0018EA  97B47F     MOV [W15-18], W8
0018EC  97BC8F     MOV [W15-16], W9
0018EE  97A82F     MOV [W15-44], W0
0018F0  97A8BF     MOV [W15-42], W1
0018F2  540100     SUB W8, W0, W2
0018F4  5C8181     SUBB W9, W1, W3
0018F6  97A3AF     MOV [W15-60], W7
0018F8  B9B806     MUL.SS W7, W6, W0
0018FA  97B40F     MOV [W15-32], W8
0018FC  97A49F     MOV [W15-62], W9
0018FE  B9C309     MUL.SS W8, W9, W6
001900  430000     ADD W6, W0, W0
001902  97A8CF     MOV [W15-40], W1
001904  97AC7F     MOV [W15-34], W8
001906  B80B08     MUL.UU W1, W8, W6
001908  400387     ADD W0, W7, W7
00190A  430302     ADD W6, W2, W6
00190C  4B8383     ADDC W7, W3, W7
00190E  97B03F     MOV [W15-26], W0
001910  97B0CF     MOV [W15-24], W1
001912  430000     ADD W6, W0, W0
001914  4B8081     ADDC W7, W1, W1
001916  9FB7F0     MOV W0, [W15-18]
001918  9FBF81     MOV W1, [W15-16]
00191A  560661     SUB W12, #0x1, W12
00191C  5E86E0     SUBB W13, #0x0, W13
00191E  97B15F     MOV [W15-22], W2
001920  97B1EF     MOV [W15-20], W3
001922  97B31F     MOV [W15-30], W6
001924  97B3AF     MOV [W15-28], W7
001926  430102     ADD W6, W2, W2
001928  4B8183     ADDC W7, W3, W3
00192A  9FB7D2     MOV W2, [W15-22]
00192C  9FB7E3     MOV W3, [W15-20]
00192E  97B43F     MOV [W15-26], W8
001930  97B4CF     MOV [W15-24], W9
001932  430408     ADD W6, W8, W8
001934  4B8489     ADDC W7, W9, W9
001936  9FB7B8     MOV W8, [W15-26]
001938  9FB7C9     MOV W9, [W15-24]
129:                              }
130:                         }
131:               }//ellipse()
001940  78074F     MOV [--W15], W14
001942  BE064F     MOV.D [--W15], W12
001944  BE054F     MOV.D [--W15], W10
001946  BE044F     MOV.D [--W15], W8
001948  B1036F     SUB #0x36, W15
00194A  060000     RETURN
132:               
133:               /*
134:                * points[]={x1,y1,x2,y2,x3,y3,...}
135:                * vertices est le nombre de points
136:                */
137:               void polygon(int points[], int vertices, int color){
00194C  BE9F88     MOV.D W8, [W15++]
00194E  BE9F8A     MOV.D W10, [W15++]
001950  781F8C     MOV W12, [W15++]
001952  780600     MOV W0, W12
001954  780582     MOV W2, W11
138:                   int i;
139:                   for(i=0;i<(2*vertices-2);i+=2){
001956  E90501     DEC W1, W10
001958  45050A     ADD W10, W10, W10
00195A  EB0480     CLR W9
00195C  550F89     SUB W10, W9, [W15]
00195E  34000B     BRA LE, 0x1976
001960  78040C     MOV W12, W8
00196E  E88489     INC2 W9, W9
001970  440464     ADD W8, #0x4, W8
001972  550F89     SUB W10, W9, [W15]
001974  3CFFF6     BRA GT, 0x1962
140:                       line(points[i],points[i+1],points[i+2],points[i+3],color);
001962  900128     MOV [W8+4], W2
001964  900098     MOV [W8+2], W1
001966  78020B     MOV W11, W4
001968  9001B8     MOV [W8+6], W3
00196A  780018     MOV [W8], W0
00196C  07FDE4     RCALL line
141:                   }
142:                   line(points[0],points[1],points[i],points[i+1],color);
001976  E80289     INC W9, W5
001978  428285     ADD W5, W5, W5
00197A  448489     ADD W9, W9, W9
00197C  90009C     MOV [W12+2], W1
00197E  78020B     MOV W11, W4
001980  7A81EC     MOV [W12+W5], W3
001982  7C816C     MOV [W12+W9], W2
001984  78001C     MOV [W12], W0
001986  07FDD7     RCALL line
143:               }//polygon()
001988  78064F     MOV [--W15], W12
00198A  BE054F     MOV.D [--W15], W10
00198C  BE044F     MOV.D [--W15], W8
00198E  060000     RETURN
144:               
145:               
146:               void box(int left, int top, int width, int height,int color){
001990  4787E4     ADD W15, #0x4, W15
001992  BE9F88     MOV.D W8, [W15++]
001994  BE9F8A     MOV.D W10, [W15++]
001996  BE9F8C     MOV.D W12, [W15++]
001998  781F8E     MOV W14, [W15++]
00199A  9FBF80     MOV W0, [W15-16]
147:                   int y, x,idx,mwidth,bitsleft;
148:                   unsigned char mask;
149:                   for (y=top;y<top+height;y++){
00199C  418701     ADD W3, W1, W14
00199E  508F8E     SUB W1, W14, [W15]
0019A0  350035     BRA LT, 0x1A0C
0019A2  37003C     BRA 0x1A1C
001A04  E8068D     INC W13, W13
001A06  568F8E     SUB W13, W14, [W15]
001A08  350006     BRA LT, 0x1A16
001A0A  370008     BRA 0x1A1C
001A0C  780681     MOV W1, W13
150:                       x=left;
151:                       bitsleft=width;
152:                       while (bitsleft){
0019A8  780382     MOV W2, W7
0019AA  97BA8F     MOV [W15-16], W5
001A02  3AFFD0     BRA NZ, 0x19A4
001A16  510FE0     SUB W2, #0x0, [W15]
001A18  3AFFC7     BRA NZ, 0x19A8
001A1A  37FFF4     BRA 0x1A04
153:                           idx=x/8;
0019B0  090011     REPEAT #0x11
0019B2  D80283     DIV.SW W5, W3
0019B4  780400     MOV W0, W8
001A0E  200083     MOV #0x8, W3
154:                           if (x%8==0){
0019B6  6280E7     AND W5, #0x7, W1
0019BC  320006     BRA Z, 0x19CA
155:                               mask=0xff;
0019B8  78400A     MOV.B W10, W0
001A14  EBC500     SETM.B W10
156:                               mwidth=8;
0019BA  780303     MOV W3, W6
157:                           }else{
158:                               mask=0xff>>(x%8);
0019BE  780301     MOV W1, W6
0019C0  090011     REPEAT #0x11
0019C2  D80283     DIV.SW W5, W3
0019C4  FD0301     EXCH W1, W6
0019C6  DED806     ASR W11, W6, W0
001A10  200FFB     MOV #0xFF, W11
159:                               mwidth=8-x%8;
0019C8  130368     SUBR W6, #0x8, W6
160:                           }
161:                           if (bitsleft<mwidth){
0019CA  530F87     SUB W6, W7, [W15]
0019CC  340004     BRA LE, 0x19D6
162:                               mask &= 0xff<<(mwidth-bitsleft);
0019CE  530307     SUB W6, W7, W6
0019D0  DD5B06     SL W11, W6, W6
0019D2  604006     AND.B W0, W6, W0
0019D4  780307     MOV W7, W6
163:                               mwidth=bitsleft;
164:                           }
165:                           switch(color){
0019D6  520FE1     SUB W4, #0x1, [W15]
0019D8  32000A     BRA Z, 0x19EE
0019DA  520FE2     SUB W4, #0x2, [W15]
0019DC  32000D     BRA Z, 0x19F8
0019DE  520FE0     SUB W4, #0x0, [W15]
0019E0  3A000F     BRA NZ, 0x1A00
166:                               case BLACK:
167:                                   video_buffer[y][idx] &= ~mask;
0019E2  460408     ADD W12, W8, W8
0019E4  448088     ADD W9, W8, W1
0019E6  EAC000     COM.B W0, W0
0019E8  7C4469     MOV.B [W9+W8], W8
0019EA  604888     AND.B W0, W8, [W1]
168:                                   break;
0019EC  370009     BRA 0x1A00
169:                               case WHITE:
170:                                   video_buffer[y][idx] |= mask;
0019AC  B9687B     MUL.SU W13, #27, W0
0019AE  780600     MOV W0, W12
0019EE  460408     ADD W12, W8, W8
0019F0  448088     ADD W9, W8, W1
0019F2  7C4469     MOV.B [W9+W8], W8
0019F4  704888     IOR.B W0, W8, [W1]
001A12  208009     MOV #0x800, W9
171:                                   break;
0019F6  370004     BRA 0x1A00
172:                               case INVERT:
173:                                   video_buffer[y][idx] ^= mask;
0019F8  460408     ADD W12, W8, W8
0019FA  448088     ADD W9, W8, W1
0019FC  7C4469     MOV.B [W9+W8], W8
0019FE  684888     XOR.B W0, W8, [W1]
174:                                   break;
175:                           }//switch
176:                           x += mwidth;
0019A4  428286     ADD W5, W6, W5
0019A6  370004     BRA 0x19B0
177:                           bitsleft -= mwidth;
001A00  538386     SUB W7, W6, W7
178:                       }//while
179:                   }//for
180:               }//f()
001A1C  78074F     MOV [--W15], W14
001A1E  BE064F     MOV.D [--W15], W12
001A20  BE054F     MOV.D [--W15], W10
001A22  BE044F     MOV.D [--W15], W8
001A24  B1004F     SUB #0x4, W15
001A26  060000     RETURN
181:               
182:               
183:               
184:               void bitmap(int left, int top, int width, int height, bmp_op_t op, const unsigned char* bmp){
001A28  4787EE     ADD W15, #0xE, W15
001A2A  BE9F88     MOV.D W8, [W15++]
001A2C  BE9F8A     MOV.D W10, [W15++]
001A2E  BE9F8C     MOV.D W12, [W15++]
001A30  781F8E     MOV W14, [W15++]
001A32  9FB7B0     MOV W0, [W15-26]
001A34  9FB7E2     MOV W2, [W15-20]
001B30  97B3DF     MOV [W15-22], W7
001B32  458587     ADD W11, W7, W11
001B34  370005     BRA 0x1B40
185:                   int x,y, xbmp,mwidth,idx, bitsleft,ybmp_inc;
186:                   unsigned char  mask, bmpbits, *ybmp;
187:               
188:                   ybmp_inc=width/8;
001A36  200086     MOV #0x8, W6
001A38  BE9F80     MOV.D W0, [W15++]
001A3A  090011     REPEAT #0x11
001A3C  D80106     DIV.SW W2, W6
001A3E  780100     MOV W0, W2
001A40  BE004F     MOV.D [--W15], W0
001A42  9FB7D2     MOV W2, [W15-22]
189:                   if (width%8) ybmp_inc++;
001A44  97B3EF     MOV [W15-20], W7
001A46  638367     AND W7, #0x7, W6
001A48  320002     BRA Z, 0x1A4E
001A4A  E80102     INC W2, W2
001A4C  9FB7D2     MOV W2, [W15-22]
190:                   ybmp=bmp;
001B36  780585     MOV W5, W11
191:                   //remainder=0;
192:                   for (y=top;y<top+height;y++){
001A4E  418181     ADD W3, W1, W3
001A50  9FB7C3     MOV W3, [W15-24]
001A52  508F83     SUB W1, W3, [W15]
001A54  350070     BRA LT, 0x1B36
001A56  370078     BRA 0x1B48
001B24  97B27F     MOV [W15-18], W4
001B26  E80204     INC W4, W4
001B28  9FB7F4     MOV W4, [W15-18]
001B2A  97B34F     MOV [W15-24], W6
001B2C  530F84     SUB W6, W4, [W15]
001B2E  34000C     BRA LE, 0x1B48
001B38  9FB7F1     MOV W1, [W15-18]
193:                       x=left;
194:                       xbmp=0;
195:                       bitsleft=width;
196:                       while (bitsleft){
001A5E  97B3EF     MOV [W15-20], W7
001A60  97B23F     MOV [W15-26], W4
001A62  EB0000     CLR W0
001B22  3AFF9A     BRA NZ, 0x1A58
001B40  97B46F     MOV [W15-20], W8
001B42  540FE0     SUB W8, #0x0, [W15]
001B44  3AFF8C     BRA NZ, 0x1A5E
001B46  37FFEE     BRA 0x1B24
197:                           idx=x/8;
001A6C  780500     MOV W0, W10
001A6E  090011     REPEAT #0x11
001A70  D80205     DIV.SW W4, W5
001A72  FD0500     EXCH W0, W10
001B3A  200085     MOV #0x8, W5
198:                           if (x%8==0){
001A74  620167     AND W4, #0x7, W2
001A7A  320008     BRA Z, 0x1A8C
199:                               mask=0xff;
001A76  78408E     MOV.B W14, W1
001B3E  EBC700     SETM.B W14
200:                               mwidth=8;
001A78  780305     MOV W5, W6
201:                           }else{
202:                               mask=0xff>>(x%8);
001A7C  781F80     MOV W0, [W15++]
001A7E  090011     REPEAT #0x11
001A80  D80205     DIV.SW W4, W5
001A82  780301     MOV W1, W6
001A84  78004F     MOV [--W15], W0
001A86  200FF2     MOV #0xFF, W2
001A88  DE9086     ASR W2, W6, W1
203:                               mwidth=8-x%8;
001A8A  130368     SUBR W6, #0x8, W6
204:                           }
205:                           if (bitsleft<mwidth){
001A8C  530F87     SUB W6, W7, [W15]
001A8E  340005     BRA LE, 0x1A9A
206:                               mask &= 0xff<<(mwidth-bitsleft);
001A90  530307     SUB W6, W7, W6
001A92  200FF3     MOV #0xFF, W3
001A94  DD1B06     SL W3, W6, W6
001A96  60C086     AND.B W1, W6, W1
001A98  780307     MOV W7, W6
207:                               mwidth=bitsleft;
208:                           }
209:                           bmpbits = (*(ybmp+xbmp/8))<<(xbmp%8);
001A9A  780400     MOV W0, W8
001A9C  780181     MOV W1, W3
001A9E  090011     REPEAT #0x11
001AA0  D80005     DIV.SW W0, W5
001AA2  FD0400     EXCH W0, W8
001AA4  FD0181     EXCH W1, W3
001AA6  7C416B     MOV.B [W11+W8], W2
001AA8  FB8102     ZE W2, W2
001AAA  DD1103     SL W2, W3, W2
210:                           if (xbmp%8){
001AAC  6004E7     AND W0, #0x7, W9
001AAE  320006     BRA Z, 0x1ABC
211:                               bmpbits |= (*(ybmp+xbmp/8+1))>>(8-xbmp%8);
001AB0  458408     ADD W11, W8, W8
001AB2  904418     MOV.B [W8+1], W8
001AB4  FB8408     ZE W8, W8
001AB6  1181E8     SUBR W3, #0x8, W3
001AB8  DEC183     ASR W8, W3, W3
001ABA  714103     IOR.B W2, W3, W2
212:                           }
213:                           bmpbits >>= (x%8);
001ABC  FB8102     ZE W2, W2
001ABE  781F80     MOV W0, [W15++]
001AC0  780181     MOV W1, W3
001AC2  090011     REPEAT #0x11
001AC4  D80205     DIV.SW W4, W5
001AC6  FD0181     EXCH W1, W3
001AC8  78004F     MOV [--W15], W0
001ACA  DE9103     ASR W2, W3, W2
214:                           bmpbits &= mask;
001ACC  614101     AND.B W2, W1, W2
215:                           switch(op){
001ACE  200038     MOV #0x3, W8
001AD0  200009     MOV #0x0, W9
001AD2  560F88     SUB W12, W8, [W15]
001AD4  5E8F89     SUBB W13, W9, [W15]
001AD6  3E0024     BRA GTU, 0x1B20
001AD8  01600C     BRA W12
001ADA  370003     BRA 0x1AE2
001ADC  37000B     BRA 0x1AF4
001ADE  370011     BRA 0x1B02
001AE0  370019     BRA 0x1B14
001B3C  B82661     MUL.UU W4, #1, W12
216:                               case BMP_COPY:
217:                                   video_buffer[y][idx] &= ~mask;
001AEA  EAC081     COM.B W1, W1
001AEC  7D4468     MOV.B [W8+W10], W8
001AEE  60C088     AND.B W1, W8, W1
218:                                   video_buffer[y][idx] |= bmpbits;
001AE2  97BC8F     MOV [W15-16], W9
001AE4  44850A     ADD W9, W10, W10
001AE6  208008     MOV #0x800, W8
001AE8  44018A     ADD W8, W10, W3
001AF0  714981     IOR.B W2, W1, [W3]
219:                                   break;
001AF2  370016     BRA 0x1B20
220:                               case BMP_OR:
221:                                   video_buffer[y][idx] |= bmpbits;
001AF4  97BC8F     MOV [W15-16], W9
001AF6  44850A     ADD W9, W10, W10
001AF8  208003     MOV #0x800, W3
001AFA  41808A     ADD W3, W10, W1
001AFC  7D41E3     MOV.B [W3+W10], W3
001AFE  714883     IOR.B W2, W3, [W1]
222:                                   break;
001B00  37000F     BRA 0x1B20
223:                               case BMP_AND:
224:                                   video_buffer[y][idx] &= (~mask) | bmpbits;
001B02  97BC0F     MOV [W15-16], W8
001B04  44050A     ADD W8, W10, W10
001B06  208009     MOV #0x800, W9
001B08  44840A     ADD W9, W10, W8
001B0A  EAC081     COM.B W1, W1
001B0C  714081     IOR.B W2, W1, W1
001B0E  7D4169     MOV.B [W9+W10], W2
001B10  60CC02     AND.B W1, W2, [W8]
225:                                   break;
001B12  370006     BRA 0x1B20
226:                               case BMP_XOR:
227:                                   video_buffer[y][idx] ^= bmpbits;
001A64  97B47F     MOV [W15-18], W8
001A66  B9417B     MUL.SU W8, #27, W2
001A68  780482     MOV W2, W9
001A6A  9FBF89     MOV W9, [W15-16]
001B14  97B88F     MOV [W15-16], W1
001B16  40850A     ADD W1, W10, W10
001B18  208003     MOV #0x800, W3
001B1A  41808A     ADD W3, W10, W1
001B1C  7D41E3     MOV.B [W3+W10], W3
001B1E  694883     XOR.B W2, W3, [W1]
228:                                   break;
229:                           }//switch
230:                           x += mwidth;
001A58  420206     ADD W4, W6, W4
231:                           xbmp += mwidth;
001A5A  400006     ADD W0, W6, W0
001A5C  370007     BRA 0x1A6C
232:                           bitsleft -= mwidth;
001B20  538386     SUB W7, W6, W7
233:                       }//while
234:                       ybmp+=ybmp_inc;
235:                       
236:                   }//for
237:               
238:               //    awidth=width/8;
239:               //    if (width%8) awidth++;
240:               //    first= left/8;
241:               //    lmask= 0xff>>(left%8);
242:               //    last= (left+width-1)/8;
243:               //    if (width<9){
244:               //        if (8-left%8>=width){
245:               //            rmask= lmask;
246:               //        }else{
247:               //            rmask= 0xff<<(8-left%8);
248:               //        }//if
249:               //    }
250:               //    else{
251:               //        rmask=0xff<<(8-(left+width)%8);
252:               //    }//if
253:               //    if (first==last){
254:               //        lmask &= rmask;
255:               //        for (i=top;i<top+height;i++){
256:               //            switch(r2op){
257:               //                case BMP_COPY:
258:               //                    video_buffer[i][first] &= ~lmask;
259:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
260:               //                    break;
261:               //                case BMP_OR:
262:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
263:               //                    break;
264:               //                case BMP_AND:
265:               //                    video_buffer[i][first] &= ~(lmask^((*(bmp+(i-top)))>>(left%8)));
266:               //                    break;
267:               //                case BMP_XOR:
268:               //                    video_buffer[i][first] ^= (*(bmp+(i-top)))>>(left%8);
269:               //                    break;
270:               //            }//switch
271:               //        }//for
272:               //    }else{
273:               //        for (i=top;i<top+height;i++){
274:               //            switch(r2op){
275:               //                case BMP_COPY:
276:               //                    video_buffer[i][first] &= ~lmask;
277:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
278:               //                    video_buffer[i][last] &= ~rmask;
279:               //                    if (width<8)
280:               //                        video_buffer[i][last]|=(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8);
281:               //                    else
282:               //                        video_buffer[i][last] |=(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8);
283:               //                    break;
284:               //                case BMP_OR:
285:               //                    video_buffer[i][first] |= (*(bmp+(i-top)))>>(left%8);
286:               //                    if (width<8)
287:               //                        video_buffer[i][last]|=(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8);
288:               //                    else
289:               //                        video_buffer[i][last] |=(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8);
290:               //                    break;
291:               //                    break;
292:               //                case BMP_AND:
293:               //                    video_buffer[i][first] &= ~(lmask^((*(bmp+(i-top)))>>(left%8)));
294:               //              //      video_buffer[i][last] &= ~(rmask^(*(bmp+(i-top)*awidth+awidth-1)));
295:               //                    if (width<8)
296:               //                        video_buffer[i][last]&=~(rmask^(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8));
297:               //                    else
298:               //                        video_buffer[i][last] &=~(rmask^(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8));
299:               //                    break;
300:               //                case BMP_XOR:
301:               //                    video_buffer[i][first] ^= (*(bmp+(i-top)*awidth+awidth-1))>>(left%8);
302:               //                    if (width<8)
303:               //                        video_buffer[i][last] ^=(*(bmp+(i-top)*awidth+awidth-1))<<(width-1-(left+width-1)%8);
304:               //                    else
305:               //                        video_buffer[i][last] ^=(*(bmp+(i-top)*awidth+awidth-1))<<(7-(left+width-1)%8);
306:               //                    break;
307:               //            }//switch
308:               //        }//for
309:               //        if (last>first+1){
310:               //            for (i=top;i<top+height;i++){
311:               //                for (j=first+1;j<last;j++){
312:               //                    switch(r2op){
313:               //                        case BMP_COPY:
314:               //                            video_buffer[i][j]= *(bmp+(i-top)*awidth+j);
315:               //                            break;
316:               //                        case BMP_OR:
317:               //                            video_buffer[i][j] |= *(bmp+(i-top)*awidth+j);
318:               //                            break;
319:               //                        case BMP_AND:
320:               //                            video_buffer[i][j] &= *(bmp+(i-top)*awidth+j);
321:               //                            break;
322:               //                        case BMP_XOR:
323:               //                            video_buffer[i][j] ^= *(bmp+(i-top)*awidth+j);
324:               //                            break;
325:               //                    }//switch
326:               //                }//for
327:               //            }//for
328:               //        }//if
329:               //    }
330:               }//f()
001B48  78074F     MOV [--W15], W14
001B4A  BE064F     MOV.D [--W15], W12
001B4C  BE054F     MOV.D [--W15], W10
001B4E  BE044F     MOV.D [--W15], W8
001B50  B100EF     SUB #0xE, W15
001B52  060000     RETURN
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/games/snake_text_mode/snake.c  ------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   snake.c
21:                 * Author: jacques Deschênes
22:                 * Description: snake game in text mode.
23:                 * Created on 5 mars 2014, 16:01
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include <time.h>
28:                #include "../../PICvision.h"
29:                
30:                typedef struct symbol{
31:                    unsigned char x;
32:                    unsigned char y;
33:                    char part;
34:                }symbol_t;
35:                
36:                #define SNAKE_MAX_LEN  64
37:                
38:                typedef struct snake_struct{
39:                    unsigned length;
40:                    unsigned calories;
41:                    unsigned lifespan;
42:                    unsigned short dx;
43:                    unsigned short dy;
44:                    symbol_t body[SNAKE_MAX_LEN];
45:                }snake_t;
46:                
47:                typedef struct msg_struct{
48:                    unsigned char x;
49:                    unsigned char y;
50:                    char *text;
51:                }msg_t;
52:                
53:                // snake some symbols
54:                #define RING  102+32
55:                #define HEAD_RIGHT  103+32
56:                #define HEAD_LEFT 104+32
57:                #define HEAD_UP  105+32
58:                #define HEAD_DOWN 106+32
59:                #define MOUSE 109+32
60:                
61:                #define BASE_METABOLISM 2   // calories lost per seconde
62:                #define MOUSE_CALORIES  20  // calories gain by eating mouse
63:                
64:                snake_t snake;
65:                
66:                symbol_t mouse;
67:                
68:                int run; // game exit when run==0
69:                
70:                const msg_t msgCALORIES={0,0,"calories: "};
71:                const msg_t msgSECONDS={16,0,"lifespan: "};
72:                const msg_t msgGAME_OVER={6,13,"game over"};
73:                const msg_t msgSTART={8,20, "press START to begin"};
74:                const msg_t msgQUIT={8,21,"X to quit game."};
75:                const msg_t msgSTARVATION={6,14,"died of starvation"};
76:                const msg_t msgWALL_COLLIDE={6,14,"died of wall collision"};
77:                const msg_t msgTAIL_BITE={6,14,"died of tail bite."};
78:                
79:                void print_msg(const msg_t msg){
001B54  BE9F88     MOV.D W8, [W15++]
001B56  BE0400     MOV.D W0, W8
80:                    set_curpos(msg.x,msg.y);
001B58  DE00C8     LSR W0, #8, W1
001B5A  FB8008     ZE W8, W0
001B5C  0703CF     RCALL set_curpos
81:                    print(msg.text);
001B5E  780009     MOV W9, W0
001B60  070350     RCALL print
82:                }//f()
001B62  BE044F     MOV.D [--W15], W8
001B64  060000     RETURN
83:                
84:                void new_mouse(){
001B66  BE9F88     MOV.D W8, [W15++]
001B68  781F8A     MOV W10, [W15++]
85:                    unsigned short i, collide,mouseX,mouseY;
86:                    collide=1;
87:                    while (collide){
88:                        mouseX=rand()%(CHAR_PER_LINE-3)+2;
001B6A  200209     MOV #0x20, W9
001B6E  07F602     RCALL 0x774
001B70  780401     MOV W1, W8
001B72  090011     REPEAT #0x11
001B74  D80009     DIV.SW W0, W9
001B76  FD0401     EXCH W1, W8
001B78  E88408     INC2 W8, W8
89:                        mouseY=rand()%(LINE_PER_SCREEN-3)+2;
001B7A  07F5FC     RCALL 0x774
001B7C  200184     MOV #0x18, W4
001B7E  090011     REPEAT #0x11
001B80  D80004     DIV.SW W0, W4
001B82  E88081     INC2 W1, W1
90:                        for (i=0;i<snake.length;i++){
001B6C  21EE2A     MOV #0x1EE2, W10
001B84  80F6C0     MOV snake, W0
001B86  500FE0     SUB W0, #0x0, [W15]
001B88  320010     BRA Z, 0x1BAA
001B8A  78020A     MOV W10, W4
001B8C  EB0280     CLR W5
001B9E  E80285     INC W5, W5
001BA0  420263     ADD W4, #0x3, W4
001BA2  528F80     SUB W5, W0, [W15]
001BA4  39FFF4     BRA NC, 0x1B8E
91:                            if ((mouseX==snake.body[i].x)&&(mouseY==snake.body[i].y)) break;
001B8E  784114     MOV.B [W4], W2
001B90  FB8302     ZE W2, W6
001B92  530F88     SUB W6, W8, [W15]
001B94  3A0004     BRA NZ, 0x1B9E
001B96  904314     MOV.B [W4+1], W6
001B98  FB8306     ZE W6, W6
001B9A  530F81     SUB W6, W1, [W15]
001B9C  320004     BRA Z, 0x1BA6
92:                        }
93:                        if (i==snake.length) collide=0;
001BA6  500F85     SUB W0, W5, [W15]
001BA8  3AFFE2     BRA NZ, 0x1B6E
94:                    }//while
95:                    mouse.x=mouseX;
001BAA  780008     MOV W8, W0
001BAC  B7FFA2     MOV.B WREG, mouse
96:                    mouse.y=mouseY;
001BAE  780001     MOV W1, W0
001BB0  B7FFA3     MOV.B WREG, 0x1FA3
97:                    set_curpos(mouse.x,mouse.y);
001BB2  FB8081     ZE W1, W1
001BB4  FB8008     ZE W8, W0
001BB6  0703A2     RCALL set_curpos
98:                    put_char(mouse.part);
001BB8  BFDFA4     MOV.B 0x1FA4, WREG
001BBA  070298     RCALL put_char
99:                }//f()
001BBC  78054F     MOV [--W15], W10
001BBE  BE044F     MOV.D [--W15], W8
001BC0  060000     RETURN
100:               
101:               void hide_snake(){
001BC2  BE9F88     MOV.D W8, [W15++]
001BC4  781F8A     MOV W10, [W15++]
102:                   unsigned i;
103:                   for (i=0;i<snake.length;i++){
001BC6  80F6C4     MOV snake, W4
001BC8  520FE0     SUB W4, #0x0, [W15]
001BCA  32000F     BRA Z, 0x1BEA
001BCC  21EE38     MOV #0x1EE3, W8
001BCE  EB0480     CLR W9
001BE0  E80489     INC W9, W9
001BE2  440463     ADD W8, #0x3, W8
001BE4  80F6C4     MOV snake, W4
001BE6  520F89     SUB W4, W9, [W15]
001BE8  3EFFF4     BRA GTU, 0x1BD2
104:                       set_curpos(snake.body[i].x,snake.body[i].y);
001BD2  784218     MOV.B [W8], W4
001BD4  FB8084     ZE W4, W1
001BD6  97F878     MOV.B [W8-1], W0
001BD8  FB8000     ZE W0, W0
001BDA  070390     RCALL set_curpos
105:                       put_char(SPACE);
001BD0  B3C20A     MOV #0x20, W10
001BDC  78400A     MOV.B W10, W0
001BDE  070286     RCALL put_char
106:                   }
107:               }//f()
001BEA  78054F     MOV [--W15], W10
001BEC  BE044F     MOV.D [--W15], W8
001BEE  060000     RETURN
108:               
109:               void show_snake(){
001BF0  BE9F88     MOV.D W8, [W15++]
110:                   unsigned i;
111:                   for (i=0;i<snake.length;i++){
001BF2  80F6C4     MOV snake, W4
001BF4  520FE0     SUB W4, #0x0, [W15]
001BF6  32000E     BRA Z, 0x1C14
001BF8  21EE38     MOV #0x1EE3, W8
001BFA  EB0480     CLR W9
001C0A  E80489     INC W9, W9
001C0C  440463     ADD W8, #0x3, W8
001C0E  80F6C4     MOV snake, W4
001C10  520F89     SUB W4, W9, [W15]
001C12  3EFFF4     BRA GTU, 0x1BFC
112:                       set_curpos(snake.body[i].x,snake.body[i].y);
001BFC  784218     MOV.B [W8], W4
001BFE  FB8084     ZE W4, W1
001C00  97F878     MOV.B [W8-1], W0
001C02  FB8000     ZE W0, W0
001C04  07037B     RCALL set_curpos
113:                       put_char(snake.body[i].part);
001C06  904018     MOV.B [W8+1], W0
001C08  070271     RCALL put_char
114:                       
115:                   }//for
116:               }//f()
001C14  BE044F     MOV.D [--W15], W8
001C16  060000     RETURN
117:               
118:               
119:               int wait_start_signal(){
001C18  BE9F88     MOV.D W8, [W15++]
120:                   unsigned p;
121:                   p=0;
122:                   print_msg(msgSTART);
001C1A  84A1A0     MOV 0x9434, W0
001C1C  84A1B1     MOV 0x9436, W1
001C1E  07FF9A     RCALL print_msg
123:                   print_msg(msgQUIT);
001C20  84A240     MOV 0x9448, W0
001C22  84A251     MOV 0x944A, W1
001C24  07FF97     RCALL print_msg
124:                   while (1){
125:                     p=read_paddle(PADDLE1);
001C26  200018     MOV #0x1, W8
001C2A  780008     MOV W8, W0
001C2C  07079E     RCALL read_paddle
126:                     if ((p&SNES_START)==SNES_START){
001C2E  600268     AND W0, #0x8, W4
001C30  3A0004     BRA NZ, 0x1C3A
127:                         return 1;
001C3A  200010     MOV #0x1, W0
128:                     }else if ((p&SNES_X)==SNES_X){
001C28  202009     MOV #0x200, W9
001C32  600009     AND W0, W9, W0
001C34  32FFFA     BRA Z, 0x1C2A
129:                         return 0;
001C36  EB0000     CLR W0
001C38  370001     BRA 0x1C3C
130:                     }
131:                   }
132:               }//f()
001C3C  BE044F     MOV.D [--W15], W8
001C3E  060000     RETURN
133:               
134:               void animate_death(){
001C40  BE9F88     MOV.D W8, [W15++]
001C42  BE9F8A     MOV.D W10, [W15++]
001C44  781F8C     MOV W12, [W15++]
001C52  B94B63     MUL.SU W9, #3, W6
001C54  21EE34     MOV #0x1EE3, W4
001C56  430404     ADD W6, W4, W8
135:                   int i,freq;
136:                   show_snake();
001C46  07FFD4     RCALL show_snake
137:                   freq=snake.length*200;
001C48  80F6C4     MOV snake, W4
001C4E  200C8A     MOV #0xC8, W10
001C50  B9A50A     MUL.SS W4, W10, W10
138:                   for (i=snake.length-1;i>=0;i--){
001C4A  E90484     DEC W4, W9
001C4C  330019     BRA N, 0x1C80
001C78  E90489     DEC W9, W9
001C7A  540463     SUB W8, #0x3, W8
001C7C  548FE0     SUB W9, #0x0, [W15]
001C7E  3DFFEE     BRA GE, 0x1C5C
139:                       set_curpos(snake.body[i].x,snake.body[i].y);
001C5C  784218     MOV.B [W8], W4
001C5E  FB8084     ZE W4, W1
001C60  97F878     MOV.B [W8-1], W0
001C62  FB8000     ZE W0, W0
001C64  07034B     RCALL set_curpos
140:                       put_char(32);
001C58  B3C20B     MOV #0x20, W11
001C66  78400B     MOV.B W11, W0
001C68  070241     RCALL put_char
141:                       tone(freq,250);
001C5A  200FAC     MOV #0xFA, W12
001C6A  78008C     MOV W12, W1
001C6C  78000A     MOV W10, W0
001C6E  070576     RCALL tone
142:                       wait_n_frame(frames_per_second/4);
001C70  80F650     MOV frames_per_second, W0
001C72  DE0042     LSR W0, #2, W0
001C74  0704C7     RCALL wait_n_frame
143:                       freq -= 100;
001C76  B1064A     SUB #0x64, W10
144:                   }//for
145:               }//f()
001C80  78064F     MOV [--W15], W12
001C82  BE054F     MOV.D [--W15], W10
001C84  BE044F     MOV.D [--W15], W8
001C86  060000     RETURN
146:               
147:               // dead cause
148:               typedef enum DEATH {STARVATION,WALL_COLLISION,TAIL_BITE} death_t;
149:               
150:               unsigned char reset=0;
151:               void game_over(death_t cause){
001C88  781F88     MOV W8, [W15++]
001C8A  780400     MOV W0, W8
152:                   animate_death();
001C8C  07FFD9     RCALL animate_death
153:                   print_msg(msgGAME_OVER);
001C8E  84A0D0     MOV 0x941A, W0
001C90  84A0E1     MOV 0x941C, W1
001C92  07FF60     RCALL print_msg
154:                   switch (cause){
001C94  540FE1     SUB W8, #0x1, [W15]
001C96  320008     BRA Z, 0x1CA8
001C98  390003     BRA NC, 0x1CA0
001C9A  540FE2     SUB W8, #0x2, [W15]
001C9C  3A000C     BRA NZ, 0x1CB6
001C9E  370008     BRA 0x1CB0
155:                       case STARVATION:
156:                           print_msg(msgSTARVATION);
001CA0  84A300     MOV 0x9460, W0
001CA2  84A311     MOV 0x9462, W1
001CA4  07FF57     RCALL print_msg
157:                           break;
001CA6  370007     BRA 0x1CB6
158:                       case WALL_COLLISION:
159:                           print_msg(msgWALL_COLLIDE);
001CA8  84A3E0     MOV 0x947C, W0
001CAA  84A3F1     MOV 0x947E, W1
001CAC  07FF53     RCALL print_msg
160:                           break;
001CAE  370003     BRA 0x1CB6
161:                       case TAIL_BITE:
162:                           print_msg(msgTAIL_BITE);
001CB0  84A4A0     MOV 0x9494, W0
001CB2  84A4B1     MOV 0x9496, W1
001CB4  07FF4F     RCALL print_msg
163:                           break;
164:                   }//switch
165:                   reset=1;
001CB6  B3C014     MOV #0x1, W4
001CB8  FD0200     EXCH W0, W4
001CBA  B7FFFC     MOV.B WREG, reset
001CBC  FD0200     EXCH W0, W4
166:                   if (!wait_start_signal()) run=0;
001CBE  07FFAC     RCALL wait_start_signal
001CC0  500FE0     SUB W0, #0x0, [W15]
001CC2  3A0001     BRA NZ, 0x1CC6
001CC4  EF3FA6     CLR run
167:               }//f()
001CC6  78044F     MOV [--W15], W8
001CC8  060000     RETURN
168:               
169:               void add_calories(unsigned short gain){
170:                   snake.calories+=gain;
001CCA  B43EDA     ADD 0x1EDA
171:                   print_msg(msgCALORIES);
001CCC  849FE0     MOV 0x93FC, W0
001CCE  849FF1     MOV 0x93FE, W1
001CD0  07FF41     RCALL print_msg
172:                   print_int(snake.calories,1);
001CD2  200011     MOV #0x1, W1
001CD4  80F6D0     MOV 0x1EDA, W0
001CD6  0702BA     RCALL print_int
173:               }//f()
001CD8  060000     RETURN
174:               
175:               
176:               void burn_calories(unsigned short lost){
177:                   unsigned newLength;
178:                   if (lost < BASE_METABOLISM) lost=BASE_METABOLISM;
001CDA  500FE1     SUB W0, #0x1, [W15]
001CDC  3E0001     BRA GTU, 0x1CE0
001CDE  200020     MOV #0x2, W0
179:                   snake.calories -= lost;
001CE0  B53EDA     SUB 0x1EDA
180:                   if (snake.calories<0) snake.calories=0;
181:                   print_msg(msgCALORIES);
001CE2  849FE0     MOV 0x93FC, W0
001CE4  849FF1     MOV 0x93FE, W1
001CE6  07FF36     RCALL print_msg
182:                   clear_eol();
001CE8  0702E8     RCALL clear_eol
183:                   print_int(snake.calories,1);
001CEA  200011     MOV #0x1, W1
001CEC  80F6D0     MOV 0x1EDA, W0
001CEE  0702AE     RCALL print_int
184:                   print_msg(msgSECONDS);
001CF0  84A060     MOV 0x940C, W0
001CF2  84A071     MOV 0x940E, W1
001CF4  07FF2F     RCALL print_msg
185:                   print_int(snake.lifespan,1);
001CF6  200011     MOV #0x1, W1
001CF8  80F6E0     MOV 0x1EDC, W0
001CFA  0702A8     RCALL print_int
186:                   hide_snake();
001CFC  07FF62     RCALL hide_snake
187:                   newLength=snake.calories/MOUSE_CALORIES+1;
001CFE  80F6D4     MOV 0x1EDA, W4
001D04  200145     MOV #0x14, W5
001D06  BE9F80     MOV.D W0, [W15++]
001D08  090011     REPEAT #0x11
001D0A  D88205     DIV.UW W4, W5
001D0C  780200     MOV W0, W4
001D0E  BE004F     MOV.D [--W15], W0
188:                   if (snake.calories){
001D00  520FE0     SUB W4, #0x0, [W15]
001D02  32000A     BRA Z, 0x1D18
189:                       snake.length=newLength+1;
001D10  E88204     INC2 W4, W4
001D12  88F6C4     MOV W4, snake
190:                       show_snake();
001D14  07FF6D     RCALL show_snake
001D16  370002     BRA 0x1D1C
191:                   } else{
192:                       game_over(STARVATION);
001D18  EB0000     CLR W0
001D1A  07FFB6     RCALL game_over
193:                       return;
194:                   }
195:               }//f()
001D1C  060000     RETURN
196:               
197:               void check_if_got_mouse(){
198:                   if ((mouse.x==snake.body[0].x) && (mouse.y==snake.body[0].y)){
001D1E  21EE24     MOV #0x1EE2, W4
001D20  784214     MOV.B [W4], W4
001D22  21FA25     MOV #0x1FA2, W5
001D24  784295     MOV.B [W5], W5
001D26  52CF84     SUB.B W5, W4, [W15]
001D28  3A006A     BRA NZ, 0x1DFE
001D2A  21EE34     MOV #0x1EE3, W4
001D2C  784214     MOV.B [W4], W4
001D2E  21FA35     MOV #0x1FA3, W5
001D30  784295     MOV.B [W5], W5
001D32  52CF84     SUB.B W5, W4, [W15]
001D34  3A0064     BRA NZ, 0x1DFE
199:                       add_calories(MOUSE_CALORIES);
001D36  200140     MOV #0x14, W0
001D38  07FFC8     RCALL add_calories
200:                       snake.length++;
001D3A  80F6C4     MOV snake, W4
001D3C  E80284     INC W4, W5
001D3E  88F6C5     MOV W5, snake
201:                       snake.body[snake.length-1].part=RING;
001D40  B92363     MUL.SU W4, #3, W6
001D42  B3C861     MOV #0x86, W1
001D44  21EE40     MOV #0x1EE4, W0
001D46  7B7001     MOV.B W1, [W0+W6]
202:                       if (snake.dx){
001D48  80F6F6     MOV 0x1EDE, W6
001D4A  530FE0     SUB W6, #0x0, [W15]
001D4C  32002D     BRA Z, 0x1DA8
203:                           if (snake.body[snake.length-2].y==snake.body[0].y){
001D4E  E98285     DEC2 W5, W5
001D50  B92863     MUL.SU W5, #3, W0
001D52  21EE27     MOV #0x1EE2, W7
001D54  400387     ADD W0, W7, W7
001D56  904017     MOV.B [W7+1], W0
001D58  21EE37     MOV #0x1EE3, W7
001D5A  784397     MOV.B [W7], W7
001D5C  504F87     SUB.B W0, W7, [W15]
001D5E  3A000C     BRA NZ, 0x1D78
204:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x-snake.dx;
001D60  B92063     MUL.SU W4, #3, W0
001D62  21EE24     MOV #0x1EE2, W4
001D64  420200     ADD W4, W0, W4
001D66  B92863     MUL.SU W5, #3, W0
001D68  4002EA     ADD W0, #0xA, W5
001D6A  21ED87     MOV #0x1ED8, W7
001D6C  7AC067     MOV.B [W7+W5], W0
001D6E  504A06     SUB.B W0, W6, [W4]
205:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
001D70  438285     ADD W7, W5, W5
001D72  904295     MOV.B [W5+1], W5
001D74  984215     MOV.B W5, [W4+1]
001D76  370042     BRA 0x1DFC
206:                           }else{
207:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001D78  B92063     MUL.SU W4, #3, W0
001D7A  B92B63     MUL.SU W5, #3, W6
001D7C  4302EA     ADD W6, #0xA, W5
001D7E  21ED86     MOV #0x1ED8, W6
001D80  4303EA     ADD W6, #0xA, W7
001D82  7AC166     MOV.B [W6+W5], W2
001D84  787382     MOV.B W2, [W7+W0]
208:                               if (snake.body[0].y>snake.body[snake.length-2].y){
001D86  430285     ADD W6, W5, W5
001D88  904295     MOV.B [W5+1], W5
001D8A  21EE36     MOV #0x1EE3, W6
001D8C  784316     MOV.B [W6], W6
001D8E  534F85     SUB.B W6, W5, [W15]
001D90  360005     BRA LEU, 0x1D9C
209:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y-1;
001D92  21EE24     MOV #0x1EE2, W4
001D94  420200     ADD W4, W0, W4
001D96  E94285     DEC.B W5, W5
001D98  984215     MOV.B W5, [W4+1]
001D9A  370030     BRA 0x1DFC
210:                               }else{
211:                                   snake.body[snake.length-1].y=snake.body[snake.length-2].y+1;
001D9C  B92363     MUL.SU W4, #3, W6
001D9E  21EE24     MOV #0x1EE2, W4
001DA0  420206     ADD W4, W6, W4
001DA2  E84285     INC.B W5, W5
001DA4  984215     MOV.B W5, [W4+1]
001DA6  37002A     BRA 0x1DFC
212:                               }//if
213:                           }//if
214:                       }else {
215:                           if (snake.body[snake.length-2].x==snake.body[0].x){
001DA8  E98285     DEC2 W5, W5
001DAA  B92B63     MUL.SU W5, #3, W6
001DAC  43036A     ADD W6, #0xA, W6
001DAE  21ED87     MOV #0x1ED8, W7
001DB0  7B43E7     MOV.B [W7+W6], W7
001DB2  21EE26     MOV #0x1EE2, W6
001DB4  784316     MOV.B [W6], W6
001DB6  53CF86     SUB.B W7, W6, [W15]
001DB8  3A000C     BRA NZ, 0x1DD2
216:                               snake.body[snake.length-1].x=snake.body[snake.length-2].x;
001DBA  B92063     MUL.SU W4, #3, W0
001DBC  21EE24     MOV #0x1EE2, W4
001DBE  420200     ADD W4, W0, W4
001DC0  784A07     MOV.B W7, [W4]
217:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y-snake.dy;
001DC2  B92863     MUL.SU W5, #3, W0
001DC4  21EE26     MOV #0x1EE2, W6
001DC6  400286     ADD W0, W6, W5
001DC8  904315     MOV.B [W5+1], W6
001DCA  80F705     MOV 0x1EE0, W5
001DCC  534285     SUB.B W6, W5, W5
001DCE  984215     MOV.B W5, [W4+1]
001DD0  370015     BRA 0x1DFC
218:                           }else{
219:                               snake.body[snake.length-1].y=snake.body[snake.length-2].y;
001DD2  B92063     MUL.SU W4, #3, W0
001DD4  21EE27     MOV #0x1EE2, W7
001DD6  438000     ADD W7, W0, W0
001DD8  B92963     MUL.SU W5, #3, W2
001DDA  4102EA     ADD W2, #0xA, W5
001DDC  21ED87     MOV #0x1ED8, W7
001DDE  438085     ADD W7, W5, W1
001DE0  904091     MOV.B [W1+1], W1
001DE2  984011     MOV.B W1, [W0+1]
220:                               if (snake.body[0].x>snake.body[snake.length-2].x){
001DE4  7AC2E7     MOV.B [W7+W5], W5
001DE6  534F85     SUB.B W6, W5, [W15]
001DE8  360005     BRA LEU, 0x1DF4
221:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x-1;
001DEA  B92363     MUL.SU W4, #3, W6
001DEC  21EE24     MOV #0x1EE2, W4
001DEE  420206     ADD W4, W6, W4
001DF0  E94A05     DEC.B W5, [W4]
001DF2  370004     BRA 0x1DFC
222:                               }else{
223:                                   snake.body[snake.length-1].x=snake.body[snake.length-2].x+1;
001DF4  B92363     MUL.SU W4, #3, W6
001DF6  21EE24     MOV #0x1EE2, W4
001DF8  420206     ADD W4, W6, W4
001DFA  E84A05     INC.B W5, [W4]
224:                               }//if
225:                           }//if
226:               
227:                       }//if
228:                       new_mouse();
001DFC  07FEB4     RCALL new_mouse
229:                   }
230:               }//f()
001DFE  060000     RETURN
231:               
232:               int bit_himself(){
233:                   int i;
234:                   for (i=1;i<snake.length;i++){
001E00  80F6C7     MOV snake, W7
001E04  538FE1     SUB W7, #0x1, [W15]
001E06  360011     BRA LEU, 0x1E2A
001E10  200015     MOV #0x1, W5
001E1C  E80285     INC W5, W5
001E1E  420263     ADD W4, #0x3, W4
001E20  538F85     SUB W7, W5, [W15]
001E22  3EFFF7     BRA GTU, 0x1E12
235:                       if ((snake.body[0].x==snake.body[i].x) &&(snake.body[0].y==snake.body[i].y)){
001E08  BFDEE2     MOV.B 0x1EE2, WREG
001E0A  21EE31     MOV #0x1EE3, W1
001E0C  784091     MOV.B [W1], W1
001E0E  21EE54     MOV #0x1EE5, W4
001E12  504F94     SUB.B W0, [W4], [W15]
001E14  3A0003     BRA NZ, 0x1E1C
001E16  904314     MOV.B [W4+1], W6
001E18  50CF86     SUB.B W1, W6, [W15]
001E1A  320006     BRA Z, 0x1E28
236:                           return 1;
001E28  200010     MOV #0x1, W0
237:                       }
238:                   }
239:                   return 0;
001E02  EB0000     CLR W0
001E24  EB0000     CLR W0
001E26  370001     BRA 0x1E2A
240:               }//f()
001E2A  060000     RETURN
241:               
242:               void move_snake(){
001E42  B92363     MUL.SU W4, #3, W6
001E44  21EE24     MOV #0x1EE2, W4
001E46  430204     ADD W6, W4, W4
001E48  21EDF5     MOV #0x1EDF, W5
243:                   unsigned i;
244:                   if (!(snake.dx || snake.dy)) return;
001E2C  80F6F4     MOV 0x1EDE, W4
001E2E  520FE0     SUB W4, #0x0, [W15]
001E30  3A0003     BRA NZ, 0x1E38
001E32  80F704     MOV 0x1EE0, W4
001E34  520FE0     SUB W4, #0x0, [W15]
001E36  32002F     BRA Z, 0x1E96
245:                   hide_snake();
001E38  07FEC4     RCALL hide_snake
246:                   for (i=snake.length-1;i;i--){
001E3A  80F6C4     MOV snake, W4
001E3C  520FE1     SUB W4, #0x1, [W15]
001E3E  32000C     BRA Z, 0x1E58
001E54  520F85     SUB W4, W5, [W15]
001E56  3AFFF9     BRA NZ, 0x1E4A
247:                       snake.body[i].x = snake.body[i-1].x;
001E40  E98204     DEC2 W4, W4
001E4A  784314     MOV.B [W4], W6
001E4C  984236     MOV.B W6, [W4+3]
248:                       snake.body[i].y = snake.body[i-1].y;
001E4E  904314     MOV.B [W4+1], W6
001E50  984246     MOV.B W6, [W4+4]
001E52  520263     SUB W4, #0x3, W4
249:                   }
250:                   snake.body[0].x += snake.dx;
001E58  80F6F5     MOV 0x1EDE, W5
001E5A  21EE24     MOV #0x1EE2, W4
001E5C  42C294     ADD.B W5, [W4], W5
001E5E  FD0280     EXCH W0, W5
001E60  B7FEE2     MOV.B WREG, 0x1EE2
001E62  FD0280     EXCH W0, W5
251:                   snake.body[0].y += snake.dy;
001E64  80F704     MOV 0x1EE0, W4
001E66  21EE36     MOV #0x1EE3, W6
001E68  424216     ADD.B W4, [W6], W4
001E6A  FD0200     EXCH W0, W4
001E6C  B7FEE3     MOV.B WREG, 0x1EE3
001E6E  FD0200     EXCH W0, W4
252:                   if ((snake.body[0].x<1)||(snake.body[0].x>=(CHAR_PER_LINE)) ||
001E70  E94285     DEC.B W5, W5
001E72  B3C216     MOV #0x21, W6
001E74  52CF86     SUB.B W5, W6, [W15]
001E76  3E0004     BRA GTU, 0x1E80
001E78  524FE1     SUB.B W4, #0x1, [W15]
001E7A  360002     BRA LEU, 0x1E80
253:                       (snake.body[0].y<2) || (snake.body[0].y>=LINE_PER_SCREEN-1)){
001E7C  524FF9     SUB.B W4, #0x19, [W15]
001E7E  360003     BRA LEU, 0x1E86
254:                       game_over(WALL_COLLISION);
001E80  200010     MOV #0x1, W0
001E82  07FF02     RCALL game_over
001E84  370008     BRA 0x1E96
255:                   }else if (bit_himself()){
001E86  07FFBC     RCALL bit_himself
001E88  500FE0     SUB W0, #0x0, [W15]
001E8A  320003     BRA Z, 0x1E92
256:                       game_over(TAIL_BITE);
001E8C  200020     MOV #0x2, W0
001E8E  07FEFC     RCALL game_over
001E90  370002     BRA 0x1E96
257:                   }else{
258:                       check_if_got_mouse();
001E92  07FF45     RCALL check_if_got_mouse
259:                       show_snake();
001E94  07FEAD     RCALL show_snake
260:                   }//if
261:               }//f()
001E96  060000     RETURN
262:               
263:               void game_info(){
264:                   clear_screen();
001E98  0701AD     RCALL clear_screen
265:                   print("**************\r");
001E9A  292DC0     MOV #0x92DC, W0
001E9C  0701B2     RCALL print
266:                   print("* SNAKE GAME *\r");
001E9E  292EC0     MOV #0x92EC, W0
001EA0  0701B0     RCALL print
267:                   print("**************\r\r");
001EA2  292FC0     MOV #0x92FC, W0
001EA4  0701AE     RCALL print
268:                   print("Eating a mouse increase snake length.\r");
001EA6  2930D0     MOV #0x930D, W0
001EA8  0701AC     RCALL print
269:                   print("Snake burn 10% of is calaries/sec.\r");
001EAA  293340     MOV #0x9334, W0
001EAC  0701AA     RCALL print
270:                   print("Die of starvation when calories=0.\r");
001EAE  293580     MOV #0x9358, W0
001EB0  0701A8     RCALL print
271:                   print("Eating a mouse give 20 calories.\r");
001EB2  2937C0     MOV #0x937C, W0
001EB4  0701A6     RCALL print
272:                   print("Die when hitting wall.\r");
001EB6  2939E0     MOV #0x939E, W0
001EB8  0701A4     RCALL print
273:                   print("Die when bitting his tail.\r\r");
001EBA  293B60     MOV #0x93B6, W0
001EBC  0701A2     RCALL print
274:                   print("Use ARROWS to control snake.\r");
001EBE  293D30     MOV #0x93D3, W0
001EC0  0701A0     RCALL print
275:                   run=wait_start_signal();
001EC2  07FEAA     RCALL wait_start_signal
001EC4  88FD30     MOV W0, run
276:               }//f()
001EC6  060000     RETURN
277:               
278:               void game_init(){
001EC8  781F88     MOV W8, [W15++]
279:                   reset=0;
001ECA  EF7FFC     CLR.B reset
280:                   srand(time(0));
001ECC  EB0000     CLR W0
001ECE  07F1E6     RCALL 0x29C
001ED0  07F44A     RCALL 0x766
281:                   //snake initialisation
282:                   snake.dx=0;
001ED2  EB0400     CLR W8
001ED4  88F6F8     MOV W8, 0x1EDE
283:                   snake.dy=0;
001ED6  88F708     MOV W8, 0x1EE0
284:                   snake.length=2;
001ED8  200024     MOV #0x2, W4
001EDA  88F6C4     MOV W4, snake
285:                   snake.calories=MOUSE_CALORIES;
001EDC  200144     MOV #0x14, W4
001EDE  88F6D4     MOV W4, 0x1EDA
286:                   snake.lifespan=0;
001EE0  88F6E8     MOV W8, 0x1EDC
287:                   snake.body[0].x=12;
001EE2  B3C0C4     MOV #0xC, W4
001EE4  FD0200     EXCH W0, W4
001EE6  B7FEE2     MOV.B WREG, 0x1EE2
001EE8  B7FEE3     MOV.B WREG, 0x1EE3
001EEA  FD0200     EXCH W0, W4
288:                   snake.body[0].y=12;
289:                   snake.body[0].part=HEAD_RIGHT;
001EEC  B3C875     MOV #0x87, W5
001EEE  FD0280     EXCH W0, W5
001EF0  B7FEE4     MOV.B WREG, 0x1EE4
001EF2  FD0280     EXCH W0, W5
290:                   snake.body[1].x=11;
001EF4  B3C0B5     MOV #0xB, W5
001EF6  FD0280     EXCH W0, W5
001EF8  B7FEE5     MOV.B WREG, 0x1EE5
001EFA  FD0280     EXCH W0, W5
291:                   snake.body[1].y=12;
001EFC  FD0200     EXCH W0, W4
001EFE  B7FEE6     MOV.B WREG, 0x1EE6
001F00  FD0200     EXCH W0, W4
292:                   snake.body[1].part=RING;
001F02  B3C864     MOV #0x86, W4
001F04  FD0200     EXCH W0, W4
001F06  B7FEE7     MOV.B WREG, 0x1EE7
001F08  FD0200     EXCH W0, W4
293:                   mouse.part=MOUSE;
001F0A  424267     ADD.B W4, #0x7, W4
001F0C  FD0200     EXCH W0, W4
001F0E  B7FFA4     MOV.B WREG, 0x1FA4
001F10  FD0200     EXCH W0, W4
294:                   clear_screen();
001F12  070170     RCALL clear_screen
295:                   print_msg(msgCALORIES);
001F14  849FE0     MOV 0x93FC, W0
001F16  849FF1     MOV 0x93FE, W1
001F18  07FE1D     RCALL print_msg
296:                   print_int(snake.calories,1);
001F1A  200011     MOV #0x1, W1
001F1C  80F6D0     MOV 0x1EDA, W0
001F1E  070196     RCALL print_int
297:                   print_msg(msgSECONDS);
001F20  84A060     MOV 0x940C, W0
001F22  84A071     MOV 0x940E, W1
001F24  07FE17     RCALL print_msg
298:                   print_int(snake.lifespan,1);
001F26  200011     MOV #0x1, W1
001F28  80F6E0     MOV 0x1EDC, W0
001F2A  070190     RCALL print_int
299:                   //draw  borders
300:                   rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001F2C  200014     MOV #0x1, W4
001F2E  200D73     MOV #0xD7, W3
001F30  780103     MOV W3, W2
001F32  200081     MOV #0x8, W1
001F34  780008     MOV W8, W0
001F36  07FB6A     RCALL rectangle
301:                   new_mouse();
001F38  07FE16     RCALL new_mouse
302:                   show_snake();
001F3A  07FE5A     RCALL show_snake
303:               }//f()
001F3C  78044F     MOV [--W15], W8
001F3E  060000     RETURN
304:               
305:               
306:               void snake_game_tm(void) {
001F40  BE9F88     MOV.D W8, [W15++]
001F42  781F8A     MOV W10, [W15++]
307:                   unsigned p,frame_count;
308:                   game_info();
001F44  07FFA9     RCALL game_info
309:                   game_init();
001F46  07FFC0     RCALL game_init
310:                   frame_count=0;
001F48  EB0400     CLR W8
311:                   while (run){
001F4E  370056     BRA 0x1FFC
001FFC  80FD34     MOV run, W4
001FFE  520FE0     SUB W4, #0x0, [W15]
002000  3AFFA7     BRA NZ, 0x1F50
312:                       wait_n_frame(10);
001F50  2000A0     MOV #0xA, W0
001F52  070358     RCALL wait_n_frame
313:                       frame_count += 10;
001F54  44046A     ADD W8, #0xA, W8
314:                       if (frame_count%frames_per_second==0){
001F56  80F654     MOV frames_per_second, W4
001F58  BE9F80     MOV.D W0, [W15++]
001F5A  090011     REPEAT #0x11
001F5C  D88404     DIV.UW W8, W4
001F5E  780201     MOV W1, W4
001F60  BE004F     MOV.D [--W15], W0
001F62  520FE0     SUB W4, #0x0, [W15]
001F64  3A000E     BRA NZ, 0x1F82
315:                           snake.lifespan +=1;
001F66  EC3EDC     INC 0x1EDC
316:                           burn_calories(snake.calories / 10);
001F68  80F6D0     MOV 0x1EDA, W0
001F6A  2000A4     MOV #0xA, W4
001F6C  781F81     MOV W1, [W15++]
001F6E  090011     REPEAT #0x11
001F70  D88004     DIV.UW W0, W4
001F72  7800CF     MOV [--W15], W1
001F74  07FEB2     RCALL burn_calories
317:                           rectangle(0,CHAR_HEIGHT,HPIXELS-1,VPIXELS-1,WHITE);
001F76  200014     MOV #0x1, W4
001F78  200D73     MOV #0xD7, W3
001F7A  780103     MOV W3, W2
001F7C  200081     MOV #0x8, W1
001F7E  EB0000     CLR W0
001F80  07FB45     RCALL rectangle
318:                       }
319:                       p=read_paddle(PADDLE1);
001F82  200010     MOV #0x1, W0
001F84  0705F2     RCALL read_paddle
320:                       switch (p){
001F4A  200209     MOV #0x20, W9
001F86  500F89     SUB W0, W9, [W15]
001F88  32002A     BRA Z, 0x1FDE
001F8A  3E0003     BRA GTU, 0x1F92
001F8C  500FF0     SUB W0, #0x10, [W15]
001F8E  3A0030     BRA NZ, 0x1FF0
001F90  37001C     BRA 0x1FCA
001F92  200404     MOV #0x40, W4
001F94  500F84     SUB W0, W4, [W15]
001F96  320004     BRA Z, 0x1FA0
001F98  200804     MOV #0x80, W4
001F9A  500F84     SUB W0, W4, [W15]
001F9C  3A0029     BRA NZ, 0x1FF0
001F9E  37000A     BRA 0x1FB4
321:                           case SNES_LEFT:
322:                               if (snake.dx==1){
001FA0  80F6F4     MOV 0x1EDE, W4
001FA2  520FE1     SUB W4, #0x1, [W15]
001FA4  320025     BRA Z, 0x1FF0
323:                                   break;
324:                               }
325:                               snake.dx =-1;
001FA6  EFBEDE     SETM 0x1EDE
326:                               snake.dy=0;
001FA8  EF3EE0     CLR 0x1EE0
327:                               snake.body[0].part=HEAD_LEFT;
001FAA  B3C884     MOV #0x88, W4
001FAC  FD0200     EXCH W0, W4
001FAE  B7FEE4     MOV.B WREG, 0x1EE4
001FB0  FD0200     EXCH W0, W4
328:                               break;
001FB2  37001E     BRA 0x1FF0
329:                           case SNES_RIGHT:
330:                               if (snake.dx==-1){
001FB4  80F6F4     MOV 0x1EDE, W4
001FB6  420FE1     ADD W4, #0x1, [W15]
001FB8  32001B     BRA Z, 0x1FF0
331:                                   break;
332:                               }
333:                               snake.dx=1;
001FBA  200014     MOV #0x1, W4
001FBC  88F6F4     MOV W4, 0x1EDE
334:                               snake.dy=0;
001FBE  EF3EE0     CLR 0x1EE0
335:                               snake.body[0].part=HEAD_RIGHT;
001FC0  B3C874     MOV #0x87, W4
001FC2  FD0200     EXCH W0, W4
001FC4  B7FEE4     MOV.B WREG, 0x1EE4
001FC6  FD0200     EXCH W0, W4
336:                               break;
001FC8  370013     BRA 0x1FF0
337:                           case SNES_UP:
338:                               if (snake.dy==1){
001FCA  80F704     MOV 0x1EE0, W4
001FCC  520FE1     SUB W4, #0x1, [W15]
001FCE  320010     BRA Z, 0x1FF0
339:                                   break;
340:                               }
341:                               snake.dy=-1;
001FD0  EFBEE0     SETM 0x1EE0
342:                               snake.dx=0;
001FD2  EF3EDE     CLR 0x1EDE
343:                               snake.body[0].part=HEAD_UP;
001FD4  B3C894     MOV #0x89, W4
001FD6  FD0200     EXCH W0, W4
001FD8  B7FEE4     MOV.B WREG, 0x1EE4
001FDA  FD0200     EXCH W0, W4
344:                               break;
001FDC  370009     BRA 0x1FF0
345:                           case SNES_DOWN:
346:                               if (snake.dy==-1){
001FDE  80F704     MOV 0x1EE0, W4
001FE0  420FE1     ADD W4, #0x1, [W15]
001FE2  320006     BRA Z, 0x1FF0
347:                                   break;
348:                               }
349:                               snake.dy=1;
001FE4  200014     MOV #0x1, W4
001FE6  88F704     MOV W4, 0x1EE0
350:                               snake.dx=0;
001FE8  EF3EDE     CLR 0x1EDE
351:                               snake.body[0].part=HEAD_DOWN;
001F4C  B3C8AA     MOV #0x8A, W10
001FEA  FD0500     EXCH W0, W10
001FEC  B7FEE4     MOV.B WREG, 0x1EE4
001FEE  FD0500     EXCH W0, W10
352:                               break;
353:                       }//switch
354:                       move_snake();
001FF0  07FF1D     RCALL move_snake
355:                       if (reset) game_init();
001FF2  21FFC4     MOV #0x1FFC, W4
001FF4  784214     MOV.B [W4], W4
001FF6  524FE0     SUB.B W4, #0x0, [W15]
001FF8  320001     BRA Z, 0x1FFC
001FFA  07FF66     RCALL game_init
356:                   }//while
357:                   clear_screen();
002002  0700F8     RCALL clear_screen
358:               }//snake_game_tm()
002004  78054F     MOV [--W15], W10
002006  BE044F     MOV.D [--W15], W8
002008  060000     RETURN
359:               
360:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/audio/sound.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   sound.c
21:                 * Author: jacques Deschênes
22:                 * Description:  sound generation using PWM D.A.C.
23:                 * Created on 25 février 2014, 16:43
24:                 */
25:                
26:                #include <stdlib.h>
27:                #include "sound.h"
28:                
29:                #define F_TONE  1  // tone playing flag
30:                #define F_TUNE  2  // flag tune playing
31:                #define F_WHITE 4  // white noise generation
32:                
33:                #define mTone_off() (AUDIOCON.OCM=0)
34:                #define mTone_on()  (AUDIOCON.OCM=5)
35:                
36:                
37:                volatile unsigned char fSound=0; // boolean flags
38:                volatile int tmrId;  // duratio timer identifier
39:                volatile unsigned int *tones_list;  // list of tones and interval for playing tune
40:                int tick_msec=10; // tick interval in milliseconds, default 10msec.
41:                
42:                void cb_tone(void){ // timer call back function
43:                    mTone_off();
002724  800C54     MOV OC2CON, W4
002726  A10004     BCLR W4, #0
002728  A11004     BCLR W4, #1
00272A  A12004     BCLR W4, #2
00272C  880C54     MOV W4, OC2CON
44:                    fSound &= ~(F_TONE|F_WHITE);
00272E  21FF45     MOV #0x1FF4, W5
002730  784295     MOV.B [W5], W5
002732  B3CFA4     MOV #0xFA, W4
002734  62C204     AND.B W5, W4, W4
002736  780004     MOV W4, W0
002738  B7FFF4     MOV.B WREG, fSound
45:                }// f()
00273A  060000     RETURN
46:                
47:                void sound_init(int tick_time){
48:                    if (tick_time) tick_msec=tick_time;
00273C  500FE0     SUB W0, #0x0, [W15]
00273E  320001     BRA Z, 0x2742
002740  88FFB0     MOV W0, tick_msec
49:                    tmrId=create_timer(1,TIMER_SINGLE,(timer_handler_t *)cb_tone);
002742  227242     MOV #0x2724, W2
002744  EB0080     CLR W1
002746  200010     MOV #0x1, W0
002748  07FE84     RCALL create_timer
00274A  88FFC0     MOV W0, tmrId
50:                    AUDIOCON.OCTSEL=1; // select OCx timer
00274C  A8618A     BSET OC2CON, #3
51:                    AUDIOR=0;
00274E  EF2188     CLR OC2R
52:                    AUDIOTMR.TON=0;
002750  A9E113     BCLR 0x113, #7
53:                    AUDIOTMR.TCKPS=1; // 1:8  // timer clock prescale divisor
002752  800894     MOV T3CON, W4
002754  A04004     BSET W4, #4
002756  A15004     BCLR W4, #5
002758  880894     MOV W4, T3CON
54:                }//f()
00275A  060000     RETURN
55:                
56:                // play tone in background
57:                void tone(unsigned freq, // frequency in hertz
58:                          unsigned msec){ // duration in  milliseconds
00275C  BE9F88     MOV.D W8, [W15++]
00275E  781F8A     MOV W10, [W15++]
002760  780501     MOV W1, W10
59:                    //
60:                    mTone_off(); 
002762  800C54     MOV OC2CON, W4
002764  A10004     BCLR W4, #0
002766  A11004     BCLR W4, #1
002768  A12004     BCLR W4, #2
00276A  880C54     MOV W4, OC2CON
61:                    AUDIORS=FCY/16/freq; // determine tone duty cycle
00276C  B80461     MUL.UU W0, #1, W8
00276E  BE0108     MOV.D W8, W2
002770  242400     MOV #0x4240, W0
002772  2000F1     MOV #0xF, W1
002774  07EEA9     RCALL 0x4C8
002776  880C30     MOV W0, OC2RS
62:                    AUDIOTMR.TON=0;
002778  A9E113     BCLR 0x113, #7
63:                    AUDIOPR=(FCY/8/freq)-1; // pwm period
00277A  BE0108     MOV.D W8, W2
00277C  284800     MOV #0x8480, W0
00277E  2001E1     MOV #0x1E, W1
002780  07EEA3     RCALL 0x4C8
002782  E90200     DEC W0, W4
002784  880874     MOV W4, PR3
64:                    fSound |=F_TONE;
002786  A81FF4     BSET fSound, #0
65:                    mTone_on(); 
002788  800C54     MOV OC2CON, W4
00278A  A00004     BSET W4, #0
00278C  A11004     BCLR W4, #1
00278E  A02004     BSET W4, #2
002790  880C54     MOV W4, OC2CON
66:                    AUDIOTMR.TON=1;
002792  A8E113     BSET 0x113, #7
67:                    update_timer(tmrId,msec/tick_msec);
002794  80FFC0     MOV tmrId, W0
002796  80FFB4     MOV tick_msec, W4
002798  781F80     MOV W0, [W15++]
00279A  090011     REPEAT #0x11
00279C  D88504     DIV.UW W10, W4
00279E  780080     MOV W0, W1
0027A0  78004F     MOV [--W15], W0
0027A2  07FE9C     RCALL update_timer
68:                    start_timer(tmrId);
0027A4  80FFC0     MOV tmrId, W0
0027A6  07FE88     RCALL start_timer
69:                } //tone();
0027A8  78054F     MOV [--W15], W10
0027AA  BE044F     MOV.D [--W15], W8
0027AC  060000     RETURN
70:                
71:                // play tune in background
72:                void tune(const unsigned *buffer){
73:                    tones_list=(unsigned *)buffer;
0027AE  88FFD0     MOV W0, tones_list
74:                    if (*tones_list && *(tones_list+1)){
0027B0  EB0200     CLR W4
0027B2  120F90     SUBR W4, [W0], [W15]
0027B4  32000C     BRA Z, 0x27CE
0027B6  780200     MOV W0, W4
0027B8  EB0280     CLR W5
0027BA  128FD4     SUBR W5, [++W4], [W15]
0027BC  320008     BRA Z, 0x27CE
75:                        fSound |= F_TUNE;
0027BE  A83FF4     BSET fSound, #1
76:                        AUDIOIF=0;
0027C0  A90085     BCLR 0x85, #0
77:                        AUDIOIE=1;
0027C2  A80095     BSET 0x95, #0
78:                        tone(*tones_list++,*tones_list++);
0027C4  780090     MOV [W0], W1
0027C6  88FFD4     MOV W4, tones_list
0027C8  780034     MOV [W4++], W0
0027CA  88FFD4     MOV W4, tones_list
0027CC  07FFC7     RCALL tone
79:                    }
80:                }//tune()
0027CE  060000     RETURN
81:                
82:                
83:                void white_noise(unsigned msec){
84:                    if (!fSound){
0027D0  21FF44     MOV #0x1FF4, W4
0027D2  784214     MOV.B [W4], W4
0027D4  524FE0     SUB.B W4, #0x0, [W15]
0027D6  3A0010     BRA NZ, 0x27F8
85:                        AUDIOTMR.TON=0;
0027D8  A9E113     BCLR 0x113, #7
86:                        AUDIOPR=(FCY/8/10000)-1; // pwm period
0027DA  200C74     MOV #0xC7, W4
0027DC  880874     MOV W4, PR3
87:                        AUDIOTMR.TON=0;
0027DE  A9E113     BCLR 0x113, #7
88:                        AUDIOIF=0;
0027E0  A90085     BCLR 0x85, #0
89:                        AUDIOIE=1;
0027E2  A80095     BSET 0x95, #0
90:                        AUDIOTMR.TON=1;
0027E4  A8E113     BSET 0x113, #7
91:                        update_timer(tmrId,msec/tick_msec);
0027E6  80FFC4     MOV tmrId, W4
0027E8  80FFB5     MOV tick_msec, W5
0027EA  090011     REPEAT #0x11
0027EC  D88005     DIV.UW W0, W5
0027EE  FD0080     EXCH W0, W1
0027F0  780004     MOV W4, W0
0027F2  07FE74     RCALL update_timer
92:                        start_timer(tmrId);
0027F4  80FFC0     MOV tmrId, W0
0027F6  07FE60     RCALL start_timer
93:                    }
94:                    fSound |= F_WHITE;
0027F8  A85FF4     BSET fSound, #2
95:                }// f()
0027FA  060000     RETURN
96:                
97:                void while_sound(){
98:                    while (fSound);
0027FC  21FF44     MOV #0x1FF4, W4
0027FE  784214     MOV.B [W4], W4
002800  524FE0     SUB.B W4, #0x0, [W15]
002802  3AFFFC     BRA NZ, while_sound
99:                }// f()
002804  060000     RETURN
100:               
101:               // interrupt at end of tone cycle
102:               void __attribute__((interrupt, no_auto_psv))  _AUDIO_ISR(void){
002806  F80036     PUSH RCOUNT
002808  BE9F80     MOV.D W0, [W15++]
00280A  BE9F82     MOV.D W2, [W15++]
00280C  BE9F84     MOV.D W4, [W15++]
00280E  BE9F86     MOV.D W6, [W15++]
103:                  unsigned int f,d;
104:                  if (fSound&F_WHITE){
002810  21FF44     MOV #0x1FF4, W4
002812  784214     MOV.B [W4], W4
002814  620264     AND W4, #0x4, W4
002816  320007     BRA Z, 0x2826
105:                      P_NOISE_OUT=rand()&1;
002818  07EFAD     RCALL 0x774
00281A  6002E1     AND W0, #0x1, W5
00281C  DD2ACA     SL W5, #10, W5
00281E  801664     MOV LATB, W4
002820  A1A004     BCLR W4, #10
002822  720205     IOR W4, W5, W4
002824  881664     MOV W4, LATB
106:                  }
107:                  if (!fSound) {
002826  21FF44     MOV #0x1FF4, W4
002828  784214     MOV.B [W4], W4
00282A  524FE0     SUB.B W4, #0x0, [W15]
00282C  3A0003     BRA NZ, 0x2834
108:                      AUDIOIE=0;
00282E  A90095     BCLR 0x95, #0
109:                      AUDIOTMR.TON=0;
002830  A9E113     BCLR 0x113, #7
002832  370027     BRA 0x2882
110:                  }else if (fSound==(fSound & F_TUNE)){
002834  21FF45     MOV #0x1FF4, W5
002836  784295     MOV.B [W5], W5
002838  21FF44     MOV #0x1FF4, W4
00283A  784214     MOV.B [W4], W4
00283C  FB8285     ZE W5, W5
00283E  620262     AND W4, #0x2, W4
002840  528F84     SUB W5, W4, [W15]
002842  3A001F     BRA NZ, 0x2882
111:                      f=*tones_list++;
002844  80FFD4     MOV tones_list, W4
002846  780034     MOV [W4++], W0
002848  88FFD4     MOV W4, tones_list
112:                      d=*tones_list++;
00284A  7800B4     MOV [W4++], W1
00284C  88FFD4     MOV W4, tones_list
113:                      if (d){
00284E  508FE0     SUB W1, #0x0, [W15]
002850  320015     BRA Z, 0x287C
114:                           if (f){
002852  500FE0     SUB W0, #0x0, [W15]
002854  320002     BRA Z, 0x285A
115:                               tone(f,d);
002856  07FF82     RCALL tone
002858  370014     BRA 0x2882
116:                           }else{
117:                               update_timer(tmrId,d/tick_msec);
00285A  80FFC0     MOV tmrId, W0
00285C  80FFB4     MOV tick_msec, W4
00285E  781F80     MOV W0, [W15++]
002860  090011     REPEAT #0x11
002862  D88084     DIV.UW W1, W4
002864  780080     MOV W0, W1
002866  78004F     MOV [--W15], W0
002868  07FE39     RCALL update_timer
118:                               start_timer(tmrId);
00286A  80FFC0     MOV tmrId, W0
00286C  07FE25     RCALL start_timer
119:                               fSound |= F_TONE;
00286E  A81FF4     BSET fSound, #0
120:                               mTone_on();
002870  800C54     MOV OC2CON, W4
002872  A00004     BSET W4, #0
002874  A11004     BCLR W4, #1
002876  A02004     BSET W4, #2
002878  880C54     MOV W4, OC2CON
00287A  370003     BRA 0x2882
121:                           }
122:                      }else{
123:                          fSound=0;
00287C  EF7FF4     CLR.B fSound
124:                          AUDIOIE=0;
00287E  A90095     BCLR 0x95, #0
125:                          AUDIOTMR.TON=0;
002880  A9E113     BCLR 0x113, #7
126:                      } // if
127:                  }
128:                  AUDIOIF=0;
002882  A90085     BCLR 0x85, #0
129:               }// _AUDIO_ISR
002884  BE034F     MOV.D [--W15], W6
002886  BE024F     MOV.D [--W15], W4
002888  BE014F     MOV.D [--W15], W2
00288A  BE004F     MOV.D [--W15], W0
00288C  F90036     POP RCOUNT
00288E  064000     RETFIE
130:               
131:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/TVout/TVout.c  ----------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   TVout.c
21:                 * Author: jacques Deschênes
22:                 * Description:  NTSC/PAL signal generator
23:                 * NTSC REF: http://www.ntsc-tv.com/ntsc-index-02.htm
24:                 * NTSC/PAL/SECAM REF: http://www.videointerchange.com/pal_secam_conversions.htm
25:                 * Created on 25 février 2014, 16:28
26:                 */
27:                
28:                #include <stdio.h>
29:                #include <stdlib.h>
30:                #include <string.h>
31:                #include "TVout.h"
32:                
33:                // NTSC composite signal parameters
34:                #define NTSC_LINES_PER_FRAME (525/2) // progressive scan
35:                #define NTSC_FRAMES_PER_SECOND 60
36:                #define NTSC_LINE_PERIOD  (63.5*FCY/MHZ) // horizontal line period 63,5µsec
37:                #define NTSC_FRONT_PORCH (1.5*FCY/MHZ)
38:                #define NTSC_HPULSE (4.7*FCY/MHZ)
39:                #define NTSC_FIRST_VISIBLE  30
40:                #define NTSC_LAST_VISIBLE (NTSC_FIRST_VISIBLE+VPIXELS)
41:                #define NTSC_VIDEO_DELAY (2*NTSC_HPULSE+40)
42:                
43:                // PAL composite signal parameters
44:                #define PAL_LINES_PER_FRAME (625/2)  // progressive scan
45:                #define PAL_FRAMES_PER_SECOND 50
46:                #define PAL_LINE_PERIOD (64*FCY/MHZ)  // horizontal line period 64µsec
47:                #define PAL_FRONT_PORCH (1.6*FCY/MHZ)
48:                #define PAL_HPULSE (4.7*FCY/MHZ)
49:                #define PAL_FIRST_VISIBLE  55
50:                #define PAL_LAST_VISIBLE (PAL_FIRST_VISIBLE+VPIXELS)
51:                #define PAL_VIDEO_DELAY (2*PAL_HPULSE+45)
52:                
53:                #define NTSC_MODE 0
54:                #define PAL_MODE 1
55:                
56:                #define F_PCHAR 1    // flag put_char() pending
57:                #define F_CLEAR 2    // flag clear_screen() pending
58:                #define F_CLREOL 4   // flag clear to end of line
59:                #define F_RETRACE 8  // flag screen in retrace phase
60:                #define F_BLANK 16   // flag keep screen blank
61:                
62:                unsigned frames_per_second;
63:                static unsigned int frame_line_cntr=0; // count line in video frame
64:                volatile static unsigned long frame_cntr=0; // number of frame since reset
65:                volatile static unsigned int flags;
66:                
67:                
68:                char video_buffer[VPIXELS][BYTES_PER_LINE];
69:                int vsync, hsync, video_mode;
70:                
71:                void ntsc_init(){
72:                    VIDPR = NTSC_LINE_PERIOD;  // video timer PRx SFR
002588  203F85     MOV #0x3F8, W5
00258A  880865     MOV W5, PR2
73:                    VSYNCR= NTSC_HPULSE;       // video OCxR  SFR
00258C  2004B4     MOV #0x4B, W4
00258E  880C14     MOV W4, OC1R
74:                    VSYNCRS=NTSC_LINE_PERIOD;  // video OCxRS SFR
002590  880C05     MOV W5, OC1RS
75:                    VDLYR=NTSC_VIDEO_DELAY;     // video delay OCxR SFR
002592  200BE5     MOV #0xBE, W5
002594  880CA5     MOV W5, OC4R
76:                    VDLYRS=NTSC_LINE_PERIOD-NTSC_FRONT_PORCH;  // video delay OCxRS SFR
002596  203E05     MOV #0x3E0, W5
002598  880C95     MOV W5, OC4RS
77:                    hsync=NTSC_HPULSE;
00259A  88F674     MOV W4, hsync
78:                    vsync=NTSC_LINE_PERIOD-NTSC_HPULSE;
00259C  203AC4     MOV #0x3AC, W4
00259E  88F664     MOV W4, vsync
79:                    video_mode=NTSC_MODE;
0025A0  EF3EC8     CLR video_mode
80:                    frames_per_second=NTSC_FRAMES_PER_SECOND;
0025A2  2003C4     MOV #0x3C, W4
0025A4  88F654     MOV W4, frames_per_second
81:                }//f()
0025A6  060000     RETURN
82:                
83:                void pal_init(){
84:                    VIDPR = PAL_LINE_PERIOD;
0025A8  204005     MOV #0x400, W5
0025AA  880865     MOV W5, PR2
85:                    VSYNCR= PAL_HPULSE;
0025AC  2004B4     MOV #0x4B, W4
0025AE  880C14     MOV W4, OC1R
86:                    VSYNCRS=PAL_LINE_PERIOD;
0025B0  880C05     MOV W5, OC1RS
87:                    VDLYR=PAL_VIDEO_DELAY;
0025B2  200C35     MOV #0xC3, W5
0025B4  880CA5     MOV W5, OC4R
88:                    VDLYRS=PAL_LINE_PERIOD-PAL_FRONT_PORCH;
0025B6  203E65     MOV #0x3E6, W5
0025B8  880C95     MOV W5, OC4RS
89:                    hsync=PAL_HPULSE;
0025BA  88F674     MOV W4, hsync
90:                    vsync=PAL_LINE_PERIOD-PAL_HPULSE;
0025BC  203B44     MOV #0x3B4, W4
0025BE  88F664     MOV W4, vsync
91:                    video_mode=PAL_MODE;
0025C0  200014     MOV #0x1, W4
0025C2  88F644     MOV W4, video_mode
92:                    frames_per_second=PAL_FRAMES_PER_SECOND;
0025C4  200324     MOV #0x32, W4
0025C6  88F654     MOV W4, frames_per_second
93:                }//f()
0025C8  060000     RETURN
94:                
95:                void  video_init(){ // initialisation sorties NTSC
96:                    VIDTMR.TON=0; // désactivation TIMER2
0025CA  A9E111     BCLR 0x111, #7
97:                    if (P_VIDEO_MODE){
0025CC  801655     MOV PORTB, W5
0025CE  210004     MOV #0x1000, W4
0025D0  628204     AND W5, W4, W4
0025D2  320002     BRA Z, 0x25D8
98:                        ntsc_init();
0025D4  07FFD9     RCALL ntsc_init
0025D6  370001     BRA 0x25DA
99:                    }else{
100:                       pal_init();
0025D8  07FFE7     RCALL pal_init
101:                   }
102:                   //  video sync OC mode
103:                   VSYNCCON.OCM=5; // mode 5, timer 2
0025DA  800C24     MOV OC1CON, W4
0025DC  A00004     BSET W4, #0
0025DE  A11004     BCLR W4, #1
0025E0  A02004     BSET W4, #2
0025E2  880C24     MOV W4, OC1CON
104:                   //video delay change notification interrupt enable on that pin.
105:                   PIXIE=1;
0025E4  A8A062     BSET CNEN2, #5
106:                   // video sync interrupt enabling
107:                   VSYNCIF=0;
0025E6  A9E084     BCLR IFS0, #7
108:                   VSYNCIE=1;
0025E8  A8E094     BSET IEC0, #7
109:                   // SPIx configuration (pixels output)
110:                   PIXCON1.DISSCK=1;
0025EA  A88243     BSET 0x243, #4
111:                   PIXCON1.MSTEN=1;
0025EC  A8A242     BSET SPI1CON1, #5
112:                   PIXCON1.SPRE=5;
0025EE  801214     MOV SPI1CON1, W4
0025F0  A02004     BSET W4, #2
0025F2  A13004     BCLR W4, #3
0025F4  A04004     BSET W4, #4
0025F6  881214     MOV W4, SPI1CON1
113:                   PIXCON1.PPRE=3;
0025F8  200030     MOV #0x3, W0
0025FA  B72242     IOR SPI1CON1
114:                   PIXCON2.SPIBEN=1;  // enhanced buffer mode
0025FC  A80244     BSET SPI1CON2, #0
115:                   PIXSTAT.SPIEN=1;
0025FE  A8E241     BSET 0x241, #7
116:                   VIDTMR.TON=1;
002600  A8E111     BSET 0x111, #7
117:               }//horz_sync_init()
002602  060000     RETURN
118:               
119:               void  wait_n_frame(unsigned n){
120:               unsigned long f0;
121:                   f0=frame_cntr+n;
002604  80F6A4     MOV frame_cntr, W4
002606  80F6B5     MOV 0x1ED6, W5
002608  420000     ADD W4, W0, W0
00260A  4A80E0     ADDC W5, #0x0, W1
122:                   while (frame_cntr<f0);
00260C  80F6A4     MOV frame_cntr, W4
00260E  80F6B5     MOV 0x1ED6, W5
002610  500F84     SUB W0, W4, [W15]
002612  588F85     SUBB W1, W5, [W15]
002614  3EFFFB     BRA GTU, 0x260C
123:               }//f()
002616  060000     RETURN
124:               
125:               void  blank_out(unsigned state){
126:                   if (!state){
002618  500FE0     SUB W0, #0x0, [W15]
00261A  3A0002     BRA NZ, 0x2620
127:                       flags &= ~F_BLANK;
00261C  A99ED2     BCLR flags, #4
00261E  370001     BRA 0x2622
128:                   }else{
129:                       flags |=F_BLANK;
002620  A89ED2     BSET flags, #4
130:                   }
131:               }//f()
002622  060000     RETURN
132:               
133:               
134:               // video sync signal generation
135:               void __attribute__((interrupt,no_auto_psv,shadow)) _VSYNC_ISR(void){
002624  FEA000     PUSH.S
002626  BE9F84     MOV.D W4, [W15++]
136:                   frame_line_cntr++;
002628  80F684     MOV frame_line_cntr, W4
00262A  E80204     INC W4, W4
00262C  88F684     MOV W4, frame_line_cntr
137:                   switch (frame_line_cntr){
00262E  200375     MOV #0x37, W5
002630  520F85     SUB W4, W5, [W15]
002632  320030     BRA Z, 0x2694
002634  3E0007     BRA GTU, 0x2644
002636  520FE4     SUB W4, #0x4, [W15]
002638  320019     BRA Z, 0x266C
00263A  520FFE     SUB W4, #0x1E, [W15]
00263C  32001C     BRA Z, 0x2676
00263E  520FE1     SUB W4, #0x1, [W15]
002640  3A004D     BRA NZ, 0x26DC
002642  37000F     BRA 0x2662
002644  201075     MOV #0x107, W5
002646  520F85     SUB W4, W5, [W15]
002648  320034     BRA Z, 0x26B2
00264A  3E0004     BRA GTU, 0x2654
00264C  5282F1     SUB W5, #0x11, W5
00264E  520F85     SUB W4, W5, [W15]
002650  3A0045     BRA NZ, 0x26DC
002652  37001A     BRA 0x2688
002654  2010F5     MOV #0x10F, W5
002656  520F85     SUB W4, W5, [W15]
002658  320026     BRA Z, 0x26A6
00265A  201395     MOV #0x139, W5
00265C  520F85     SUB W4, W5, [W15]
00265E  3A003E     BRA NZ, 0x26DC
002660  370033     BRA 0x26C8
138:                       case 1:
139:                           VSYNCR=vsync;
002662  F81ECC     PUSH vsync
002664  F90182     POP OC1R
140:                           VDLYCONR &=0xF8;
002666  200F80     MOV #0xF8, W0
002668  B62196     AND OC4CON
141:                           break;
00266A  370038     BRA 0x26DC
142:                       case 4:
143:                           VDLYCONR |=5;
00266C  200050     MOV #0x5, W0
00266E  B72196     IOR OC4CON
144:                           VSYNCR=hsync;
002670  F81ECE     PUSH hsync
002672  F90182     POP OC1R
145:                           break;
002674  370033     BRA 0x26DC
146:                       case NTSC_FIRST_VISIBLE:
147:                           if (video_mode==NTSC_MODE && !(flags&F_BLANK)){
002676  80F644     MOV video_mode, W4
002678  520FE0     SUB W4, #0x0, [W15]
00267A  3A0030     BRA NZ, 0x26DC
00267C  AB9ED2     BTST flags, #4
00267E  3A002E     BRA NZ, 0x26DC
148:                               VDLYIF=0;
002680  A96086     BCLR IFS1, #3
149:                               VDLYIE=1;
002682  A86096     BSET IEC1, #3
150:                               flags &= ~F_RETRACE;
002684  A97ED2     BCLR flags, #3
002686  37002A     BRA 0x26DC
151:                           }
152:                           break;
153:                       case NTSC_LAST_VISIBLE:
154:                           if (video_mode==NTSC_MODE){
002688  80F644     MOV video_mode, W4
00268A  520FE0     SUB W4, #0x0, [W15]
00268C  3A0027     BRA NZ, 0x26DC
155:                               VDLYIE=0;
00268E  A96096     BCLR IEC1, #3
156:                               flags |= F_RETRACE;
002690  A87ED2     BSET flags, #3
002692  370024     BRA 0x26DC
157:                           }
158:                           break;
159:                       case PAL_FIRST_VISIBLE:
160:                           if (video_mode==PAL_MODE && !(flags&F_BLANK)){
002694  80F644     MOV video_mode, W4
002696  520FE1     SUB W4, #0x1, [W15]
002698  3A0021     BRA NZ, 0x26DC
00269A  AB9ED2     BTST flags, #4
00269C  3A001F     BRA NZ, 0x26DC
161:                               VDLYIF=0;
00269E  A96086     BCLR IFS1, #3
162:                               VDLYIE=1;
0026A0  A86096     BSET IEC1, #3
163:                               flags &= ~F_RETRACE;
0026A2  A97ED2     BCLR flags, #3
0026A4  37001B     BRA 0x26DC
164:                           }
165:                           break;
166:                       case PAL_LAST_VISIBLE:
167:                           if (video_mode==PAL_MODE){
0026A6  80F644     MOV video_mode, W4
0026A8  520FE1     SUB W4, #0x1, [W15]
0026AA  3A0018     BRA NZ, 0x26DC
168:                               VDLYIE=0;
0026AC  A96096     BCLR IEC1, #3
169:                               flags |= F_RETRACE;
0026AE  A87ED2     BSET flags, #3
0026B0  370015     BRA 0x26DC
170:                           }
171:                           break;
172:                       case NTSC_LINES_PER_FRAME+1:
173:                           if (video_mode==NTSC_MODE){
0026B2  80F644     MOV video_mode, W4
0026B4  520FE0     SUB W4, #0x0, [W15]
0026B6  3A0012     BRA NZ, 0x26DC
174:                               frame_line_cntr=0;
0026B8  EF3ED0     CLR frame_line_cntr
175:                               frame_cntr++;
0026BA  80F6A4     MOV frame_cntr, W4
0026BC  80F6B5     MOV 0x1ED6, W5
0026BE  420261     ADD W4, #0x1, W4
0026C0  4A82E0     ADDC W5, #0x0, W5
0026C2  88F6A4     MOV W4, frame_cntr
0026C4  88F6B5     MOV W5, 0x1ED6
0026C6  37000A     BRA 0x26DC
176:                           }
177:                           break;
178:                       case PAL_LINES_PER_FRAME+1:
179:                           if (video_mode==PAL_MODE){
0026C8  80F644     MOV video_mode, W4
0026CA  520FE1     SUB W4, #0x1, [W15]
0026CC  3A0007     BRA NZ, 0x26DC
180:                               frame_line_cntr=0;
0026CE  EF3ED0     CLR frame_line_cntr
181:                               frame_cntr++;
0026D0  80F6A4     MOV frame_cntr, W4
0026D2  80F6B5     MOV 0x1ED6, W5
0026D4  420261     ADD W4, #0x1, W4
0026D6  4A82E0     ADDC W5, #0x0, W5
0026D8  88F6A4     MOV W4, frame_cntr
0026DA  88F6B5     MOV W5, 0x1ED6
182:                           }
183:                           break;
184:                   }//switch
185:                   VSYNCIF=0;
0026DC  A9E084     BCLR IFS0, #7
186:               }// _VSYNC_ISR()
0026DE  BE024F     MOV.D [--W15], W4
0026E0  FE8000     POP.S
0026E2  064000     RETFIE
187:               
188:               void __attribute__((interrupt,no_auto_psv,shadow)) _VIDEO_OUT_ISR(void){
0026E4  FEA000     PUSH.S
0026E6  BE9F84     MOV.D W4, [W15++]
0026E8  BE9F86     MOV.D W6, [W15++]
0026FE  B9337B     MUL.SU W6, #27, W6
002700  207FF4     MOV #0x7FF, W4
002702  430304     ADD W6, W4, W6
189:                   int y,x;
190:                   if (PIXDLY_INP){
0026EA  AB22CB     BTST 0x2CB, #1
0026EC  320016     BRA Z, 0x271A
191:                       if (video_mode==NTSC_MODE){
0026EE  80F644     MOV video_mode, W4
0026F0  520FE0     SUB W4, #0x0, [W15]
0026F2  3A0003     BRA NZ, 0x26FA
192:                           y=(frame_line_cntr-NTSC_FIRST_VISIBLE);
0026F4  80F686     MOV frame_line_cntr, W6
0026F6  53037E     SUB W6, #0x1E, W6
0026F8  370002     BRA 0x26FE
193:                       }else{
194:                           y=(frame_line_cntr-PAL_FIRST_VISIBLE);
0026FA  80F686     MOV frame_line_cntr, W6
0026FC  B10376     SUB #0x37, W6
195:                       }
196:                       for (x=0;x<BYTES_PER_LINE;x++){
002704  EB0280     CLR W5
00270E  E80285     INC W5, W5
002710  528FFB     SUB W5, #0x1B, [W15]
002712  3AFFF9     BRA NZ, 0x2706
197:                           while (PIXSTAT.SPITBF);
002706  AB2240     BTST SPI1STAT, #1
002708  3AFFFE     BRA NZ, 0x2706
198:                           PIXBUF=video_buffer[y][x];
00270A  FB0256     SE [++W6], W4
00270C  881244     MOV W4, SPI1BUF
199:                       }//for
200:                       while (PIXSTAT.SPITBF);
002714  AB2240     BTST SPI1STAT, #1
002716  3AFFFE     BRA NZ, 0x2714
201:                       PIXBUF=0;
002718  EF2248     CLR SPI1BUF
202:                   }
203:                   VDLYIF=0;
00271A  A96086     BCLR IFS1, #3
204:               }// _VIDEO_OUT_ISR
00271C  BE034F     MOV.D [--W15], W6
00271E  BE024F     MOV.D [--W15], W4
002720  FE8000     POP.S
002722  064000     RETFIE
205:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/PICvision.c  ------------------------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /* 
20:                 * File:   PICvision.c
21:                 * Author: jacques Deschênes
22:                 * Description:  a simple video game console on PIC24FJ64GA002 MCU
23:                 *               inspiration come from HACKvision console.
24:                 *               REF: https://nootropicdesign.com/hackvision/
25:                 *     - display  NTSC/PAL  monochrome
26:                 *     - resolution  216x216 pixels
27:                 *     - controls: 2 SNES paddle  (cheap and easy to find.)
28:                 *     - audio out:  monophonic  PWM DAC  or square wave tones
29:                 *
30:                 * Created on 25 février 2014, 16:22
31:                 */
32:                
33:                #include "PICvision.h"
34:                #include "PICvision_banner.h"
35:                #include "games/snake_text_mode/snake.h"
36:                
37:                // PIC24FJ64GA002 Configuration Bit Settings
38:                // CONFIG2
39:                #pragma config POSCMOD = HS             // Primary Oscillator Select (HS Oscillator mode selected)
40:                #pragma config I2C1SEL = PRI            // I2C1 Pin Location Select (Use default SCL1/SDA1 pins)
41:                #pragma config IOL1WAY = ON             // IOLOCK Protection (Once IOLOCK is set, cannot be changed)
42:                #pragma config OSCIOFNC = OFF           // Primary Oscillator Output Function (OSC2/CLKO/RC15 functions as CLKO (FOSC/2))
43:                #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor (Clock switching and Fail-Safe Clock Monitor are disabled)
44:                #pragma config FNOSC = PRIPLL           // Oscillator Select (Primary Oscillator with PLL module (HSPLL, ECPLL))
45:                #pragma config SOSCSEL = LPSOSC         // Sec Oscillator Select (Low Power Secondary Oscillator (LPSOSC))
46:                #pragma config WUTSEL = FST             // Wake-up timer Select (Fast Wake-up Timer)
47:                #pragma config IESO = OFF               // Internal External Switch Over Mode (IESO mode (Two-Speed Start-up) disabled)
48:                
49:                // CONFIG1
50:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler (1:32,768)
51:                #pragma config FWPSA = PR128            // WDT Prescaler (Prescaler ratio of 1:128)
52:                #pragma config WINDIS = ON              // Watchdog Timer Window (Standard Watchdog Timer enabled,(Windowed-mode is disabled))
53:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (Watchdog Timer is disabled)
54:                #pragma config ICS = PGx1               // Comm Channel Select (Emulator EMUC1/EMUD1 pins are shared with PGC1/PGD1)
55:                #pragma config GWRP = OFF               // General Code Segment Write Protect (Writes to program memory are allowed)
56:                #pragma config GCP = OFF                // General Code Segment Code Protect (Code protection is disabled)
57:                #pragma config JTAGEN = OFF             // JTAG Port Enable (JTAG port is disabled)
58:                
59:                
60:                void splash_screen(){
0029CA  4787E6     ADD W15, #0x6, W15
0029CC  BE9F88     MOV.D W8, [W15++]
0029CE  BE9F8A     MOV.D W10, [W15++]
0029D0  BE9F8C     MOV.D W12, [W15++]
0029D2  781F8E     MOV W14, [W15++]
0029D8  287EC8     MOV #0x87EC, W8
0029DA  207FEE     MOV #0x7FE, W14
0029DE  78000A     MOV W10, W0
0029E0  2004F4     MOV #0x4F, W4
0029E2  52020A     SUB W4, W10, W4
0029F2  2004F7     MOV #0x4F, W7
0029F4  538103     SUB W7, W3, W2
0029F6  208001     MOV #0x800, W1
0029F8  370008     BRA 0x2A0A
002A0A  B93A78     MUL.SU W7, #24, W4
002A0C  E90204     DEC W4, W4
002A0E  420208     ADD W4, W8, W4
002A10  B9067B     MUL.SU W0, #27, W12
002A12  9FB7FC     MOV W12, [W15-18]
002A14  9FBF8D     MOV W13, [W15-16]
002A16  E8028C     INC W12, W5
002A18  428281     ADD W5, W1, W5
002A1A  37FFEF     BRA 0x29FA
002A24  E90303     DEC W3, W6
002A26  B9337B     MUL.SU W6, #27, W6
002A28  208014     MOV #0x801, W4
002A2A  430204     ADD W6, W4, W4
002A2C  B91B7B     MUL.SU W3, #27, W6
002A2E  470286     ADD W14, W6, W5
61:                    int i,k,first,last,left;
62:                    left=(HPIXELS-PIX_WIDTH)/16+1;
63:                    last=0;
0029D4  EB0500     CLR W10
64:                    while (last<(VPIXELS-PIX_HEIGHT)/2+PIX_HEIGHT){
002A3C  200944     MOV #0x94, W4
002A3E  550F84     SUB W10, W4, [W15]
002A40  3AFFCE     BRA NZ, 0x29DE
65:                        first=max(0,PIX_HEIGHT-last-1);
0029E4  3B0001     BRA NN, 0x29E8
0029E6  EB0200     CLR W4
66:                        for (i=0;i<PIX_HEIGHT-first;i++){
0029D6  28F6BB     MOV #0x8F6B, W11
0029E8  200503     MOV #0x50, W3
0029EA  518184     SUB W3, W4, W3
0029EC  A94042     BCLR SR, #2
0029EE  340016     BRA LE, 0x2A1C
0029F0  78030B     MOV W11, W6
002A06  538F82     SUB W7, W2, [W15]
002A08  32000A     BRA Z, 0x2A1E
002A1C  EB0180     CLR W3
67:                            for (k=0;k<ARRAY_WIDTH;k++){
0029FC  520F86     SUB W4, W6, [W15]
0029FE  3AFFFD     BRA NZ, 0x29FA
002A00  E90387     DEC W7, W7
002A02  E90000     DEC W0, W0
002A04  530378     SUB W6, #0x18, W6
68:                                video_buffer[last-i][left+k]=PICVISION_BANNER[PIX_HEIGHT-1-i][k];
0029FA  786AD4     MOV.B [++W4], [++W5]
69:                            }//for
70:                        }//for
71:                        if (last-i>0){
002A1E  550183     SUB W10, W3, W3
002A20  A94042     BCLR SR, #2
002A22  340009     BRA LE, 0x2A36
72:                            for (k=0;k<ARRAY_WIDTH;k++){
002A32  520F85     SUB W4, W5, [W15]
002A34  3AFFFD     BRA NZ, 0x2A30
73:                                video_buffer[last-i-1][left+k]=0;
0029DC  EB4480     CLR.B W9
002A30  786A09     MOV.B W9, [++W4]
74:                            }//for
75:                        }//if
76:                        wait_n_frame(1);
002A36  200010     MOV #0x1, W0
002A38  07FDE5     RCALL wait_n_frame
77:                        last++;
002A3A  E8050A     INC W10, W10
78:                    }//while
79:                    set_curpos(left,last/8+2);
002A42  200141     MOV #0x14, W1
002A44  200020     MOV #0x2, W0
002A46  07FC5A     RCALL set_curpos
80:                    print("Copyright 2014, Jacques Deschenes");
002A48  294980     MOV #0x9498, W0
002A4A  07FBDB     RCALL print
81:                    wait_n_frame(180);
002A4C  200B40     MOV #0xB4, W0
002A4E  07FDDA     RCALL wait_n_frame
82:                }//f()
002A50  78074F     MOV [--W15], W14
002A52  BE064F     MOV.D [--W15], W12
002A54  BE054F     MOV.D [--W15], W10
002A56  BE044F     MOV.D [--W15], W8
002A58  B1006F     SUB #0x6, W15
002A5A  060000     RETURN
83:                
84:                
85:                void PICvision_init(void) {
86:                    HardwareConfig();
002A5C  070033     RCALL HardwareConfig
87:                    timers_init(TICK_FREQ);
002A5E  200640     MOV #0x64, W0
002A60  07FCA6     RCALL timers_init
88:                    video_init();
002A62  07FDB3     RCALL video_init
89:                    sound_init(1000/TICK_FREQ);
002A64  2000A0     MOV #0xA, W0
002A66  07FE6A     RCALL sound_init
90:                    splash_screen();
002A68  07FFB0     RCALL splash_screen
91:                }//f()
002A6A  060000     RETURN
92:                
93:                
94:                int main(void){
002A6C  BE9F88     MOV.D W8, [W15++]
002A6E  781F8A     MOV W10, [W15++]
95:                   menu_t *games_list;
96:                   int selected;
97:                   PICvision_init();
002A70  07FFF5     RCALL PICvision_init
98:                   games_list=create_menu("SELECT GAME");
002A72  294BA0     MOV #0x94BA, W0
002A74  07FF0D     RCALL create_menu
002A76  780400     MOV W0, W8
99:                   add_menu_item("snake text mode",1,games_list);
002A78  780108     MOV W8, W2
002A7A  200011     MOV #0x1, W1
002A7C  294C60     MOV #0x94C6, W0
002A7E  07FF14     RCALL add_menu_item
100:                  add_menu_item("game 2",2,games_list);
002A80  780108     MOV W8, W2
002A82  200021     MOV #0x2, W1
002A84  294D60     MOV #0x94D6, W0
002A86  07FF10     RCALL add_menu_item
101:                  add_menu_item("game 3",3,games_list);
002A88  780108     MOV W8, W2
002A8A  200031     MOV #0x3, W1
002A8C  294DD0     MOV #0x94DD, W0
002A8E  07FF0C     RCALL add_menu_item
102:                  while(1){
103:                      clear_screen();
002A94  07FBAF     RCALL clear_screen
104:                      selected=run_menu(games_list,10,(27-5)/2,PADDLE1);
002A96  200013     MOV #0x1, W3
002A98  2000B2     MOV #0xB, W2
002A9A  2000A1     MOV #0xA, W1
002A9C  780008     MOV W8, W0
002A9E  07FF52     RCALL run_menu
105:                      switch(selected){
002AA0  500FE2     SUB W0, #0x2, [W15]
002AA2  320006     BRA Z, 0x2AB0
002AA4  500FE3     SUB W0, #0x3, [W15]
002AA6  320009     BRA Z, 0x2ABA
002AA8  500FE1     SUB W0, #0x1, [W15]
002AAA  3AFFF4     BRA NZ, 0x2A94
106:                          case 1:
107:                              snake_game_tm();
002AAC  07FA49     RCALL snake_game_tm
108:                              break;
002AAE  37FFF2     BRA 0x2A94
109:                          case 2:
110:                              set_curpos(0,0);
002AB0  B80060     MUL.UU W0, #0, W0
002AB2  07FC24     RCALL set_curpos
111:                              print("game 2");
002A92  294D6A     MOV #0x94D6, W10
002AB4  78000A     MOV W10, W0
002AB6  07FBA5     RCALL print
112:                              break;
002AB8  37FFED     BRA 0x2A94
113:                          case 3:
114:                              set_curpos(0,0);
002ABA  B80060     MUL.UU W0, #0, W0
002ABC  07FC1F     RCALL set_curpos
115:                              print("game 3");
002A90  294DD9     MOV #0x94DD, W9
002ABE  780009     MOV W9, W0
002AC0  07FBA0     RCALL print
002AC2  37FFE8     BRA 0x2A94
116:                              break;
117:                      }//switch
118:                  }//while
119:                  return 0;
120:               }//main()
121:               
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/Hardware/hardwareProfile.c  ---------------------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   hardwareProfile.h
21:                 * Author: jacques Deschênes
22:                 * Description:  try to centralize  hardware specific.
23:                 * Created on 1 march 2014
24:                 */
25:                
26:                #include "hardwareProfile.h"
27:                
28:                void HardwareConfig(){
29:                    // peripheral to pin association.
30:                    PPSUnLock;
002AC4  803A16     MOV OSCCON, W6
002AC6  B20BF6     AND #0xBF, W6
002AC8  200464     MOV #0x46, W4
002ACA  200575     MOV #0x57, W5
002ACC  207427     MOV #0x742, W7
002ACE  784B84     MOV.B W4, [W7]
002AD0  784B85     MOV.B W5, [W7]
002AD2  784B86     MOV.B W6, [W7]
31:                    PPSOutput(PPS_RP5,PPS_SDO1);   // video pixels output
002AD4  803626     MOV RPOR2, W6
002AD6  2E0FF7     MOV #0xE0FF, W7
002AD8  630307     AND W6, W7, W6
002ADA  207000     MOV #0x700, W0
002ADC  730300     IOR W6, W0, W6
002ADE  883626     MOV W6, RPOR2
32:                    PPSOutput(PPS_RP6,PPS_OC4);  // video delay output
002AE0  803630     MOV RPOR3, W0
002AE2  2FFE06     MOV #0xFFE0, W6
002AE4  600006     AND W0, W6, W0
002AE6  B30150     IOR #0x15, W0
002AE8  883630     MOV W0, RPOR3
33:                    PPSOutput(PPS_RP7,PPS_OC1);  // video sync output
002AEA  803630     MOV RPOR3, W0
002AEC  600387     AND W0, W7, W7
002AEE  212000     MOV #0x1200, W0
002AF0  738380     IOR W7, W0, W7
002AF2  883637     MOV W7, RPOR3
34:                    PPSOutput(PPS_RP8,PPS_OC2);  // audio output
002AF4  803647     MOV RPOR4, W7
002AF6  638306     AND W7, W6, W6
002AF8  B30136     IOR #0x13, W6
002AFA  883646     MOV W6, RPOR4
35:                    PPSLock;
002AFC  803A16     MOV OSCCON, W6
002AFE  A06006     BSET W6, #6
002B00  207427     MOV #0x742, W7
002B02  784B84     MOV.B W4, [W7]
002B04  784B85     MOV.B W5, [W7]
002B06  784B86     MOV.B W6, [W7]
36:                    // pins data direction
37:                    P_PIXEL_OUT_TRIS=0;     // video pixels output
002B08  A9A2C8     BCLR TRISB, #5
38:                    P_VDLY_OUT_TRIS=0;     // video delay output
002B0A  A9C2C8     BCLR TRISB, #6
39:                    P_VSYNC_OUT_TRIS=0;     // video sync output
002B0C  A9E2C8     BCLR TRISB, #7
40:                    P_AUDIO_OUT_TRIS=0;     // audio output
002B0E  A902C9     BCLR 0x2C9, #0
41:                    P_NOISE_OUT_TRIS=0;     /// white noise output
002B10  A942C9     BCLR 0x2C9, #2
42:                    P_PIXDLY_IN_TRIS=1;     //input video pixels delay
002B12  A822C9     BSET 0x2C9, #1
43:                    P_VIDEO_MODE_TRIS=1;    //input NTSC/PAL select input
002B14  A882C9     BSET 0x2C9, #4
44:                    VIDMODE_ANDIS=1;   // disable ADC  on NTSC/PAL select input.
002B16  A8832D     BSET 0x32D, #4
45:                    // paddles interface I/O setting
46:                    P_PDL1_DAT_TRIS=1;      // paddle 1 data as input
002B18  A802C0     BSET TRISA, #0
47:                    P_PDL2_DAT_TRIS=1;      // paddle 2 data as input
002B1A  A822C0     BSET TRISA, #1
48:                    P_PDL_CLK_TRIS=0;       // paddles clock signal as output
002B1C  A902C8     BCLR TRISB, #0
49:                    P_PDL_LATCH_TRIS=0;     // paddles latch signal as output
002B1E  A922C8     BCLR TRISB, #1
50:                    P_PDL1_ANDIS=1;         // disable analog input
002B20  A8032C     BSET AD1PCFG, #0
51:                    P_PDL2_ANDIS=1;         // disable analog input
002B22  A8232C     BSET AD1PCFG, #1
52:                    // interrupts priorities
53:                    VSYNCIP=7;  // timer interrupt used for video output must have highest priority
002B24  270000     MOV #0x7000, W0
002B26  B720A6     IOR IPC1
54:                    PIXIP=7;  // change notification interrupt used for video pixels must have highest priority
002B28  B720AC     IOR IPC4
55:                    AUDIOIP=3; // audio output timer interrupt priority
002B2A  800544     MOV IPC2, W4
002B2C  B30034     IOR #0x3, W4
002B2E  A12004     BCLR W4, #2
002B30  880544     MOV W4, IPC2
56:                    SYSTICKIP=2; // system ticks timer interrupt priority
002B32  800524     MOV IPC0, W4
002B34  A1C004     BCLR W4, #12
002B36  A0D004     BSET W4, #13
002B38  A1E004     BCLR W4, #14
002B3A  880524     MOV W4, IPC0
57:                }//f()
002B3C  060000     RETURN
58:                
---  /home/jacques/MPLABXProjects/PICvision/PICvision.X/Hardware/controllers/SNES/snes_paddle.c  --------
1:                 /*
2:                 * Copyright 2014, Jacques Deschênes
3:                 * This file is part of PICvision.
4:                 *
5:                 *     PICvision is free software: you can redistribute it and/or modify
6:                 *     it under the terms of the GNU General Public License as published by
7:                 *     the Free Software Foundation, either version 3 of the License, or
8:                 *     (at your option) any later version.
9:                 *
10:                *     PICvision is distributed in the hope that it will be useful,
11:                *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                *     GNU General Public License for more details.
14:                *
15:                *     You should have received a copy of the GNU General Public License
16:                *     along with PICvision.  If not, see <http://www.gnu.org/licenses/>.
17:                */
18:                
19:                /*
20:                 * File:   snes_paddle.c
21:                 * Author: jacques Deschênes
22:                 * Description:  SNES gemepad interface
23:                 *              1) a pulse on paddle latch input store last switches state in shift register
24:                 *              2) each rising edge of clock signal shift one bit out, bit 0 first.
25:                 *                 bit 0 is at output after latch so there is only 15 shift to do.
26:                 * Created on 25 février 2014, 16:41
27:                 */
28:                
29:                #include <stdlib.h>
30:                #include "snes_paddle.h"
31:                //#include "TVout.h"
32:                
33:                
34:                
35:                // the loop execute in 4 Tcy
36:                #define mDelay(usec) asm(" MOV #%0, W4\n NOP\n DEC W4,W4\n BRA NZ .-4"::"i"(usec))
37:                
38:                void latch(){
39:                    P_PDL_LATCH=1;
002B3E  A822CC     BSET LATB, #1
40:                    mDelay(CYCLES_PER_USEC/4);
002B40  200044     MOV #0x4, W4
002B42  000000     NOP
002B44  E90204     DEC W4, W4
002B46  3AFFFD     BRA NZ, 0x2B42
41:                    P_PDL_LATCH=0;
002B48  A922CC     BCLR LATB, #1
42:                    mDelay(CYCLES_PER_USEC/4);
002B4A  200044     MOV #0x4, W4
002B4C  000000     NOP
002B4E  E90204     DEC W4, W4
002B50  3AFFFD     BRA NZ, 0x2B4C
43:                }//f()
002B52  060000     RETURN
44:                
45:                void bit_shift(){
46:                    P_PDL_CLK=1;
002B54  A802CC     BSET LATB, #0
47:                    mDelay(CYCLES_PER_USEC/4);
002B56  200044     MOV #0x4, W4
002B58  000000     NOP
002B5A  E90204     DEC W4, W4
002B5C  3AFFFD     BRA NZ, 0x2B58
48:                    P_PDL_CLK=0;
002B5E  A902CC     BCLR LATB, #0
49:                    mDelay(CYCLES_PER_USEC/4);
002B60  200044     MOV #0x4, W4
002B62  000000     NOP
002B64  E90204     DEC W4, W4
002B66  3AFFFD     BRA NZ, 0x2B62
50:                }// f()
002B68  060000     RETURN
51:                
52:                unsigned read_paddle(int paddleId) {
002B6A  BE9F88     MOV.D W8, [W15++]
002B6C  BE9F8A     MOV.D W10, [W15++]
002B6E  BE9F8C     MOV.D W12, [W15++]
002B70  780680     MOV W0, W13
53:                    unsigned i,pdata, p1,p2;
54:                    p1=0;
002B76  780509     MOV W9, W10
55:                    p2=0;
002B74  EB0480     CLR W9
56:                    latch(); // latch data in paddles shift register
002B72  07FFE5     RCALL latch
57:                    // shift out is least significant bit first.
58:                    for (i=0;i<15;i++){ // SNES paddle have 16 bits shift register
002B78  780409     MOV W9, W8
002B92  E80408     INC W8, W8
002B94  540FEF     SUB W8, #0xF, [W15]
002B96  3AFFF3     BRA NZ, 0x2B7E
59:                        pdata=PADDLES_DATA_PORT;
002B7E  801614     MOV PORTA, W4
60:                        p1 |= (pdata&PADDLE1)<<i;
002B80  6202E1     AND W4, #0x1, W5
002B82  DD2A88     SL W5, W8, W5
002B84  750505     IOR W10, W5, W10
61:                        p2 |= (pdata&PADDLE2)?1<<i:0;
002B7A  EB0580     CLR W11
002B7C  20001C     MOV #0x1, W12
002B86  620262     AND W4, #0x2, W4
002B88  78028B     MOV W11, W5
002B8A  320001     BRA Z, 0x2B8E
002B8C  DD6288     SL W12, W8, W5
002B8E  748485     IOR W9, W5, W9
62:                        bit_shift();
002B90  07FFE1     RCALL bit_shift
63:                    }
64:                    return paddleId==1?(~p1)&0xfff:(~p2)&0xfff;
002B98  568FE1     SUB W13, #0x1, [W15]
002B9A  3A0004     BRA NZ, 0x2BA4
002B9C  EA800A     COM W10, W0
002B9E  20FFF4     MOV #0xFFF, W4
002BA0  600004     AND W0, W4, W0
002BA2  370003     BRA 0x2BAA
002BA4  EA8009     COM W9, W0
002BA6  20FFF4     MOV #0xFFF, W4
002BA8  600004     AND W0, W4, W0
65:                }//f()
002BAA  BE064F     MOV.D [--W15], W12
002BAC  BE054F     MOV.D [--W15], W10
002BAE  BE044F     MOV.D [--W15], W8
002BB0  060000     RETURN
66:                
